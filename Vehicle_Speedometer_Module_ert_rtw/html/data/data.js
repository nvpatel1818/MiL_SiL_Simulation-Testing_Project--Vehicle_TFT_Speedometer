var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":true},"build":"Vehicle_Speedometer_Module","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: ert_main.c\n *\n * Code generated for Simulink model 'Vehicle_Speedometer_Module'.\n *\n * Model version                  : 1.35\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 04:03:56 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include <stddef.h>\n#include <stdio.h>            /* This example main program uses printf/fflush */\n#include \"Vehicle_Speedometer_Module.h\" /* Model header file */\n\n/*\n * Associating rt_OneStep with a real-time clock or interrupt service routine\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\n * always associated with the base rate of the model.  Subrates are managed\n * by the base rate from inside the generated code.  Enabling/disabling\n * interrupts and floating point context switches are target specific.  This\n * example code indicates where these should take place relative to executing\n * the generated code step function.  Overrun behavior should be tailored to\n * your application needs.  This example simply sets an error status in the\n * real-time model and returns from rt_OneStep.\n */\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag = false;\n\n  /* Disable interrupts here */\n\n  /* Check for overrun */\n  if (OverrunFlag) {\n    rtmSetErrorStatus(Vehicle_Speedometer_Module_M, \"Overrun\");\n    return;\n  }\n\n  OverrunFlag = true;\n\n  /* Save FPU context here (if necessary) */\n  /* Re-enable timer or interrupt here */\n  /* Set model inputs here */\n\n  /* Step the model */\n  Vehicle_Speedometer_Module_step();\n\n  /* Get model outputs here */\n\n  /* Indicate task complete */\n  OverrunFlag = false;\n\n  /* Disable interrupts here */\n  /* Restore FPU context here (if necessary) */\n  /* Enable interrupts here */\n}\n\n/*\n * The example main function illustrates what is required by your\n * application code to initialize, execute, and terminate the generated code.\n * Attaching rt_OneStep to a real-time clock is target specific. This example\n * illustrates how you do this relative to initializing the model.\n */\nint_T main(int_T argc, const char *argv[])\n{\n  /* Unused arguments */\n  (void)(argc);\n  (void)(argv);\n\n  /* Initialize model */\n  Vehicle_Speedometer_Module_initialize();\n\n  /* Attach rt_OneStep to a timer or interrupt service routine with\n   * period 0.01 seconds (base rate of the model) here.\n   * The call syntax for rt_OneStep is\n   *\n   *  rt_OneStep();\n   */\n  printf(\"Warning: The simulation will run forever. \"\n         \"Generated ERT main won't simulate model step behavior. \"\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\n  fflush((NULL));\n  while (rtmGetErrorStatus(Vehicle_Speedometer_Module_M) == (NULL)) {\n    /*  Perform application tasks here */\n  }\n\n  /* Terminate model */\n  Vehicle_Speedometer_Module_terminate();\n  return 0;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Vehicle_Speedometer_Module.c","type":"source","group":"model","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Vehicle_Speedometer_Module.c\n *\n * Code generated for Simulink model 'Vehicle_Speedometer_Module'.\n *\n * Model version                  : 1.35\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 04:03:56 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"Vehicle_Speedometer_Module.h\"\n#include \"rtwtypes.h\"\n#include \"Vehicle_Speedometer_Module_private.h\"\n\n/* Block signals (default storage) */\nB_Vehicle_Speedometer_Module_T Vehicle_Speedometer_Module_B;\n\n/* External inputs (root inport signals with default storage) */\nExtU_Vehicle_Speedometer_Modu_T Vehicle_Speedometer_Module_U;\n\n/* External outputs (root outports fed by signals with default storage) */\nExtY_Vehicle_Speedometer_Modu_T Vehicle_Speedometer_Module_Y;\n\n/* Real-time model */\nstatic RT_MODEL_Vehicle_Speedometer__T Vehicle_Speedometer_Module_M_;\nRT_MODEL_Vehicle_Speedometer__T *const Vehicle_Speedometer_Module_M =\n  &Vehicle_Speedometer_Module_M_;\n\n/* Model step function */\nvoid Vehicle_Speedometer_Module_step(void)\n{\n  int16_T rtb_Add;\n  uint16_T rtb_Add_0;\n  uint16_T tmp;\n\n  /* Outputs for Atomic SubSystem: '<Root>/Speedometer_Module' */\n  /* Saturate: '<S5>/Saturation' incorporates:\n   *  Inport: '<Root>/Avg_VehicleSpeed'\n   */\n  if (Vehicle_Speedometer_Module_U.Avg_VehicleSpeed > 25000) {\n    /* Saturate: '<S5>/Saturation' */\n    Vehicle_Speedometer_Module_Y.Out_VehicleSpeed_Display = 25000U;\n  } else if (Vehicle_Speedometer_Module_U.Avg_VehicleSpeed < 200) {\n    /* Saturate: '<S5>/Saturation' */\n    Vehicle_Speedometer_Module_Y.Out_VehicleSpeed_Display = 200U;\n  } else {\n    /* Saturate: '<S5>/Saturation' */\n    Vehicle_Speedometer_Module_Y.Out_VehicleSpeed_Display =\n      Vehicle_Speedometer_Module_U.Avg_VehicleSpeed;\n  }\n\n  /* End of Saturate: '<S5>/Saturation' */\n\n  /* Outputs for Enabled SubSystem: '<S1>/Auxilliary_Data_Filtering' incorporates:\n   *  EnablePort: '<S2>/Enable'\n   */\n  /* Outputs for Enabled SubSystem: '<S1>/Main_Data_Filtering' incorporates:\n   *  EnablePort: '<S6>/Enable'\n   */\n  /* RelationalOperator: '<S3>/Compare' incorporates:\n   *  Constant: '<S3>/Constant'\n   *  Inport: '<Root>/Timer_Input'\n   *  Math: '<S1>/Rem'\n   */\n  if ((uint16_T)(Vehicle_Speedometer_Module_U.Timer_Input % 10) == 0) {\n    /* Product: '<S6>/Divide' incorporates:\n     *  Gain: '<S6>/Gain'\n     *  Inport: '<Root>/In_MainFilt_SpeedValue'\n     *  Saturate: '<S5>/Saturation'\n     */\n    if (Vehicle_Speedometer_Module_U.In_MainFilt_SpeedValue == 0U) {\n      rtb_Add_0 = MAX_uint16_T;\n\n      /* Divide by zero handler */\n    } else {\n      rtb_Add_0 = (uint16_T)((uint32_T)(uint16_T)((((65U *\n        Vehicle_Speedometer_Module_Y.Out_VehicleSpeed_Display) >> 7) * 2684355UL)\n        >> 21) / Vehicle_Speedometer_Module_U.In_MainFilt_SpeedValue);\n    }\n\n    /* Product: '<S2>/Divide' incorporates:\n     *  Constant: '<S6>/Constant'\n     *  Gain: '<S2>/Gain'\n     *  Inport: '<Root>/In_AuxFilt_SpeedValue'\n     *  Product: '<S6>/Divide'\n     *  Sum: '<S6>/Add'\n     */\n    if (Vehicle_Speedometer_Module_U.In_AuxFilt_SpeedValue == 0U) {\n      rtb_Add_0 = MAX_uint16_T;\n\n      /* Divide by zero handler */\n    } else {\n      rtb_Add_0 = (uint16_T)((uint32_T)(uint16_T)(((((uint16_T)(rtb_Add_0 - 5U) *\n        39U) >> 6) * 2684355UL) >> 21) /\n        Vehicle_Speedometer_Module_U.In_AuxFilt_SpeedValue);\n    }\n\n    /* Sum: '<S2>/Add' incorporates:\n     *  Constant: '<S2>/Constant'\n     *  Product: '<S2>/Divide'\n     */\n    Vehicle_Speedometer_Module_B.DisplaySpeed_Filter = (uint16_T)(rtb_Add_0 - 3U);\n  }\n\n  /* End of RelationalOperator: '<S3>/Compare' */\n  /* End of Outputs for SubSystem: '<S1>/Main_Data_Filtering' */\n  /* End of Outputs for SubSystem: '<S1>/Auxilliary_Data_Filtering' */\n\n  /* Sum: '<S4>/Add' incorporates:\n   *  Saturate: '<S5>/Saturation'\n   *  Sum: '<S2>/Add'\n   */\n  rtb_Add_0 = Vehicle_Speedometer_Module_B.DisplaySpeed_Filter;\n  if (Vehicle_Speedometer_Module_B.DisplaySpeed_Filter > 32767) {\n    rtb_Add_0 = 32767U;\n  }\n\n  tmp = Vehicle_Speedometer_Module_Y.Out_VehicleSpeed_Display;\n  if (Vehicle_Speedometer_Module_Y.Out_VehicleSpeed_Display > 32767) {\n    tmp = 32767U;\n  }\n\n  rtb_Add = (int16_T)(rtb_Add_0 - tmp);\n\n  /* End of Sum: '<S4>/Add' */\n\n  /* Abs: '<S4>/Abs' incorporates:\n   *  Sum: '<S4>/Add'\n   */\n  if (rtb_Add < 0) {\n    rtb_Add_0 = (uint16_T)-rtb_Add;\n  } else {\n    rtb_Add_0 = (uint16_T)rtb_Add;\n  }\n\n  /* End of Abs: '<S4>/Abs' */\n\n  /* Switch: '<S4>/Switch' incorporates:\n   *  RelationalOperator: '<S4>/Relational Operator'\n   */\n  if (rtb_Add_0 <= 150) {\n    /* Saturate: '<S5>/Saturation' incorporates:\n     *  Outport: '<Root>/Out_VehicleSpeed_Display'\n     *  Sum: '<S2>/Add'\n     */\n    Vehicle_Speedometer_Module_Y.Out_VehicleSpeed_Display =\n      Vehicle_Speedometer_Module_B.DisplaySpeed_Filter;\n  }\n\n  /* End of Switch: '<S4>/Switch' */\n  /* End of Outputs for SubSystem: '<Root>/Speedometer_Module' */\n}\n\n/* Model initialize function */\nvoid Vehicle_Speedometer_Module_initialize(void)\n{\n  /* (no initialization code required) */\n}\n\n/* Model terminate function */\nvoid Vehicle_Speedometer_Module_terminate(void)\n{\n  /* (no terminate code required) */\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Vehicle_Speedometer_Module.h","type":"header","group":"model","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Vehicle_Speedometer_Module.h\n *\n * Code generated for Simulink model 'Vehicle_Speedometer_Module'.\n *\n * Model version                  : 1.35\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 04:03:56 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Vehicle_Speedometer_Module_h_\n#define RTW_HEADER_Vehicle_Speedometer_Module_h_\n#ifndef Vehicle_Speedometer_Module_COMMON_INCLUDES_\n#define Vehicle_Speedometer_Module_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#endif                         /* Vehicle_Speedometer_Module_COMMON_INCLUDES_ */\n\n#include \"Vehicle_Speedometer_Module_types.h\"\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n/* Block signals (default storage) */\ntypedef struct {\n  uint16_T DisplaySpeed_Filter;        /* '<S2>/Add' */\n} B_Vehicle_Speedometer_Module_T;\n\n/* External inputs (root inport signals with default storage) */\ntypedef struct {\n  uint8_T In_MainFilt_SpeedValue;      /* '<Root>/In_MainFilt_SpeedValue' */\n  uint8_T In_AuxFilt_SpeedValue;       /* '<Root>/In_AuxFilt_SpeedValue' */\n  uint16_T Avg_VehicleSpeed;           /* '<Root>/Avg_VehicleSpeed' */\n  uint16_T Timer_Input;                /* '<Root>/Timer_Input' */\n} ExtU_Vehicle_Speedometer_Modu_T;\n\n/* External outputs (root outports fed by signals with default storage) */\ntypedef struct {\n  uint16_T Out_VehicleSpeed_Display;   /* '<Root>/Out_VehicleSpeed_Display' */\n} ExtY_Vehicle_Speedometer_Modu_T;\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_Vehicle_Speedometer_M_T {\n  const char_T * volatile errorStatus;\n};\n\n/* Block signals (default storage) */\nextern B_Vehicle_Speedometer_Module_T Vehicle_Speedometer_Module_B;\n\n/* External inputs (root inport signals with default storage) */\nextern ExtU_Vehicle_Speedometer_Modu_T Vehicle_Speedometer_Module_U;\n\n/* External outputs (root outports fed by signals with default storage) */\nextern ExtY_Vehicle_Speedometer_Modu_T Vehicle_Speedometer_Module_Y;\n\n/* Model entry point functions */\nextern void Vehicle_Speedometer_Module_initialize(void);\nextern void Vehicle_Speedometer_Module_step(void);\nextern void Vehicle_Speedometer_Module_terminate(void);\n\n/* Real-time Model object */\nextern RT_MODEL_Vehicle_Speedometer__T *const Vehicle_Speedometer_Module_M;\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'Vehicle_Speedometer_Module'\n * '<S1>'   : 'Vehicle_Speedometer_Module/Speedometer_Module'\n * '<S2>'   : 'Vehicle_Speedometer_Module/Speedometer_Module/Auxilliary_Data_Filtering'\n * '<S3>'   : 'Vehicle_Speedometer_Module/Speedometer_Module/Compare To Zero'\n * '<S4>'   : 'Vehicle_Speedometer_Module/Speedometer_Module/Display_Speed_Output'\n * '<S5>'   : 'Vehicle_Speedometer_Module/Speedometer_Module/Input_Processing'\n * '<S6>'   : 'Vehicle_Speedometer_Module/Speedometer_Module/Main_Data_Filtering'\n */\n#endif                            /* RTW_HEADER_Vehicle_Speedometer_Module_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Vehicle_Speedometer_Module_private.h","type":"header","group":"model","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Vehicle_Speedometer_Module_private.h\n *\n * Code generated for Simulink model 'Vehicle_Speedometer_Module'.\n *\n * Model version                  : 1.35\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 04:03:56 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Vehicle_Speedometer_Module_private_h_\n#define RTW_HEADER_Vehicle_Speedometer_Module_private_h_\n#include \"rtwtypes.h\"\n#ifndef UCHAR_MAX\n#include <limits.h>\n#endif\n\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\n#error Code was generated for compiler with different sized uchar/char. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\n#error Code was generated for compiler with different sized ushort/short. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\n#error Code was generated for compiler with different sized uint/int. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n/* Skipping ulong/long check: insufficient preprocessor integer range. */\n#endif                    /* RTW_HEADER_Vehicle_Speedometer_Module_private_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Vehicle_Speedometer_Module_types.h","type":"header","group":"model","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Vehicle_Speedometer_Module_types.h\n *\n * Code generated for Simulink model 'Vehicle_Speedometer_Module'.\n *\n * Model version                  : 1.35\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 04:03:56 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Vehicle_Speedometer_Module_types_h_\n#define RTW_HEADER_Vehicle_Speedometer_Module_types_h_\n\n/* Model Code Variants */\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_Vehicle_Speedometer_M_T RT_MODEL_Vehicle_Speedometer__T;\n\n#endif                      /* RTW_HEADER_Vehicle_Speedometer_Module_types_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtwtypes.h\n *\n * Code generated for Simulink model 'Vehicle_Speedometer_Module'.\n *\n * Model version                  : 1.35\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 04:03:56 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n/*=======================================================================*\n * Target hardware information\n *   Device type: Intel->x86-64 (Mac OS X)\n *   Number of bits:     char:   8    short:   16    int:  32\n *                       long:  64\n *                       native word size:  64\n *   Byte ordering: LittleEndian\n *   Signed integer division rounds to: Zero\n *   Shift right on a signed integer as arithmetic shift: on\n *=======================================================================*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long int64_T;\ntypedef unsigned long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n/*===========================================================================*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T.                        *\n *===========================================================================*/\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n/*===========================================================================*\n * Complex number type definitions                                           *\n *===========================================================================*/\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n\n/* Block D-Work pointer type */\ntypedef void * pointer_T;\n\n#endif                                 /* RTWTYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"barplot.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * File : barplot.c\n * Abstract:\n *  An example C-file S-function for accessing simulink signals without using\n *  the standard block inputs.  In this case, a floating bar-plot style scope is\n *  implemented.  The signals that are selected on the diagram (via the mouse)\n *  are displayed by the scope.  The companion file barplotm.m receives the\n *  signal data and plots it.  See the demo model, fcndemo_barplot.\n *\n *\n * Copyright 1990-2013 The MathWorks, Inc.\n */\n\n\n#define S_FUNCTION_NAME  barplot\n#define S_FUNCTION_LEVEL 2\n\n#include \"simstruc.h\"\n#include \"sigmapdef_sfcn.h\"\n\n/*================*\n * Build checking *\n *================*/\n#if !defined(MATLAB_MEX_FILE)\n/*\n * This file cannot be used directly with the Real-Time Workshop.\n */\n# error This_file_can_be_used_only_during_simulation_inside_Simulink\n#endif\n\n\n/*\n * Define the user data.\n */\ntypedef struct UD_tag {\n    int  nPortObjs;    /* current # of ports */\n    void **portObjs;   /* current port list  */\n\n    mxArray *figTag;        /* tag of hg window used for plotting     */\n    mxArray *dataCell;      /* cell array used to pass data to m-code */\n    mxArray *sigNameCell;   /* cell array containing port names       */\n\n    SL_SigList *sigList; /* signal list corresponding to current ports */\n} UD;\n\n#define YLIM_PIDX (0)\n#define YLIM_PARAM(S) ssGetSFcnParam(S,YLIM_PIDX)\n\n#define IS_BIT_SET(uword32,bit) ((uword32 & bit) != 0)\n\n#define MDL_CHECK_PARAMETERS\n#if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)\n/* Function: mdlCheckParameters =============================================\n * Abstract:\n *  Validate our parameters.\n */\nstatic void mdlCheckParameters(SimStruct *S)\n{\n    int    i;\n    int    nEls;\n    double *pr;\n    \n    /*\n     * The ylimites must have an even number of elements and the mins\n     * must be less than the maxes.  This is not a very sophisticated\n     * user interface.  The ylims are entered as a vector where successive\n     * pairs of elements are used as the limits for successive axes.\n     */\n    if (!mxIsDouble(YLIM_PARAM(S))) {\n        ssSetErrorStatus(S,\"YLim parameter must be of type 'double'\");\n        return;\n    }\n\n    nEls = mxGetNumberOfElements(YLIM_PARAM(S));\n    if ((nEls < 2) || ((nEls % 2) != 0)) {\n        ssSetErrorStatus(S,\"YLim parameter have an even number of elements\");\n        return;\n\n    }\n\n    pr = mxGetPr(YLIM_PARAM(S));\n    for (i=0; i<nEls; i+=2) {\n        double yMin = pr[i];\n        double yMax = pr[i+1];\n\n        if (yMin >= yMax) {\n            ssSetErrorStatus(S,\"YMin must be less than YMax\");\n            return;\n        }\n    }\n}\n#endif /* MDL_CHECK_PARAMETERS */\n\n\n/* Function: mdlInitializeSizes ===============================================\n * Abstract:\n *   Setup sizes of the various vectors.\n */\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n    ssSetNumSFcnParams(S, 1);\n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {\n        return; /* Parameter mismatch will be reported by Simulink */\n    }\n\n    {\n        int iParam = 0;\n        int nParam = ssGetNumSFcnParams(S);\n\n        for ( iParam = 0; iParam < nParam; iParam++ )\n        {\n            ssSetSFcnParamTunable( S, iParam, SS_PRM_SIM_ONLY_TUNABLE );\n        }\n    }\n\n    if (!ssSetNumInputPorts(S, 0)) return;\n    if (!ssSetNumOutputPorts(S,0)) return;\n\n    ssSetNumSampleTimes(S, 1);\n\n    /* specify the sim state compliance to be same as a built-in block */\n    ssSetSimStateCompliance(S, USE_DEFAULT_SIM_STATE);\n\n    ssSetOptions(S, SS_OPTION_SIM_VIEWING_DEVICE);\n}\n\n\n/* Function: mdlInitializeSampleTimes =========================================\n * Abstract:\n *    Specifiy that we inherit our sample time from the driving block.\n */\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{\n    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);\n    ssSetOffsetTime(S, 0, 0.0);\n    ssSetModelReferenceSampleTimeDefaultInheritance(S); \n}\n\n\n#define MDL_START  /* Change to #undef to remove function */\n#if defined(MDL_START) \n  /* Function: mdlStart =======================================================\n   * Abstract:\n   *    Do startup tasks.\n   */\nstatic void mdlStart(SimStruct *S)\n{\n    /*\n     * Create user container.\n     */\n    UD *ud = (UD *)calloc(1,sizeof(UD));\n    if (ud == NULL) ssSetErrorStatus(S, \"Out of memory\");\n\n    /*\n     * Create & initialize the figure tag.\n     */\n    ud->figTag = mxCreateString(ssGetPath(S)); /* long jumps */\n    if (ud->figTag == NULL) ssSetErrorStatus(S, \"Out of memory\");\n    mexMakeArrayPersistent(ud->figTag);\n\n    ssSetUserData(S,ud);\n}\n#endif /*  MDL_START */\n\n\n/* Function: mdlOutputs ========================================================\n */\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n    return;\n}\n\n\n/* Function: AllRegionsSameN ===================================================\n * Abstract:\n *  Returns true if all regions have the same number of columns.\n */\nstatic boolean_T AllRegionsSameN(SL_SigRegion *sigReg)\n{\n    boolean_T    matrix  = (gsr_M(sigReg) != -1);\n    int          baseN   = matrix ? gsr_N(sigReg) : gsr_nEls(sigReg);\n\n    while((sigReg = gsr_NextReg(sigReg)) != NULL) {\n        int n;\n        int nEls = gsr_nEls(sigReg);\n\n        if (nEls == 0) continue; /* ignore unavailable regions */\n        \n        matrix  = (gsr_M(sigReg) != -1);\n        n = matrix ? gsr_N(sigReg) : nEls;\n        if (n != baseN) {\n            return(false);\n        }\n    }\n    return(true);\n} /* end AllRegionsSameN */\n\n\n/* Function: PopulateDataCell ==================================================\n * Abstract:\n *  Cycle through the signals in the signap map and package the signal data\n *  from the current time step into the data cell array.  This array will\n *  be passed to barplotm.m for display.  Note that if the signal consists\n *  of multiple \"tie wrapped\" signals that have the same number of columns,\n *  they are concatenated together into one matrix.\n */\nstatic void PopulateDataCell(\n    SimStruct  *S,\n    mxArray    *dataCell,\n    SL_SigList *sigList)\n{\n    int i;\n    int nSigs = gsl_nSigs(sigList);\n\n    for (i=0; i<nSigs; i++) {\n        SL_SigRegion *sigReg     = gsl_FirstReg(S,sigList,i);\n        mxArray      *mat        = mxGetCell(dataCell,i);\n        int          nCols       = mxGetN(mat);\n        double       *pr         = mxGetPr(mat);\n        boolean_T    tieWrap     = gsl_TieWrap(S,sigList,i);\n        int          nSigRegions = gsl_nSigRegions(S,sigList,i);\n        boolean_T    allSameN    = AllRegionsSameN(sigReg);\n        boolean_T    matrixStyle = tieWrap && ((nSigRegions == 1) || allSameN);\n\n        if (matrixStyle) {\n            int nColsDone   = 0;\n            while (nColsDone != nCols) {\n                do {\n                    if (gsr_nEls(sigReg) > 0) {\n                        int        j;\n                        boolean_T  matrix  = (gsr_M(sigReg) != -1);\n                        int        m       = matrix ? gsr_M(sigReg) : 1;\n                        int        offset  = m*nColsDone;\n                        int        dType   = gsr_DataType(sigReg);\n                        int        elSize  = gsr_DataTypeSize(sigReg);\n                        const char *data   = gsr_data(sigReg)+(offset * elSize);\n                        \n                        if (dType == SS_DOUBLE) {\n                            for (j=0; j<m; j++) {\n                                const double val = *(const double *)data;\n                                \n                                *pr = val;\n                                \n                                pr++;\n                                data += elSize;\n                            }\n                        } else {\n                            const boolean_T doDiff           = false;\n                            const boolean_T satOnIntOverFlow = false;\n                            \n                            ssCallConvertBuiltInDType(\n                                S,m,satOnIntOverFlow,doDiff,dType,\n                                data,SS_DOUBLE,pr);\n                            pr += m;\n                        }\n                    }\n                } while(sigReg = gsr_NextReg(sigReg), sigReg != NULL);\n                \n                nColsDone++;\n                sigReg = gsl_FirstReg(S,sigList,i);\n            }\n        } else {\n            do {\n                if (gsr_nEls(sigReg) > 0) {\n                    int        j;\n                    int        nEls    = gsr_nEls(sigReg);\n                    int        dType   = gsr_DataType(sigReg);\n                    int        elSize  = gsr_DataTypeSize(sigReg);\n                    const char *data   = gsr_data(sigReg);\n                    \n                    if (dType == SS_DOUBLE) {\n                        for (j=0; j<nEls; j++) {\n                            const double val = *(const double *)data;\n                            \n                            *pr = val;\n                            \n                            pr++;\n                            data += elSize;\n                        }\n                    } else {\n                        const boolean_T doDiff           = false;\n                        const boolean_T satOnIntOverFlow = false;\n                        \n                        ssCallConvertBuiltInDType(\n                            S,nEls,satOnIntOverFlow,doDiff,dType,\n                            data,SS_DOUBLE,pr);\n                        pr += nEls;\n                    }\n                }\n            } while(sigReg = gsr_NextReg(sigReg), sigReg != NULL);\n\n            /* \n             * Check that we stayed in bounds of allocated mem.\n             */\n            if ((mxGetPr(mat) + nCols) != pr) {\n                ssSetErrorStatus(S, \"Fatal memory overrun\");\n            }\n        }\n    }\n} /* end PopulateDataCell */\n\n\n/* Function: SumM ==============================================================\n * Abstract:\n *  Return the total number of rows across all regions.\n */\nstatic int SumM(SL_SigRegion *sigReg)\n{\n    int          sumM    = 0;\n    \n    do {\n        boolean_T matrix = (gsr_M(sigReg) != -1);\n        int       m      = matrix ? gsr_M(sigReg) : 1;\n        \n        sumM += m;\n    } while(sigReg = gsr_NextReg(sigReg), sigReg != NULL);\n    \n    return(sumM);\n}\n\n\n/* Function: CreateMatrixForSig ================================================\n * Abstract:\n *  Create a matrix to hold the data for a signal.  If it makes sense to plot\n *  the data as groups of bars (see bar.m), then the data is packaged into\n *  a single matrix with all columns being the same width.  Otherwise, we\n *  create a vector of values and each element is displayed as a bar.\n */\nstatic mxArray *CreateMatrixForSig(SimStruct *S,\n                                   const UD *ud,\n                                   const int lstIdx)\n{\n    int          m,n;\n    mxArray      *mat;\n    SL_SigList   *sigList    = ud->sigList;\n    boolean_T    tieWrap     = gsl_TieWrap(S,sigList,lstIdx);\n    int          nSigRegions = gsl_nSigRegions(S,sigList,lstIdx);\n    SL_SigRegion *sigReg     = gsl_FirstReg(S,sigList,lstIdx);\n    boolean_T    allSameN    = AllRegionsSameN(sigReg);\n    boolean_T    matrixStyle = tieWrap && ((nSigRegions == 1) || allSameN);\n    \n    if (matrixStyle) {\n        boolean_T    matrix  = (gsr_M(sigReg) != -1);\n        \n        m = SumM(sigReg);\n        n = matrix ? gsr_N(sigReg) : gsr_nEls(sigReg);\n    } else {\n        m = 1;\n        n = gsl_NumElements(S,ud->sigList,lstIdx);\n    }\n\n    mat = mxCreateDoubleMatrix(m, n, mxREAL); /* lngjmps */\n    return(mat);\n}\n\n\n/* Function: HandleUnavailSigs =================================================\n * Abstract:\n *  Unselected any unavailable signals as we are not able to display them.\n */\nstatic void HandleUnavailSigs(SimStruct *S, SL_SigList *sigList)\n{\n    const bool probeMode = true;\n    int        i;\n    int        nSigs;\n    \n    if (sigList == NULL) goto EXIT_POINT;\n    nSigs = gsl_nSigs(sigList);\n    \n    for (i=0; i<nSigs; i++) {\n        SL_SigRegion *sigReg = gsl_FirstReg(S, sigList,i);\n\n        do {\n            if (!IS_BIT_SET(gsr_status(sigReg),SLREG_AVAIL) &&\n                !IS_BIT_SET(gsr_status(sigReg),SLREG_GROUND)) {\n                if (probeMode) {\n                    /*\n                     * The graphical \"port\" selected by the user is\n                     * stored in the map (not in the region).  We\n                     * want to clear the graphically selected line.\n                     */\n                    void *mapPortObj = (void *)gsl_PortObj(sigList,i);\n                    ssCallUnselectSigFcn(S,mapPortObj);\n                } else {\n                    /* not implemented */\n                }\n                break;\n            }\n        } while((sigReg = gsr_NextReg(sigReg)) != NULL);\n    }\n\nEXIT_POINT:\n    return;\n}\n\n\n#define MDL_UPDATE  /* Change to #undef to remove function */\n#if defined(MDL_UPDATE)\n/* Function: mdlUpdate ======================================================\n * Abstract:\n *  Build the signal list, package the signal values into a cell array\n *  and call into Matlab to do the plotting.\n */\nstatic void mdlUpdate(SimStruct *S, int_T tid)\n{\n    void       **portObjs;\n    int        nPortObjs;\n    boolean_T  changed       = false;\n    const char *errmsg       = NULL;\n    UD         *ud           = (UD *)ssGetUserData(S);\n    void       **oldPortObjs = ud->portObjs;\n    int        nOldPortObjs  = ud->nPortObjs;\n    void       *block        = ssGetOwnerBlock(S);\n\n    /*\n     * Build selected signal list.\n     */\n    errmsg = ssCallSelectedSignalsFcn(S,\n        block,SIGSET_GRAPH,&portObjs,&nPortObjs);\n    if (errmsg != NULL) goto EXIT_POINT;\n\n    if (nPortObjs != nOldPortObjs) {\n        changed = true;\n    } else {\n        int i;\n        for (i=0; i<nPortObjs; i++) {\n            if (portObjs[i] != oldPortObjs[i]) {\n                changed = true;\n                break;\n            }\n        }\n    }\n\n    if (changed) {\n        /*\n         * Update the user data port cache.\n         */\n        ud->nPortObjs = nPortObjs;\n\n        ssCallGenericDestroyFcn(S,oldPortObjs);\n        ud->portObjs = portObjs;\n        portObjs = NULL; /* don't free at exit_point */\n\n        /*\n         * Destroy old signal info.\n         */\n        ssCallSigListDestroyFcn(S,ud->sigList);\n        ud->sigList = NULL;\n\n        mxDestroyArray(ud->dataCell);\n        ud->dataCell = NULL;\n\n        mxDestroyArray(ud->sigNameCell);\n        ud->sigNameCell = NULL;\n\n        /*\n         * Create the new signal info.\n         */\n        if (ud->nPortObjs != 0) {\n            int          i;\n            int          nSigs;\n            unsigned int excludeFlags = SLREG_FRAME | SLREG_COMPLEX;\n\n            /*\n             * Create signal list.\n             */\n            errmsg = ssCallSigListCreateFcn(S,\n                block,ud->nPortObjs,ud->portObjs,\n                excludeFlags, (void **)&ud->sigList);\n            if (errmsg != NULL) goto EXIT_POINT;\n            nSigs = ud->sigList->nSigs;\n\n            ssCallSigListUnavailSigAlertFcn(S,ud->sigList);\n            HandleUnavailSigs(S,ud->sigList);\n\n            /*\n             * Create data cell array and child matrices.\n             */\n            ud->dataCell = mxCreateCellMatrix(1,nSigs); /* lngjmps */\n            if (ud->dataCell == NULL) {\n                errmsg = \"Out of memory\";\n                goto EXIT_POINT;\n            }\n\n            for (i=0; i<nSigs; i++) {\n                mxArray *mat = CreateMatrixForSig(S,ud,i); /* lngjmps */\n                if (mat == NULL) {\n                    errmsg = \"Out of memory\";\n                    goto EXIT_POINT;\n                }\n                mxSetCell(ud->dataCell,i,mat);\n            }\n\n            mexMakeArrayPersistent(ud->dataCell);\n\n            /*\n             * Create signal name cell array and the child strings.\n             */\n            ud->sigNameCell = mxCreateCellMatrix(1,nSigs); /* lngjmps */\n            if (ud->sigNameCell == NULL) {\n                errmsg = \"Out of memory\";\n                goto EXIT_POINT;\n            }\n\n            for (i=0; i<nSigs; i++) {\n                void       *portObj = (void*)gsl_PortObj(ud->sigList,i);\n                const char *name    = ssCallGetPortNameFcn(S,portObj);\n                mxArray    *mat     = mxCreateString(name); /* lngjmps */\n                if (mat == NULL) {\n                    errmsg = \"Out of memory\";\n                    goto EXIT_POINT;\n                }\n                mxSetCell(ud->sigNameCell,i,mat);\n            }\n\n            mexMakeArrayPersistent(ud->sigNameCell);\n        }\n    }\n\n    /*\n     * Call barplotm.m.\n     */\n    if (ud->nPortObjs != 0) {\n        int     fail;\n        mxArray *prhs[4];\n\n        PopulateDataCell(S,ud->dataCell,ud->sigList);\n\n        prhs[0] = ud->figTag;\n        prhs[1] = ud->dataCell;\n        prhs[2] = (mxArray *)YLIM_PARAM(S);\n        prhs[3] = ud->sigNameCell;\n\n        /* Call matlab. */\n        fail = mexCallMATLAB(0,NULL,4,prhs,\"barplotm\");\n        if (fail) {\n            errmsg = \"Error calling 'barplot.m'\";\n            goto EXIT_POINT;\n        }\n    }\n\nEXIT_POINT:\n    ssCallGenericDestroyFcn(S,portObjs);\n    if (errmsg != NULL) {\n        mxDestroyArray(ud->dataCell);\n        ud->dataCell = NULL;\n\n        ssCallSigListDestroyFcn(S,ud->sigList);\n        ud->sigList = NULL;\n\n        mxDestroyArray(ud->sigNameCell);\n        ud->sigNameCell = NULL;\n\n        ssSetErrorStatus(S, errmsg);\n    }\n}\n#endif /* MDL_UPDATE */\n\n\n/* Function: mdlTerminate =====================================================\n * Abstract:\n *    No termination needed, but we are required to have this routine.\n */\nstatic void mdlTerminate(SimStruct *S)\n{\n    UD *ud = ssGetUserData(S);\n    \n    ssCallGenericDestroyFcn(S,ud->portObjs);\n    mxDestroyArray(ud->figTag);\n    mxDestroyArray(ud->dataCell);\n    mxDestroyArray(ud->sigNameCell);\n\n    ssCallSigListDestroyFcn(S,ud->sigList);\n\n    free(ud);\n}\n\n\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n"},{"name":"ml2rtw.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * ml2rtw.c : Contains utility function to write a ML structure to rtw file.\n *\n * Copyright 1990-2017 The MathWorks, Inc.\n *\n */\n\n#ifndef __ml2rtw__\n#define __ml2rtw__\n\n#ifndef S_FUNCTION_NAME\n# define S_FUNCTION_NAME\n#endif\n\n#ifndef S_FUNCTION_LEVEL\n# define S_FUNCTION_LEVEL 2\n#endif\n\n#ifdef HAS_INTERLEAVED_COMPLEX\n# error \"This file is not compatible with Interleaved Complex.\"\n#endif\n\n#include <stdio.h>    /* for sprintf() */\n#include <string.h>   /* for strlen()  */\n#include \"simstruc.h\"\n\n\n/* Function: WriteMatlabStructureToRTWFile =====================================\n * Abstract:\n *      This routine writes out a matlab structure to the rtw file. Nested\n *      structures inside structures are also supported, i.e., any field(s) of\n *      the mxArray passed in can be structures.  However, the basic atomic\n *      units have to be either row strings or non-sparse, numeric vectors or\n *      matrices. For example, fields cannot be things like a matrix of strings\n *      or nd arrays.\n *\n *      In order to avoid name clashes with records (especially ones that might\n *      be added in future) written out by Simulink, your structure name should\n *      start with the string \"SFcn\". For example, instead of naming your\n *      structure \"ParseTree\" you should name it \"SFcnParseTree\".\n *\n * Returns:\n *      1 -on success\n *      0 -on failure\n */\nbool WriteMatlabStructureToRTWFile(SimStruct      *S,\n                                   const mxArray  *mlStruct,\n                                   const char     *structName,\n                                   char           *strBuffer,\n                                   const int      strBufferLen)\n{\n    int numStructs;\n    int numFields;\n    int i;\n\n    if (mlStruct == NULL) {\n        return(1);\n    }\n    numStructs = mxGetNumberOfElements(mlStruct);\n    numFields  = mxGetNumberOfFields(mlStruct);\n\n    /* make sure strBuffer is long enough for sprintf, be conservative */\n    if ( strlen(structName)+5 >= ((size_t) strBufferLen) ) {\n        return(0);\n    }\n\n    for (i=0; i<numStructs; i++) {\n        int  j;\n\n        (void) sprintf(strBuffer, \"%s {\",structName);\n        if ( !ssWriteRTWStr(S, strBuffer) ) {\n            return(0);\n        }\n\n        for (j=0; j<numFields; j++) {\n            const char    *fieldName = mxGetFieldNameByNumber(mlStruct, j);\n            const mxArray *field     = mxGetFieldByNumber(mlStruct, i, j);\n            int           nRows;\n            int           nCols;\n            int           nElements;\n            int           nDims;\n\n            if (field == NULL) {\n                continue;\n            }\n\n            nRows      = mxGetM(field);\n            nCols      = mxGetN(field);\n            nElements  = mxGetNumberOfElements(field);\n            nDims      = mxGetNumberOfDimensions(field);\n\n            if ( mxIsStruct(field) ) {                       /* struct param */\n                if ( !WriteMatlabStructureToRTWFile(S,\n                                                    field,\n                                                    fieldName,\n                                                    strBuffer,\n                                                    strBufferLen) ) {\n                    return(0);\n                }\n\n            } else if ( mxIsChar(field) ) {                  /* string param */\n\n                /* can handle only \"row\" strings */\n                if ( nDims > 2 || nRows > 1 ) {\n                    return(0);\n                }\n\n                if ( mxGetString(field,strBuffer,strBufferLen) ) {\n                    return(0);\n                }\n\n                if ( !ssWriteRTWStrParam(S,fieldName,strBuffer) ) {\n                    return(0);\n                }\n\n            } else if ( mxIsNumeric(field) ) {              /* numeric param */\n\n                const void *rval   = mxGetData(field);\n                int        isCmplx = mxIsComplex(field);\n                DTypeId    dTypeId = ssGetDTypeIdFromMxArray(field);\n                int        dtInfo  = DTINFO(dTypeId, isCmplx);\n                const void *ival   = (isCmplx) ? mxGetImagData(field) : NULL;\n\n                /* can handle only non-sparse, numeric vectors or matrices */\n                if (nDims > 2 || nRows*nCols != nElements || mxIsSparse(field)){\n                    return(0);\n                }\n\n                if (nRows == 1 || nCols == 1) {              /* vector param */\n                    if ( !ssWriteRTWMxVectParam(S, fieldName, rval, ival,\n                                                dtInfo, nElements) ) {\n                        return(0);\n                    }\n                } else {                                     /* matrix param */\n                    if ( !ssWriteRTWMx2dMatParam(S, fieldName, rval, ival,\n                                                 dtInfo, nRows, nCols) ) {\n                        return(0);\n                    }\n                }\n            } else {\n                return(0);\n            }\n        }\n\n        if ( !ssWriteRTWStr(S, \"}\") ) {\n            return(0);\n        }\n    }\n    return(1);\n\n} /* end WriteMatlabStructureToRTWFile */\n\n\n#endif /* __ml2rtw__ */\n\n/* LocalWords:  nd\n */\n"},{"name":"ode1.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2009 The MathWorks, Inc.\n *\n * File: ode1.c        \n *\n */\n\n#include \"odesup.h\"\n\ntypedef struct IntgData_tag {\n    real_T *f0;\n} IntgData;\n\n#ifndef RT_MALLOC\n  /* statically declare data */\n  static real_T   rt_ODE1_F[NCSTATES];\n  static IntgData rt_ODE1_IntgData = {rt_ODE1_F};\n \n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      rtsiSetSolverData(si,(void *) &rt_ODE1_IntgData);\n      rtsiSetdX(si, rt_ODE1_IntgData.f0);\n      rtsiSetSolverName(si,\"ode1\");\n  }\n\n#else\n  /* dynamically allocated data */\n  extern const char *RT_MEMORY_ALLOCATION_ERROR;\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = (IntgData *) malloc(sizeof(IntgData));\n      if(id == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      \n      id->f0 = (real_T *) malloc(rtsiGetNumContStates(si) * sizeof(real_T));\n      if(id->f0 == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      \n      rtsiSetSolverData(si, (void *)id);\n      rtsiSetdX(si, id->f0);\n      rtsiSetSolverName(si,\"ode1\");\n  }\n\n  void rt_ODEDestroyIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = rtsiGetSolverData(si);\n      \n      if (id != NULL) {\n          if (id->f0 != NULL) {\n              free(id->f0);\n          }\n          free(id);\n          rtsiSetSolverData(si, NULL);\n      }\n  }\n#endif\n\nvoid rt_ODEUpdateContinuousStates(RTWSolverInfo *si)\n{\n    time_T    h    = rtsiGetStepSize(si);\n    time_T    tnew = rtsiGetSolverStopTime(si);\n    IntgData  *id  = rtsiGetSolverData(si);\n    real_T    *f0  = id->f0;\n    real_T    *x   = rtsiGetContStates(si);\n    int_T     i;\n\n#ifdef NCSTATES\n    int_T     nXc  = NCSTATES;\n#else\n    int_T     nXc  = rtsiGetNumContStates(si);\n#endif\n\n    rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n    DERIVATIVES(si);\n\n    rtsiSetT(si, tnew);\n\n    for (i = 0; i < nXc; i++) {\n      *x += h * f0[i];\n      x++;\n    }\n\n    PROJECTION(si);\n    REDUCTION(si);\n\n    rtsiSetSimTimeStep(si, MAJOR_TIME_STEP);\n}\n\n/* [EOF] ode1.c */\n"},{"name":"ode14x.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2009 The MathWorks, Inc.\n *\n * File: ode14x.c        \n *\n */\n\n#include <math.h>\n#include <string.h>\n#include \"tmwtypes.h\"\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n#include \"rt_matrixlib.h\"\n#include \"odesup.h\"\n\n#define MAXORDER 4\n\nstatic int_T rt_ODE14x_N[MAXORDER] = {12, 8, 6, 4};\n\ntypedef struct IntgData_tag {\n    /* ode14x: */\n    real_T  *x0;\n    real_T  *f0;\n    real_T  *x1start;\n    real_T  *f1;\n    real_T  *Delta;     \n    real_T  *E;    /* maxorder x nx */\n\n    /* numjac: */\n    real_T  *fac;  /* nx */\n    real_T  *DFDX; /* nx x nx */\n\n    /* LU: */\n    real_T  *W;    /* nx x nx */\n    int32_T *pivots; /* nx */\n} IntgData;\n\n#ifndef RT_MALLOC\n  /* statically declare data */\n  static real_T   rt_ODE14x_X0[NCSTATES];\n  static real_T   rt_ODE14x_F0[NCSTATES];\n  static real_T   rt_ODE14x_X1START[NCSTATES];\n  static real_T   rt_ODE14x_F1[NCSTATES];\n  static real_T   rt_ODE14x_DELTA[NCSTATES];\n  static real_T   rt_ODE14x_E[MAXORDER*NCSTATES];\n  static real_T   rt_ODE14x_FAC[NCSTATES];\n  static real_T   rt_ODE14x_DFDX[NCSTATES*NCSTATES];\n  static real_T   rt_ODE14x_W[NCSTATES*NCSTATES];\n  static int32_T  rt_ODE14x_PIVOTS[NCSTATES];\n\n  static IntgData rt_ODE14x_IntgData = {rt_ODE14x_X0,\n                                        rt_ODE14x_F0,\n                                        rt_ODE14x_X1START,\n                                        rt_ODE14x_F1,\n                                        rt_ODE14x_DELTA,\n\t\t\t\t\trt_ODE14x_E,\n\t\t\t\t\trt_ODE14x_FAC,\n\t\t\t\t\trt_ODE14x_DFDX,\n                                        rt_ODE14x_W,\n                                        rt_ODE14x_PIVOTS};\n\t\t\t\t\t\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      { /* Initialize */\n\t  real_T SQRT_EPS = 1.5e-8;   /* sqrt(utGetEps()); */\n\t  int_T i;\n\t  for (i = 0; i < NCSTATES; i++) {\n\t      rt_ODE14x_IntgData.fac[i] = SQRT_EPS;\n\t  } \n      }\n\n      rtsiSetSolverData(si,(void *)&rt_ODE14x_IntgData);\n      rtsiSetSolverName(si,\"ode14x\");\n  }\n#else\n  /* dynamically allocated data */\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      int_T nx    = rtsiGetNumContStates(si);\n      int_T vsize = nx * sizeof(real_T);\n      int_T msize = nx * vsize;\n      int_T size  = (6+MAXORDER)*vsize + 2*msize + nx*sizeof(int_T); \n\n      IntgData *id = (IntgData *) malloc(sizeof(IntgData));\n      if(id == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      \n      id->x0 = (real_T *) malloc(size);\n      if(id->x0 == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      id->f0      = id->x0      + nx;\n      id->x1start = id->f0      + nx;\n      id->f1      = id->x1start + nx;\n      id->Delta   = id->f1      + nx;\n      id->E       = id->Delta   + nx;\n      id->fac     = id->E       + MAXORDER * nx;\n      id->DFDX    = id->fac     + nx;\n      id->W       = id->DFDX    + nx * nx;\n      id->pivots  = (int32_T *) (id->W + nx * nx);\n\n      { /* Initialize */\n\t  real_T SQRT_EPS = 1.5e-8;   /* sqrt(utGetEps()); */\n\t  int_T  i;\n\t  for (i = 0; i < nx; i++) {\n\t      id->fac[i] = SQRT_EPS;\n\t  } \n      }\n\n      rtsiSetSolverData(si, (void *)id);\n      rtsiSetSolverName(si,\"ode14x\");\n  }\n\n  void rt_ODEDestroyIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = rtsiGetSolverData(si);\n      \n      if (id != NULL) {\n          if (id->x0 != NULL) {\n              free(id->x0);\n          }\n          free(id);\n          rtsiSetSolverData(si, NULL);\n      }\n  }\n#endif\n\n\n/* Simplified version of numjac.cpp, for use with RTW. */\nvoid local_numjac(RTWSolverInfo   *si,\n\t\t  real_T          *y,\n\t\t  const real_T    *Fty,\n\t\t  real_T          *fac,\n\t\t  real_T          *dFdy)\n{\n    /* constants */\n    real_T THRESH = 1e-6;\n    real_T EPS    = 2.2e-16;  /* utGetEps(); */\n    real_T BL     = pow(EPS, 0.75);\n    real_T BU     = pow(EPS, 0.25);\n    real_T FACMIN = pow(EPS, 0.78);\n    real_T FACMAX = 0.1;\n\n#ifdef NCSTATES\n    int_T     nx = NCSTATES;\n#else\n    int_T     nx = rtsiGetNumContStates(si);\n#endif\n\n    real_T    *x = rtsiGetContStates(si);\n    real_T    del;\n    real_T    difmax;\n    real_T    FdelRowmax;\n    real_T    temp;\n    real_T    Fdiff;\n    real_T    maybe;\n    real_T    xscale;\n    real_T    fscale;\n    real_T    *p;\n    int_T     rowmax;\n    int_T     i,j;\n\n    if (x != y) (void)memcpy(x,y,nx*sizeof(real_T));\n\n    for (p = dFdy, j = 0; j < nx; j++, p += nx) {\n\n        /* Select an increment del for a difference approximation to\n           column j of dFdy.  The vector fac accounts for experience\n           gained in previous calls to numjac. */\n        xscale = fabs(x[j]);\n        if (xscale < THRESH) xscale = THRESH;\n\ttemp = (x[j] + fac[j]*xscale); \n        del  = temp  - y[j];\n        while (del == 0.0) {\n            if (fac[j] < FACMAX) {\n                fac[j] *= 100.0;\n                if (fac[j] > FACMAX) fac[j] = FACMAX;\n\t\ttemp = (x[j] + fac[j]*xscale); \n                del  = temp  - x[j];\n            } else {\n                del = THRESH; /* thresh is nonzero */\n                break;\n            }\n        }\n        /* Keep del pointing into region. */\n        if (Fty[j] >= 0.0) del = fabs(del);\n        else del = -fabs(del);\n\n        /* Form a difference approximation to column j of dFdy. */\n        temp = x[j];\n        x[j] += del;\n\n\trtsiSetdX(si,p);\n\tOUTPUTS(si,0);\n\tDERIVATIVES(si);\n\n        x[j] = temp;\n        difmax = 0.0;\n        rowmax = 0;\n        FdelRowmax = p[0];\n        temp = 1.0 / del;\n        for (i = 0; i < nx; i++) {\n            Fdiff = p[i] - Fty[i];\n            maybe = fabs(Fdiff);\n            if (maybe > difmax) {\n                difmax = maybe;\n                rowmax = i;\n                FdelRowmax = p[i];\n            }\n            p[i] = temp * Fdiff;\n        }\n\n        /* Adjust fac for next call to numjac. */\n        if (((FdelRowmax != 0.0) && (Fty[rowmax] != 0.0)) || (difmax == 0.0)) {\n            fscale = fabs(FdelRowmax);\n            if (fscale < fabs(Fty[rowmax])) fscale = fabs(Fty[rowmax]);\n\n\t    if (difmax <= BL*fscale) {\n                /* The difference is small, so increase the increment. */\n                fac[j] *= 10.0;\n                if (fac[j] > FACMAX) fac[j] = FACMAX;\n\n            } else if (difmax > BU*fscale) {\n                /* The difference is large, so reduce the increment. */\n                fac[j] *= 0.1;\n                if (fac[j] < FACMIN) fac[j] = FACMIN;\n\n            }\n        }\n    }\n\n} /* end local_numjac */\n\n\nvoid rt_ODEUpdateContinuousStates(RTWSolverInfo *si)\n{\n    time_T    t0         = rtsiGetT(si);\n    time_T    t1         = t0;\n    time_T    h          = rtsiGetStepSize(si);\n    real_T    *x1        = rtsiGetContStates(si);\n    int_T     order      = rtsiGetSolverExtrapolationOrder(si);\n    int_T     numIter    = rtsiGetSolverNumberNewtonIterations(si);\n\n    IntgData  *id        = rtsiGetSolverData(si);\n    real_T    *x0        = id->x0;\n    real_T    *f0        = id->f0;\n    real_T    *x1start   = id->x1start;\n    real_T    *f1        = id->f1;\n    real_T    *Delta     = id->Delta;\n    real_T    *E         = id->E;\n    real_T    *fac       = id->fac;\n    real_T    *dfdx      = id->DFDX;\n    real_T    *W         = id->W;\n    int_T     *pivots    = id->pivots;\n    int_T     *N         = &(rt_ODE14x_N[0]); \n    int_T     i,j,k,iter;\n\n#ifdef NCSTATES\n    int_T     nx        = NCSTATES;\n#else\n    int_T     nx        = rtsiGetNumContStates(si);\n#endif\n\n    rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n    /* Save the state values at time t in y, we'll use x as ynew. */\n    (void)memcpy(x0, x1, nx*sizeof(real_T));\n\n    /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n    /* f0 = f(t,y) */\n    rtsiSetdX(si, f0);\n    DERIVATIVES(si);\n\n    /* Compute the Jacobian */\n    local_numjac(si,x0,f0,fac,dfdx);\n\n    for (j = 0; j < order; j++) {\n\t\n\treal_T *p;\n\treal_T hN = h / N[j];\n\t\n\t/* Get the iteration matrix and solution at t0 */\n\n\t/* [L,U] = lu(I - hN*J) */\n        (void) memcpy(W, dfdx, nx*nx*sizeof(real_T));\n        for (p = W, i = 0; i < nx*nx; i++, p++) *p *= (-hN);\n        for (p = W, i = 0; i < nx; i++, p += (nx+1)) *p += 1.0;\n\trt_lu_real(W,nx,pivots);\n\n\t/* First Newton's iteration at t0. */\n\t/* rhs = hN*f0  */\n\tfor (i = 0; i < nx; i++) Delta[i] = hN*f0[i];\n\t/* Delta = (U \\ (L \\ rhs)) */\n\trt_ForwardSubstitutionRR_Dbl(W,Delta,f1,nx,1,pivots,1);\n\trt_BackwardSubstitutionRR_Dbl(W+nx*nx-1,f1+nx-1,Delta,nx,1,0);\n\t/* ytmp = y0 + Delta */ \n\t(void)memcpy(x1, x0, nx*sizeof(real_T));\n\tfor (i = 0; i < nx; i++) x1[i] += Delta[i];\n\n\t/* Additional Newton's iterations, if desired. \n\t   for iter = 2:NewtIter\n\t     rhs = (yn - ytmp) + hN*feval(odefun,tn,ytmp,extraArgs{:});\n\t     Delta = ( U \\ ( L \\ rhs ) );\n\t     ytmp = ytmp + Delta;\n\t   end  \n\t*/\n\trtsiSetT(si, t0);\n\trtsiSetdX(si, f1);\n\tfor (iter = 1; iter < numIter; iter++) {\n\n\t    OUTPUTS(si,0);\n\t    DERIVATIVES(si);\n\n\t    for (i = 0; i < nx; i++) Delta[i] = (x0[i]-x1[i]) + hN*f1[i];\n\n\t    rt_ForwardSubstitutionRR_Dbl(W,Delta,f1,nx,1,pivots,1);\n\t    rt_BackwardSubstitutionRR_Dbl(W+nx*nx-1,f1+nx-1,Delta,nx,1,0);\n\n\t    for (i = 0; i < nx; i++) x1[i] += Delta[i];\n\t}\n\n\t/* Subintegration of N(j) steps for extrapolation \n\t   ttmp = t0;\n\t   for i = 2:N(j)\n\t     ttmp = ttmp + hN\n\t     ytmp0 = ytmp;\n\t     for iter = 1:NewtIter\n               rhs = (ytmp0 - ytmp) + hN*feval(odefun,ttmp,ytmp,extraArgs{:});\n\t       Delta = ( U \\ ( L \\ rhs ) );\n\t       ytmp = ytmp + Delta;\n\t     end\n\t   end \n\t*/\n\tfor (k = 1; k < N[j]; k++) {\n\t    t1 = t0 + k*hN;\n\t    (void)memcpy(x1start, x1, nx*sizeof(real_T));\n\t    rtsiSetT(si, t1);\n\t    rtsiSetdX(si, f1);\n\t    for (iter = 0; iter < numIter; iter++) {\n\n\t\tOUTPUTS(si,0);\n\t\tDERIVATIVES(si);\n\n\t\tif (iter == 0) {\n\t\t    for (i = 0; i < nx; i++) Delta[i] = hN*f1[i];\n\t\t} else {\n\t\t    for (i = 0; i < nx; i++) Delta[i] = (x1start[i]-x1[i]) + hN*f1[i];\n\t\t}\n\n\t\t/* Modeled after rt_matdivrr_dbl.c, use f1 as a temp storage */\n\t\trt_ForwardSubstitutionRR_Dbl(W,Delta,f1,nx,1,pivots,1);\n\t\trt_BackwardSubstitutionRR_Dbl(W+nx*nx-1,f1+nx-1,Delta,nx,1,0);\n\n\t\tfor (i = 0; i < nx; i++) x1[i] += Delta[i];\n\t    }   \n\t}\n\n\t/* Extrapolate to order j\n\t   E(:,j) = ytmp\n\t   for k = j:-1:2\n             coef = N(k-1)/(N(j) - N(k-1))\n             E(:,k-1) = E(:,k) + coef*( E(:,k) - E(:,k-1) )\n\t   end \n\t*/\n\t(void)memcpy( &(E[nx*j]), x1, nx*sizeof(real_T));\n\tfor (k = j; k > 0; k--) {\n\t    real_T coef = (real_T)(N[k-1]) / (N[j]-N[k-1]);\n\n\t    for (i = 0; i < nx; i++) {\n\t\tx1[i] = E[nx*k+i] + coef*(E[nx*k+i] - E[nx*(k-1)+i]);\n\t    }\n\n\t    (void)memcpy( &(E[nx*(k-1)]), x1, nx*sizeof(real_T));\n\t}\n    }\n\n    /* Extrapolated solution\n       x1 = E(:,1);\n    */\n    (void)memcpy(x1, E, nx*sizeof(real_T));\n\n    /* t1 = t0 + h; */\n    rtsiSetT(si,rtsiGetSolverStopTime(si));\n\n    PROJECTION(si);\n    REDUCTION(si);\n\n    rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n"},{"name":"ode2.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2009 The MathWorks, Inc.\n *\n * File: ode2.c        \n *\n */\n\n#include <math.h>\n#include <string.h>\n#include \"tmwtypes.h\"\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n#include \"odesup.h\"\n\ntypedef struct IntgData_tag {\n    real_T *y;\n    real_T *f[2];\n} IntgData;\n\n#ifndef RT_MALLOC\n  /* statically declare data */\n  static real_T   rt_ODE2_Y[NCSTATES];\n  static real_T   rt_ODE2_F[2][NCSTATES];\n  static IntgData rt_ODE2_IntgData = {rt_ODE2_Y, {rt_ODE2_F[0], rt_ODE2_F[1]}};\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      rtsiSetSolverData(si, (void *)&rt_ODE2_IntgData);\n      rtsiSetSolverName(si,\"ode2\");\n  }\n\n#else\n  /* dynamically allocated data */\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = (IntgData *) malloc(sizeof(IntgData));\n      if(id == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      \n      id->y = (real_T *) malloc(3*rtsiGetNumContStates(si) * sizeof(real_T));\n      if(id->y == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      id->f[0] = id->y + rtsiGetNumContStates(si);\n      id->f[1] = id->f[0] + rtsiGetNumContStates(si);\n      \n      rtsiSetSolverData(si, (void *)id);\n      rtsiSetSolverName(si,\"ode2\");\n  }\n\n  void rt_ODEDestroyIntegrationData(RTWSolverInfo *si)\n  {\n    IntgData *id = rtsiGetSolverData(si);\n\n    if (id != NULL) {\n      if (id->y != NULL) {\n        free(id->y);\n      }\n      free(id);\n      rtsiSetSolverData(si, NULL);\n    }\n  }\n#endif\n\nvoid rt_ODEUpdateContinuousStates(RTWSolverInfo *si)\n{\n    time_T    tnew  = rtsiGetSolverStopTime(si);\n    time_T    h     = rtsiGetStepSize(si);\n    real_T    *x    = rtsiGetContStates(si);\n    IntgData  *id   = rtsiGetSolverData(si);\n    real_T    *y    = id->y;\n    real_T    *f0   = id->f[0];\n    real_T    *f1   = id->f[1];\n    real_T    temp;\n    int_T     i;\n\n#ifdef NCSTATES\n    int_T     nXc   = NCSTATES;\n#else\n    int_T     nXc   = rtsiGetNumContStates(si);\n#endif\n\n    rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n    /* Save the state values at time t in y, we'll use x as ynew. */\n    (void)memcpy(y, x, nXc*sizeof(real_T));\n\n    /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n    /* f0 = f(t,y) */\n    rtsiSetdX(si, f0);\n    DERIVATIVES(si);\n\n    /* f1 = f(t + h, y + h*f0) */\n    for (i = 0; i < nXc; i++) x[i] = y[i] + (h*f0[i]);\n    rtsiSetT(si, tnew);\n    rtsiSetdX(si, f1);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* tnew = t + h\n       ynew = y + (h/2)*(f0 + f1) */\n    temp = 0.5*h;\n    for (i = 0; i < nXc; i++) {\n        x[i] = y[i] + temp*(f0[i] + f1[i]);\n    }\n\n    PROJECTION(si);\n    REDUCTION(si);\n\n    rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n/* [EOF] ode2.c */\n"},{"name":"ode3.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2009 The MathWorks, Inc.\n *\n * File: ode3.c        \n *\n */\n\n#include <math.h>\n#include <string.h>\n#include \"tmwtypes.h\"\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n#include \"odesup.h\"\n\nstatic const real_T rt_ODE3_A[3] = {\n    1.0/2.0, 3.0/4.0, 1.0\n};\n\nstatic const real_T rt_ODE3_B[3][3] = {\n    { 1.0/2.0,     0.0,     0.0 },\n    {     0.0, 3.0/4.0,     0.0 },\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\n};\n\n\ntypedef struct IntgData_tag {\n    real_T *y;\n    real_T *f[3];\n} IntgData;\n\n\n#ifndef RT_MALLOC\n  /* statically declare data */\n  static real_T   rt_ODE3_Y[NCSTATES];\n  static real_T   rt_ODE3_F[3][NCSTATES];\n  static IntgData rt_ODE3_IntgData = {rt_ODE3_Y,\n                                      {rt_ODE3_F[0],rt_ODE3_F[1],rt_ODE3_F[2]}};\n\nvoid rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      rtsiSetSolverData(si,(void *)&rt_ODE3_IntgData);\n      rtsiSetSolverName(si,\"ode3\");\n  }\n#else\n  /* dynamically allocated data */\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = (IntgData *) malloc(sizeof(IntgData));\n      if(id == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      \n      id->y = (real_T *) malloc(4*rtsiGetNumContStates(si) * sizeof(real_T));\n      if(id->y == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      id->f[0] = id->y + rtsiGetNumContStates(si);\n      id->f[1] = id->f[0] + rtsiGetNumContStates(si);\n      id->f[2] = id->f[1] + rtsiGetNumContStates(si);\n      \n      rtsiSetSolverData(si, (void *)id);\n      rtsiSetSolverName(si,\"ode3\");\n  }\n\n  void rt_ODEDestroyIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = rtsiGetSolverData(si);\n      \n      if (id != NULL) {\n          if (id->y != NULL) {\n              free(id->y);\n          }\n          free(id);\n          rtsiSetSolverData(si, NULL);\n      }\n  }\n#endif\n\nvoid rt_ODEUpdateContinuousStates(RTWSolverInfo *si)\n{\n    time_T    t          = rtsiGetT(si);\n    time_T    tnew       = rtsiGetSolverStopTime(si);\n    time_T    h          = rtsiGetStepSize(si);\n    real_T    *x         = rtsiGetContStates(si);\n    IntgData  *id        = rtsiGetSolverData(si);\n    real_T    *y         = id->y;\n    real_T    *f0        = id->f[0];\n    real_T    *f1        = id->f[1];\n    real_T    *f2        = id->f[2];\n    real_T    hB[3];\n    int_T     i;\n\n#ifdef NCSTATES\n    int_T     nXc        = NCSTATES;\n#else\n    int_T     nXc        = rtsiGetNumContStates(si);\n#endif\n\n    rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n    /* Save the state values at time t in y, we'll use x as ynew. */\n    (void)memcpy(y, x, nXc*sizeof(real_T));\n\n    /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n    /* f0 = f(t,y) */\n    rtsiSetdX(si, f0);\n    DERIVATIVES(si);\n\n    /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\n    hB[0] = h * rt_ODE3_B[0][0];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0]);\n    }\n    rtsiSetT(si, t + h*rt_ODE3_A[0]);\n    rtsiSetdX(si, f1);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\n    for (i = 0; i <= 1; i++) hB[i] = h * rt_ODE3_B[1][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n    }\n    rtsiSetT(si, t + h*rt_ODE3_A[1]);\n    rtsiSetdX(si, f2);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* tnew = t + hA(3);\n       ynew = y + f*hB(:,3); */\n    for (i = 0; i <= 2; i++) hB[i] = h * rt_ODE3_B[2][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n    }\n    rtsiSetT(si, tnew);\n\n    PROJECTION(si);\n    REDUCTION(si);\n\n    rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n\n/* [EOF] ode3.c */\n"},{"name":"ode4.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2009 The MathWorks, Inc.\n *\n * File: ode4.c        \n *\n */\n\n#include <math.h>\n#include <string.h>\n#include \"tmwtypes.h\"\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n#include \"odesup.h\"\n\ntypedef struct IntgData_tag {\n    real_T *y;\n    real_T *f[4];\n} IntgData;\n\n#ifndef RT_MALLOC\n  /* statically declare data */\n  static real_T   rt_ODE4_Y[NCSTATES];\n  static real_T   rt_ODE4_F[4][NCSTATES];\n  static IntgData rt_ODE4_IntgData = {rt_ODE4_Y,\n                                      {rt_ODE4_F[0],\n                                       rt_ODE4_F[1],\n                                       rt_ODE4_F[2],\n                                       rt_ODE4_F[3]}};\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      rtsiSetSolverData(si,(void *)&rt_ODE4_IntgData);\n      rtsiSetSolverName(si,\"ode4\");\n  }\n#else\n  /* dynamically allocated data */\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = (IntgData *) malloc(sizeof(IntgData));\n      if(id == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      \n      id->y = (real_T *) malloc(5*rtsiGetNumContStates(si) * sizeof(real_T));\n      if(id->y == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      id->f[0] = id->y + rtsiGetNumContStates(si);\n      id->f[1] = id->f[0] + rtsiGetNumContStates(si);\n      id->f[2] = id->f[1] + rtsiGetNumContStates(si);\n      id->f[3] = id->f[2] + rtsiGetNumContStates(si);\n      \n      rtsiSetSolverData(si, (void *)id);\n      rtsiSetSolverName(si,\"ode4\");\n  }\n\n  void rt_ODEDestroyIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = rtsiGetSolverData(si);\n      \n      if (id != NULL) {\n          if (id->y != NULL) {\n              free(id->y);\n          }\n          free(id);\n          rtsiSetSolverData(si, NULL);\n      }\n  }\n#endif\n\n\nvoid rt_ODEUpdateContinuousStates(RTWSolverInfo *si)\n{\n    time_T    t          = rtsiGetT(si);\n    time_T    tnew       = rtsiGetSolverStopTime(si);\n    time_T    h          = rtsiGetStepSize(si);\n    real_T    *x         = rtsiGetContStates(si);\n    IntgData  *id        = rtsiGetSolverData(si);\n    real_T    *y         = id->y;\n    real_T    *f0        = id->f[0];\n    real_T    *f1        = id->f[1];\n    real_T    *f2        = id->f[2];\n    real_T    *f3        = id->f[3];\n    real_T    temp;\n    int_T     i;\n\n#ifdef NCSTATES\n    int_T     nXc        = NCSTATES;\n#else\n    int_T     nXc        = rtsiGetNumContStates(si);\n#endif\n\n    rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n    /* Save the state values at time t in y, we'll use x as ynew. */\n    (void)memcpy(y, x, nXc*sizeof(real_T));\n\n    /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n    /* f0 = f(t,y) */\n    rtsiSetdX(si, f0);\n    DERIVATIVES(si);\n\n    /* f1 = f(t + (h/2), y + (h/2)*f0) */\n    temp = 0.5 * h;\n    for (i = 0; i < nXc; i++) x[i] = y[i] + (temp*f0[i]);\n    rtsiSetT(si, t + temp);\n    rtsiSetdX(si, f1);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* f2 = f(t + (h/2), y + (h/2)*f1) */\n    for (i = 0; i < nXc; i++) x[i] = y[i] + (temp*f1[i]);\n    rtsiSetdX(si, f2);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* f3 = f(t + h, y + h*f2) */\n    for (i = 0; i < nXc; i++) x[i] = y[i] + (h*f2[i]);\n    rtsiSetT(si, tnew);\n    rtsiSetdX(si, f3);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* tnew = t + h\n       ynew = y + (h/6)*(f0 + 2*f1 + 2*f2 + 2*f3) */\n    temp = h / 6.0;\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + temp*(f0[i] + 2.0*f1[i] + 2.0*f2[i] + f3[i]);\n    }\n\n    PROJECTION(si);\n    REDUCTION(si);\n\n    rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n"},{"name":"ode5.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2009 The MathWorks, Inc.\n *\n * File: ode5.c        \n *\n */\n\n#include <math.h>\n#include <string.h>\n#include \"tmwtypes.h\"\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n#include \"odesup.h\"\n\nstatic const real_T rt_ODE5_A[6] = {\n    1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0\n};\n\nstatic real_T rt_ODE5_B[6][6] = {\n    {1.0/5.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n    {3.0/40.0, 9.0/40.0, 0.0, 0.0, 0.0, 0.0},\n    {44.0/45.0, -56.0/15.0, 32.0/9.0, 0.0, 0.0, 0.0},\n    {19372.0/6561.0, -25360.0/2187.0, 64448.0/6561.0, -212.0/729.0, 0.0, 0.0},\n    {9017.0/3168.0,-355.0/33.0,46732.0/5247.0,49.0/176.0,-5103.0/18656.0,0.0},\n    {35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0}\n};\n\ntypedef struct IntgData_tag {\n    real_T *y;\n    real_T *f[6];\n} IntgData;\n\n#ifndef RT_MALLOC\n  /* statically declare data */\n  static real_T   rt_ODE5_Y[NCSTATES];\n  static real_T   rt_ODE5_F[6][NCSTATES];\n  static IntgData rt_ODE5_IntgData = {rt_ODE5_Y,\n                                      {rt_ODE5_F[0],\n                                       rt_ODE5_F[1],\n                                       rt_ODE5_F[2],\n                                       rt_ODE5_F[3],\n                                       rt_ODE5_F[4],\n                                       rt_ODE5_F[5]}};\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      rtsiSetSolverData(si,(void *)&rt_ODE5_IntgData);\n      rtsiSetSolverName(si,\"ode5\");\n  }\n#else\n  /* dynamically allocated data */\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = (IntgData *) malloc(sizeof(IntgData));\n      if(id == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      \n      id->y = (real_T *) malloc(7*rtsiGetNumContStates(si) * sizeof(real_T));\n      if(id->y == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      id->f[0] = id->y + rtsiGetNumContStates(si);\n      id->f[1] = id->f[0] + rtsiGetNumContStates(si);\n      id->f[2] = id->f[1] + rtsiGetNumContStates(si);\n      id->f[3] = id->f[2] + rtsiGetNumContStates(si);\n      id->f[4] = id->f[3] + rtsiGetNumContStates(si);\n      id->f[5] = id->f[4] + rtsiGetNumContStates(si);\n      \n      rtsiSetSolverData(si, (void *)id);\n      rtsiSetSolverName(si,\"ode5\");\n  }\n\n  void rt_ODEDestroyIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = rtsiGetSolverData(si);\n      \n      if (id != NULL) {\n          if (id->y != NULL) {\n              free(id->y);\n          }\n          free(id);\n          rtsiSetSolverData(si, NULL);\n      }\n  }\n#endif\n\nvoid rt_ODEUpdateContinuousStates(RTWSolverInfo *si)\n{\n    time_T    t          = rtsiGetT(si);\n    time_T    tnew       = rtsiGetSolverStopTime(si);\n    time_T    h          = rtsiGetStepSize(si);\n    real_T    *x         = rtsiGetContStates(si);\n    IntgData  *intgData  = rtsiGetSolverData(si);\n    real_T    *y         = intgData->y;\n    real_T    *f0        = intgData->f[0];\n    real_T    *f1        = intgData->f[1];\n    real_T    *f2        = intgData->f[2];\n    real_T    *f3        = intgData->f[3];\n    real_T    *f4        = intgData->f[4];\n    real_T    *f5        = intgData->f[5];\n    real_T    hB[6];\n    int_T     i;\n\n#ifdef NCSTATES\n    int_T     nXc        = NCSTATES;\n#else\n    int_T     nXc        = rtsiGetNumContStates(si);\n#endif\n\n    rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n    /* Save the state values at time t in y, we'll use x as ynew. */\n    (void)memcpy(y, x, nXc*sizeof(real_T));\n\n    /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n    /* f0 = f(t,y) */\n    rtsiSetdX(si, f0);\n    DERIVATIVES(si);\n\n    /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\n    hB[0] = h * rt_ODE5_B[0][0];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0]);\n    }\n    rtsiSetT(si, t + h*rt_ODE5_A[0]);\n    rtsiSetdX(si, f1);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\n    for (i = 0; i <= 1; i++) hB[i] = h * rt_ODE5_B[1][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n    }\n    rtsiSetT(si, t + h*rt_ODE5_A[1]);\n    rtsiSetdX(si, f2);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* f(:,4) = feval(odefile, t + hA(3), y + f*hB(:,3), args(:)(*)); */\n    for (i = 0; i <= 2; i++) hB[i] = h * rt_ODE5_B[2][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n    }\n    rtsiSetT(si, t + h*rt_ODE5_A[2]);\n    rtsiSetdX(si, f3);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* f(:,5) = feval(odefile, t + hA(4), y + f*hB(:,4), args(:)(*)); */\n    for (i = 0; i <= 3; i++) hB[i] = h * rt_ODE5_B[3][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2] +\n\t\t       f3[i]*hB[3]);\n    }\n    rtsiSetT(si, t + h*rt_ODE5_A[3]);\n    rtsiSetdX(si, f4);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* f(:,6) = feval(odefile, t + hA(5), y + f*hB(:,5), args(:)(*)); */\n    for (i = 0; i <= 4; i++) hB[i] = h * rt_ODE5_B[4][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2] +\n\t\t       f3[i]*hB[3] + f4[i]*hB[4]);\n    }\n    rtsiSetT(si, tnew);\n    rtsiSetdX(si, f5);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* tnew = t + hA(6);\n       ynew = y + f*hB(:,6); */\n    for (i = 0; i <= 5; i++) hB[i] = h * rt_ODE5_B[5][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2] +\n\t\t       f3[i]*hB[3] + f4[i]*hB[4] + f5[i]*hB[5]);\n    }\n\n    PROJECTION(si);\n    REDUCTION(si);\n\n    rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n\n/* [EOF] ode5.c */\n"},{"name":"ode8.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2009 The MathWorks, Inc.\n *\n * File: ode5.c        \n *\n */\n\n#include <math.h>\n#include <string.h>\n#include \"tmwtypes.h\"\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n#include \"odesup.h\"\n\n#define MAT13 {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}\n#define TWODMAT13 {MAT13,MAT13,MAT13,MAT13,MAT13,MAT13,MAT13,MAT13,MAT13,MAT13,MAT13,MAT13,MAT13}\n#define NSTAGES 13\n#define ODE8_CONSTANTS  rt_ODE8_C[1] = 5.555555555555556E-2; \\\n\t\t\t\t\t\trt_ODE8_C[2] = 8.333333333333333E-2; \\\n\t\t\t\t\t\trt_ODE8_C[3] = 1.25E-1; \\\n\t\t\t\t\t\trt_ODE8_C[4] = 3.125E-1; \\\n\t\t\t\t\t\trt_ODE8_C[5] = 3.75E-1; \\\n\t\t\t\t\t\trt_ODE8_C[6] = 1.475E-1; \\\n\t\t\t\t\t\trt_ODE8_C[7] = 4.65E-1; \\\n\t\t\t\t\t\trt_ODE8_C[8] = 5.648654513822596E-1; \\\n\t\t\t\t\t\trt_ODE8_C[9] = 6.5E-1; \\\n\t\t\t\t\t\trt_ODE8_C[10] = 9.246562776405044E-1; \\\n\t\t\t\t\t\trt_ODE8_C[11] = 1.0; \\\n\t\t\t\t\t\trt_ODE8_C[12] = 1.0; \\\n\t\t\t\t\t\trt_ODE8_A[1][0] = 5.555555555555556E-2; \\\n\t\t\t\t\t\trt_ODE8_A[2][0] = 2.083333333333333E-2; \\\n\t\t\t\t\t\trt_ODE8_A[2][1] = 6.25E-2; \\\n\t\t\t\t\t\trt_ODE8_A[3][0] = 3.125E-2; \\\n\t\t\t\t\t\trt_ODE8_A[3][2] = 9.375E-2; \\\n\t\t\t\t\t\trt_ODE8_A[4][0] = 3.125E-1; \\\n\t\t\t\t\t\trt_ODE8_A[4][2] = -1.171875; \\\n\t\t\t\t\t\trt_ODE8_A[4][3] = 1.171875; \\\n\t\t\t\t\t\trt_ODE8_A[5][0] = 3.75E-2; \\\n\t\t\t\t\t\trt_ODE8_A[5][3] = 1.875E-1; \\\n\t\t\t\t\t\trt_ODE8_A[5][4] = 1.5E-1; \\\n\t\t\t\t\t\trt_ODE8_A[6][0] = 4.791013711111111E-2; \\\n\t\t\t\t\t\trt_ODE8_A[6][3] = 1.122487127777778E-1; \\\n\t\t\t\t\t\trt_ODE8_A[6][4] = -2.550567377777778E-2; \\\n\t\t\t\t\t\trt_ODE8_A[6][5] = 1.284682388888889E-2; \\\n\t\t\t\t\t\trt_ODE8_A[7][0] = 1.691798978729228E-2; \\\n\t\t\t\t\t\trt_ODE8_A[7][3] = 3.878482784860432E-1; \\\n\t\t\t\t\t\trt_ODE8_A[7][4] = 3.597736985150033E-2; \\\n\t\t\t\t\t\trt_ODE8_A[7][5] = 1.969702142156661E-1; \\\n\t\t\t\t\t\trt_ODE8_A[7][6] = -1.727138523405018E-1; \\\n\t\t\t\t\t\trt_ODE8_A[8][0] = 6.90957533591923E-2; \\\n\t\t\t\t\t\trt_ODE8_A[8][3] = -6.342479767288542E-1; \\\n\t\t\t\t\t\trt_ODE8_A[8][4] = -1.611975752246041E-1; \\\n\t\t\t\t\t\trt_ODE8_A[8][5] = 1.386503094588253E-1; \\\n\t\t\t\t\t\trt_ODE8_A[8][6] = 9.409286140357563E-1; \\\n\t\t\t\t\t\trt_ODE8_A[8][7] = 2.11636326481944E-1; \\\n\t\t\t\t\t\trt_ODE8_A[9][0] = 1.835569968390454E-1; \\\n\t\t\t\t\t\trt_ODE8_A[9][3] = -2.468768084315592; \\\n\t\t\t\t\t\trt_ODE8_A[9][4] = -2.912868878163005E-1; \\\n\t\t\t\t\t\trt_ODE8_A[9][5] = -2.647302023311738E-2; \\\n\t\t\t\t\t\trt_ODE8_A[9][6] = 2.8478387641928; \\\n\t\t\t\t\t\trt_ODE8_A[9][7] = 2.813873314698498E-1; \\\n\t\t\t\t\t\trt_ODE8_A[9][8] = 1.237448998633147E-1; \\\n\t\t\t\t\t\trt_ODE8_A[10][0] = -1.215424817395888; \\\n\t\t\t\t\t\trt_ODE8_A[10][3] = 1.667260866594577E1; \\\n\t\t\t\t\t\trt_ODE8_A[10][4] = 9.157418284168179E-1; \\\n\t\t\t\t\t\trt_ODE8_A[10][5] = -6.056605804357471; \\\n\t\t\t\t\t\trt_ODE8_A[10][6] = -1.600357359415618E1; \\\n\t\t\t\t\t\trt_ODE8_A[10][7] = 1.484930308629766E1; \\\n\t\t\t\t\t\trt_ODE8_A[10][8] = -1.337157573528985E1; \\\n\t\t\t\t\t\trt_ODE8_A[10][9] = 5.134182648179638; \\\n\t\t\t\t\t\trt_ODE8_A[11][0] = 2.588609164382643E-1; \\\n\t\t\t\t\t\trt_ODE8_A[11][3] = -4.774485785489205; \\\n\t\t\t\t\t\trt_ODE8_A[11][4] = -4.350930137770325E-1; \\\n\t\t\t\t\t\trt_ODE8_A[11][5] = -3.049483332072241; \\\n\t\t\t\t\t\trt_ODE8_A[11][6] = 5.577920039936099; \\\n\t\t\t\t\t\trt_ODE8_A[11][7] = 6.155831589861039; \\\n\t\t\t\t\t\trt_ODE8_A[11][8] = -5.062104586736938; \\\n\t\t\t\t\t\trt_ODE8_A[11][9] = 2.193926173180679; \\\n\t\t\t\t\t\trt_ODE8_A[11][10] = 1.346279986593349E-1; \\\n\t\t\t\t\t\trt_ODE8_A[12][0] = 8.224275996265075E-1; \\\n\t\t\t\t\t\trt_ODE8_A[12][3] = -1.165867325727766E1; \\\n\t\t\t\t\t\trt_ODE8_A[12][4] = -7.576221166909362E-1; \\\n\t\t\t\t\t\trt_ODE8_A[12][5] = 7.139735881595818E-1; \\\n\t\t\t\t\t\trt_ODE8_A[12][6] = 1.207577498689006E1; \\\n\t\t\t\t\t\trt_ODE8_A[12][7] = -2.127659113920403; \\\n\t\t\t\t\t\trt_ODE8_A[12][8] = 1.990166207048956; \\\n\t\t\t\t\t\trt_ODE8_A[12][9] = -2.342864715440405E-1; \\\n\t\t\t\t\t\trt_ODE8_A[12][10] = 1.758985777079423E-1; \\\n\t\t\t\t\t\trt_ODE8_B[0] = 4.174749114153025E-2; \\\n\t\t\t\t\t\trt_ODE8_B[5] = -5.54523286112393E-2; \\\n\t\t\t\t\t\trt_ODE8_B[6] = 2.393128072011801E-1; \\\n\t\t\t\t\t\trt_ODE8_B[7] = 7.03510669403443E-1; \\\n\t\t\t\t\t\trt_ODE8_B[8] = -7.597596138144609E-1; \\\n\t\t\t\t\t\trt_ODE8_B[9] = 6.605630309222863E-1; \\\n\t\t\t\t\t\trt_ODE8_B[10] = 1.581874825101233E-1; \\\n\t\t\t\t\t\trt_ODE8_B[11] = -2.381095387528628E-1; \\\n\t\t\t\t\t\trt_ODE8_B[12] = 2.5E-1;\n\nstatic real_T rt_ODE8_B[13] = MAT13;\n\nstatic real_T rt_ODE8_C[13] = MAT13;\n\nstatic real_T rt_ODE8_A[13][13] = TWODMAT13;\n\ntypedef struct IntgData_tag {\n    real_T *deltaY;\n    real_T *f[13];\n\treal_T *x0;\n} IntgData;\n\n#ifndef RT_MALLOC\n  /* statically declare data */\n  static real_T   rt_ODE8_DELTAY[NCSTATES];\n  static real_T   rt_ODE8_F[13][NCSTATES];\n  static real_T   rt_ODE8_X0[NCSTATES];\n  static IntgData rt_ODE8_IntgData = {rt_ODE8_DELTAY,\n                                      {rt_ODE8_F[0],\n                                       rt_ODE8_F[1],\n                                       rt_ODE8_F[2],\n                                       rt_ODE8_F[3],\n                                       rt_ODE8_F[4],\n                                       rt_ODE8_F[5],\n\t\t\t\t\t\t\t\t\t   rt_ODE8_F[6],\n\t\t\t\t\t\t\t\t\t   rt_ODE8_F[7],\n\t\t\t\t\t\t\t\t\t   rt_ODE8_F[8],\n\t\t\t\t\t\t\t\t\t   rt_ODE8_F[9],\n\t\t\t\t\t\t\t\t\t   rt_ODE8_F[10],\n\t\t\t\t\t\t\t\t\t   rt_ODE8_F[11],\n\t\t\t\t\t\t\t\t\t   rt_ODE8_F[12],\n\t\t\t\t\t\t\t\t\t  },\n\t\t\t\t\t\t\t\t\t  rt_ODE8_X0\n\t\t\t\t\t\t\t\t\t };\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n\t  ODE8_CONSTANTS\n      rtsiSetSolverData(si,(void *)&rt_ODE8_IntgData);\n      rtsiSetSolverName(si,\"ode8\");\n  }\n#else\n  /* dynamically allocated data */\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      int_T nX = rtsiGetNumContStates(si);\n      IntgData *id = (IntgData *) malloc(sizeof(IntgData));\n   \n\t  if(id == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      \n      id->deltaY = (real_T *) malloc(15*rtsiGetNumContStates(si) * sizeof(real_T));\n      if(id->deltaY == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      id->f[0]  = id->deltaY+ nX;\n      id->f[1]  = id->f[0]  + nX;\n      id->f[2]  = id->f[1]  + nX;\n      id->f[3]  = id->f[2]  + nX;\n      id->f[4]  = id->f[3]  + nX;\n      id->f[5]  = id->f[4]  + nX;\n\t  id->f[6]  = id->f[5]  + nX;\n\t  id->f[7]  = id->f[6]  + nX;\n\t  id->f[8]  = id->f[7]  + nX;\n\t  id->f[9]  = id->f[8]  + nX;\n\t  id->f[10] = id->f[9]  + nX;\n\t  id->f[11] = id->f[10] + nX;\n\t  id->f[12] = id->f[11] + nX;\n\t  id->x0    = id->f[12] + nX;\n\n\t  ODE8_CONSTANTS\n\n\t  rtsiSetSolverData(si, (void *)id);\n      rtsiSetSolverName(si,\"ode8\");\n  }\n\n  void rt_ODEDestroyIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = rtsiGetSolverData(si);\n      \n      if (id != NULL) {\n          if (id->deltaY != NULL) {\n              free(id->deltaY);\n          }\n          free(id);\n          rtsiSetSolverData(si, NULL);\n      }\n  }\n#endif\n\nvoid rt_ODEUpdateContinuousStates(RTWSolverInfo *si)\n{\n    time_T    t          = rtsiGetT(si);\n    time_T    tnew       = rtsiGetSolverStopTime(si);\n    time_T    h          = rtsiGetStepSize(si);\n    real_T    *x         = rtsiGetContStates(si);\n    IntgData  *intgData  = rtsiGetSolverData(si);\n    real_T    *deltaY    = intgData->deltaY;\n\treal_T    *x0        = intgData->x0;\n\treal_T*\t  f[NSTAGES];\n\tint idx,stagesIdx,statesIdx;\n\tdouble deltaX;\n    \n#ifdef NCSTATES\n    int_T     nXc        = NCSTATES;\n#else\n    int_T     nXc        = rtsiGetNumContStates(si);\n#endif\n\n\tf[0]        = intgData->f[0];\n    f[1]        = intgData->f[1];\n    f[2]        = intgData->f[2];\n    f[3]        = intgData->f[3];\n    f[4]        = intgData->f[4];\n    f[5]        = intgData->f[5];\n\tf[6]        = intgData->f[6];\n\tf[7]        = intgData->f[7];\n\tf[8]        = intgData->f[8];\n\tf[9]        = intgData->f[9];\n\tf[10]       = intgData->f[10];\n\tf[11]       = intgData->f[11];\n\tf[12]       = intgData->f[12];\n\n    rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n    /* Save the state values at time t in y, we'll use x as ynew. */\n    (void)memset(deltaY, 0, nXc*sizeof(real_T));\n\t(void)memcpy(x0, x, nXc*sizeof(real_T));\n\n    for(stagesIdx=0;stagesIdx<NSTAGES;stagesIdx++)\n\t{\n\t\tmemcpy(x,x0,nXc*sizeof(real_T));\n\t\t\n\t\tfor(statesIdx=0;statesIdx<nXc;statesIdx++)\n\t\t{\n\t\t\tdeltaX = 0;\n\t\t\tfor(idx=0;idx<stagesIdx;idx++)\n\t\t\t{\n\t\t\t\tdeltaX = deltaX + h*rt_ODE8_A[stagesIdx][idx]*f[idx][statesIdx];\n\t\t\t}\n\t\t\tx[statesIdx] = x0[statesIdx] + deltaX;\n\t\t}\n\t\t\n        if(stagesIdx==0)\n        {\n            rtsiSetdX(si, f[stagesIdx]);\n            DERIVATIVES(si);\n        }else\n        {\n            (stagesIdx==NSTAGES-1)? rtsiSetT(si, tnew) : rtsiSetT(si, t + h*rt_ODE8_C[stagesIdx]);\n            rtsiSetdX(si, f[stagesIdx]);\n            OUTPUTS(si,0);\n            DERIVATIVES(si);\n        }\n\t\t\t\t\n\t\tfor(statesIdx=0;statesIdx<nXc;statesIdx++) \n\t\t{\n\t\t\tdeltaY[statesIdx]  = deltaY[statesIdx] + h*rt_ODE8_B[stagesIdx]*f[stagesIdx][statesIdx];\n\t\t}\n\t}\n\t\n\tfor(statesIdx=0;statesIdx<nXc;statesIdx++) \n\t{\n\t\tx[statesIdx] = x0[statesIdx] + deltaY[statesIdx];\n\t}\n\n    PROJECTION(si);\n    REDUCTION(si);\n\n    rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n/* [EOF] ode5.c */\n"},{"name":"rt_logging.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2020 The MathWorks, Inc.\n *\n * File: rt_logging.c\n *\n * Abstract:\n *\tReal-Time Workshop data logging routines using circular buffers of\n *      fixed size.  The buffers are allocated at start, filled in at each\n *      major time step and finally written to a MAT-file at the end of the\n *      simulation.\n *\n *      This file handles redefining the following standard MathWorks types\n *      (see tmwtypes.h):\n *         [u]int8_T     to be int32_T (logged as Matlab [u]int32)\n *         [u]int16_T    to be int32_T (logged as Matlab [u]int32)\n *         real_T        to be real32_T (logged as Matlab single)\n *\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rt_logging.h\"\n#ifndef IS_RAPID_ACCEL\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n#define matLOGICAL_BIT          0x200\n#define matCOMPLEX_BIT          0x800\n\n#define matKEY                 0x4D49\n#define matVERSION             0x0100\n#define matVERSION_INFO_OFFSET   124L\n\n#define matINT64_ALIGN(e)      ( ( ((unsigned)(e))+7 ) & (~7) )\n#define matTAG_SIZE            (sizeof(int32_T) << 1)\n\n#ifndef DEFAULT_BUFFER_SIZE\n#define DEFAULT_BUFFER_SIZE      1024  /* used if maxRows=0 and Tfinal=0.0    */\n#endif\n\n#define FREE(m) if (m != NULL) free(m)\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/*==========*\n * typedefs *\n *==========*/\n\ntypedef struct LogInfo_Tag {\n    LogVar       *t;                   /* Time log variable                   */\n    void         *x;                   /* State log variable                  */\n    int_T        ny;                   /* Length of \"y\" log variables         */\n    void         **y;                  /* Output log vars                     */\n    void         *xFinal;              /* Final state log variable            */\n\n    LogVar       *logVarsList;         /* Linked list of all LogVars          */\n    StructLogVar *structLogVarsList;   /* Linked list of all StructLogVars    */\n\n    boolean_T   haveLogVars;           /* Are logging one or more vars?       */\n} LogInfo;\n\ntypedef struct MatItem_tag {\n  int32_T    type;\n  uint32_T    nbytes;\n  const void *data;\n} MatItem;\n\ntypedef enum {\n    DATA_ITEM,\n    MATRIX_ITEM,\n    STRUCT_LOG_VAR_ITEM,\n    SIGNALS_STRUCT_ITEM\n} ItemDataKind;\n\n/*===========*\n * Constants *\n *===========*/\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n\n#define ZEROS32 \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\n#if mxMAXNAM==32\n\n#define ZERO_PAD\n\n#elif mxMAXNAM==64\n\n#define ZERO_PAD ZEROS32\n\n#elif mxMAXNAM==128\n\n#define ZERO_PAD   ZEROS32  ZEROS32  ZEROS32\n\n#else\n\n#error \"Cannot Handle mxMAXNAM other than 32,64, and 128\"\n\n#endif\n/* field names: for variable-size signal logging */\nstatic const char_T rtStructLogVarFieldNames[] =\n                  \"time\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"signals\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtLocalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n                  \n\n#define TIME_FIELD_NAME      (rtStructLogVarFieldNames[0*mxMAXNAM])\n#define SIGNALS_FIELD_NAME   (rtStructLogVarFieldNames[1*mxMAXNAM])\n#define BLOCKNAME_FIELD_NAME (rtStructLogVarFieldNames[2*mxMAXNAM])\n\n#define VALUES_FIELD_NAME    (rtLocalLoggingSignalsStructFieldNames[0*mxMAXNAM])\n#define VALUEDIMENSIONS_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[1*mxMAXNAM])\n#define DIMENSION_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[2*mxMAXNAM])\n#define LABEL_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[3*mxMAXNAM])\n#define TITLE_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[4*mxMAXNAM])\n#define PLOTSTYLE_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n\n#define STATENAME_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n#define CROSS_MDL_REF_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[6*mxMAXNAM])\n\n/* field names: for fixed-size signal logging */\nstatic const char_T rtLocalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nextern real_T rtInf; /* declared by rt_nonfinite.c */\nextern real_T rtNaN;\nextern real32_T rtNaNF;\n\n/*================*\n * Local routines *\n *================*/\n\n/* Function: rt_GetSizeofDataType ==============================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofDataType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 0; /* unknown */\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        elSz = sizeof(real_T);\n        break;\n      case SS_SINGLE:\n        elSz = sizeof(real32_T);\n        break;\n      case SS_INT8:\n        elSz = sizeof(int8_T);\n        break;\n      case SS_UINT8:\n        elSz = sizeof(uint8_T);\n        break;\n      case SS_INT16:\n        elSz = sizeof(int16_T);\n        break;\n      case SS_UINT16:\n        elSz = sizeof(uint16_T);\n        break;\n      case SS_INT32:\n        elSz = sizeof(int32_T);\n        break;\n      case SS_UINT32:\n        elSz = sizeof(uint32_T);\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n    return(elSz);\n\n} /* end rt_GetSizeofDataType */\n\n\n/* Function: rt_GetSizeofComplexType ===========================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofComplexType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 2*rt_GetSizeofDataType(dTypeID);\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal_T);\n      #endif\n        break;\n      case SS_SINGLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal32_T);\n      #endif\n        break;\n      case SS_INT8:\n      #ifdef CINT8_T\n        elSz = sizeof(cint8_T);\n      #endif\n        break;\n      case SS_UINT8:\n      #ifdef CUINT8_T\n        elSz = sizeof(cuint8_T);\n      #endif\n        break;\n      case SS_INT16:\n      #ifdef CINT16_T\n        elSz = sizeof(cint16_T);\n      #endif\n        break;\n      case SS_UINT16:\n      #ifdef CUINT16_T\n        elSz = sizeof(cuint16_T);\n      #endif\n        break;\n      case SS_INT32:\n      #ifdef CINT32_T\n        elSz = sizeof(cint32_T);\n      #endif\n        break;\n      case SS_UINT32:\n      #ifdef CUINT32_T\n        elSz = sizeof(cuint32_T);\n      #endif\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n\n    return(elSz);\n\n} /* end rt_GetSizeofComplexType */\n\n\n/* Function: rt_GetDataTypeConvertInfo =========================================\n * Abstract:\n *      Directly copy if pointer to structure is non-NULL, otherwise set to\n *      default.\n */\nstatic RTWLogDataTypeConvert rt_GetDataTypeConvertInfo(\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    BuiltInDTypeId dTypeID\n    )\n{\n    RTWLogDataTypeConvert dataTypeConvertInfoCopy;\n\n    if (pDataTypeConvertInfo == NULL) {\n        dataTypeConvertInfoCopy.conversionNeeded = 0;\n        dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;\n        dataTypeConvertInfoCopy.dataTypeIdOriginal  = (DTypeId)dTypeID;\n        dataTypeConvertInfoCopy.bitsPerChunk = 0;\n        dataTypeConvertInfoCopy.numOfChunk = 0;\n        dataTypeConvertInfoCopy.isSigned = 0;\n        dataTypeConvertInfoCopy.fracSlope = 1.0;\n        dataTypeConvertInfoCopy.fixedExp = 0;\n        dataTypeConvertInfoCopy.bias = 0.0;\n    } else {\n        dataTypeConvertInfoCopy = *pDataTypeConvertInfo;\n    }\n\n    return dataTypeConvertInfoCopy;\n\n} /* end rt_GetDataTypeConvertInfo */\n\n\n/* Function: rt_GetDblValueFromOverSizedData ===================================\n * Abstract:\n */\nstatic double rt_GetDblValueFromOverSizedData(\n    const void *pVoid, \n    int bitsPerChunk, \n    int numOfChunk,\n    unsigned int isSigned, \n    double fracSlope, \n    int fixedExp, \n    double bias)\n{\n    double retValue = 0;\n\n    double *dblValue = (double *) calloc(numOfChunk, sizeof(double));\n\n    int i;    \n    double isSignedNeg;\n\n    if(isSigned) {\n        const chunk_T *pData = (const chunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    } else  {\n        const uchunk_T *pData = (const uchunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    }\n\n    /* \n       Assuming multi chunks b_n ... b_2 b_1 b_0, and the length of each chunk is N.\n       Suppose b_i is the i-th chunk's value.\n       Then for unsigned data or data with one chunk: we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0;\n       But for signed data, we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0+ (b_0<0) * 2^N + \n       ... (b_(n-1) <0) * 2^(n*N) \n       = (b_n + (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + (b_0<0)) * 2^N + b_0 * 2^0;\n       Together:\n       retValue = \n       (b_n + isSigned * (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + isSigned * (b_0<0)) * 2^N + b_0 * 2^0;\n    */\n\n    retValue = dblValue[numOfChunk - 1];\n    \n    for(i = numOfChunk - 1; i > 0; i--) {\n        isSignedNeg = dblValue[i - 1] < 0 ? (double)isSigned : 0;\n        retValue = retValue + isSignedNeg;\n\n        retValue = ldexp(retValue, bitsPerChunk)+ dblValue[i-1];\n    }\n    retValue = ldexp( fracSlope * retValue, fixedExp ) + bias;\n\n    FREE(dblValue);\n    return (retValue);\n\n} /* end rt_GetDblValueFromOverSizedData */\n\n\n/* Function: rt_GetNonBoolMxIdFromDTypeId ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nstatic mxClassID rt_GetNonBoolMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        mxID = (sizeof(real_T)==4? mxSINGLE_CLASS: mxDOUBLE_CLASS);\n        break;\n      case SS_SINGLE:\n        mxID = mxSINGLE_CLASS;\n        break;\n      case SS_INT8:\n        switch (sizeof(int8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 32-bits\" */\n            mxID = mxINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 16-bits\" */\n            mxID = mxINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_UINT8:\n        switch (sizeof(uint8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxUINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_INT16:\n        mxID = (sizeof(int16_T)==4? mxINT32_CLASS: mxINT16_CLASS);\n        break;\n      case SS_UINT16:\n        mxID = (sizeof(uint16_T)==4? mxUINT32_CLASS: mxUINT16_CLASS);\n        break;\n      case SS_INT32:\n        mxID = mxINT32_CLASS;\n        break;\n      case SS_UINT32:\n        mxID = mxUINT32_CLASS;\n        break;\n        /*case SS_BOOLEAN:\n          mxID = (sizeof(boolean_T)==4? mxUINT32_CLASS: mxLOGICAL_CLASS);\n          break;*/\n      default:\n        mxID = mxUNKNOWN_CLASS;\n        break;\n    }\n\n    return(mxID);\n\n} /* end rt_GetNonBoolMxIdFromDTypeId */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeIdForRSim ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxLOGICAL_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeIdForRSim */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeId =============================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxUINT8_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeId */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n/* Function: rt_GetMatIdFromMxId ===============================================\n * Abstract:\n *      Get the MatId given the mxClassID.\n */\nstatic int_T rt_GetMatIdFromMxId(mxClassID mxID)\n{\n    int_T matID;\n\n    switch (mxID) {\n      case mxCELL_CLASS:\n      case mxSTRUCT_CLASS:\n      case mxOBJECT_CLASS:\n        matID = -1;\n        break;\n      case mxCHAR_CLASS:\n        matID = matUINT16;\n        break;\n      case mxDOUBLE_CLASS:\n        matID = matDOUBLE;\n        break;\n      case mxSINGLE_CLASS:\n        matID = matFLOAT;\n        break;\n      case mxINT8_CLASS:\n        matID = matINT8;\n        break;\n      case mxUINT8_CLASS:\n        matID = matUINT8;\n        break;\n      case mxINT16_CLASS:\n        matID = matINT16;\n        break;\n      case mxUINT16_CLASS:\n        matID = matUINT16;\n        break;\n      case mxINT32_CLASS:\n        matID = matINT32;\n        break;\n      case mxUINT32_CLASS:\n        matID = matUINT32;\n        break;\n      case mxINT64_CLASS:\n        matID = matINT64;\n        break;\n      case mxUINT64_CLASS:\n        matID = matUINT64;\n        break;\n      default:\n        matID = matUNKNOWN;\n        break;\n    }\n    return(matID);\n\n} /* end rt_GetMatIdFromMxId */\n\n\n/* Forward declaration */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind dataKind);\n\n\n/* Function: rt_ProcessMatItem =================================================\n * Abstract:\n *      This routine along with rt_WriteItemToMatFile() write out a specified\n *      mat-item the .mat file. Note that if the input argument\n *          cmd == 0, then this function just calculates the size of the item.\n *          cmd <> 0, this function writes the mat-item to the file.\n *      Return values is\n *           -1 : coding/logic error\n *            0 : upon success\n *          > 0 : upon write failure (1)\n */\nstatic int_T rt_ProcessMatItem(FILE         *fp,\n                               MatItem      *pItem,\n                               ItemDataKind itemKind,\n                               int_T        cmd)\n{\n    mxClassID    mxID          = mxUNKNOWN_CLASS;\n    uint32_T     arrayFlags[2] = {0, 0};\n    int32_T      *dims         = NULL;\n    int32_T      _dims[3]      = {0, 0, 0};\n    int32_T      nDims         = 2;\n    int32_T      nBytesInItem  = 0;\n    const char_T *itemName;\n    MatItem      item;\n    int_T        retStat       = 0;\n\n    switch (itemKind) {\n      case DATA_ITEM: {\n          (void)fprintf(stderr,\"Unexpected itemKind = DATA_ITEM in \"\n                               \"rt_ProcessMatItem @A\\n\");\n          retStat = -1;\n          goto EXIT_POINT;\n      }\n      case MATRIX_ITEM: {\n          const MatrixData *var = (const MatrixData *) pItem->data;\n\n          mxID           = var->mxID;\n          arrayFlags[0]  = mxID;\n          arrayFlags[0] |= var->logical;\n          arrayFlags[0] |= var->complex;\n          if (var->nDims < 2) {\n              dims         = _dims;\n              dims[0]      = var->nRows;\n              dims[1]      = var->nCols;\n              nDims        = 2;\n          } else {\n              int32_T k;\n              dims = (int32_T*)malloc(sizeof(int32_T)*(var->nDims+1));\n              for (k = 0; k < var->nDims; k++) {\n                  dims[k] = var->dims[k];\n              }\n              dims[var->nDims] = var->nRows;\n              nDims = var->nDims + 1;\n          }\n          itemName = var->name;\n          break;\n      }\n      case STRUCT_LOG_VAR_ITEM: {\n          const StructLogVar *var = (const StructLogVar *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = 1;\n          itemName      = var->name;\n          break;\n      }\n      case SIGNALS_STRUCT_ITEM: {\n          const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = var->numSignals;\n          itemName      = &SIGNALS_FIELD_NAME;\n          break;\n      }\n      default:\n        (void)fprintf(stderr,\"Unexpected itemKind=%d in rt_ProcessMatItem @B\\n\",\n                      itemKind);\n        retStat = -1;\n        goto EXIT_POINT;\n    }\n\n    /* array flags */\n    item.nbytes = 2*sizeof(uint32_T);\n    if (cmd) {\n        item.type = matUINT32;\n        item.data = arrayFlags;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* dimensions */\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    item.nbytes = nDims*sizeof(int32_T);\n    if (cmd) {\n        item.type = matINT32;\n        item.data = dims;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;            \n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* name */\n    item.nbytes = (int32_T)strlen(itemName);\n    if (cmd) {\n        item.type = matINT8;\n        item.data = (const char_T*) itemName;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        nBytesInItem += (item.nbytes <= 4) ? /*LINTED E_CAST_INT_TO_SMALL_INT*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n\n    if (itemKind == MATRIX_ITEM) {\n        const MatrixData *var   = (const MatrixData*) pItem->data;\n        int_T            matID  = rt_GetMatIdFromMxId(mxID);\n        size_t           elSize = var->elSize;\n\n        /* data */\n        item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n        if (cmd) {\n            item.type = matID;\n            item.data = var->re;\n            if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n        }\n        /* imaginary part */\n        if (var->complex) {\n            item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n            if (cmd) {\n                item.type = matID;\n                item.data = var->im;\n                if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                    retStat = 1;\n                    goto EXIT_POINT;\n                }\n            } else {\n                nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n            }\n        }\n    } else {  /* some type of structure item */\n        const char_T *fieldNames;\n        int_T        sizeofFieldNames;\n\n        /* field names */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = (const StructLogVar *) pItem->data;\n              fieldNames        = rtStructLogVarFieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n              fieldNames        = var->fieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @C\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n\n        /* write field names */\n        if (cmd) {\n            int32_T tmpInt = mxMAXNAM;\n\n            item.nbytes = sizeof(int32_T);\n            item.type   = matINT32;\n            item.data   = &tmpInt;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n\n            item.nbytes = sizeofFieldNames;\n            item.type   = matINT8;\n            item.data   = (const char_T*) fieldNames;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            /*LINTED E_CAST_INT_TO_SMALL_INT*/\n            nBytesInItem += matINT64_ALIGN( matTAG_SIZE + matTAG_SIZE +\n                                            sizeofFieldNames );\n        }\n\n        /* process each field of the structure */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = pItem->data;\n\n              /* time */\n              {\n                  const void *data = var->time;\n\n                  if (var->logTime) { /* time is a LogVar, get the MatrixData */\n                      data = &(((const LogVar*) (var->time))->data);\n                  }\n\n                  item.type = matMATRIX;\n                  item.data = data;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp,&item,MATRIX_ITEM)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM,0)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n\n              /* signals */\n              item.type = matMATRIX;\n              item.data = &(var->signals);\n              if (cmd) {\n                  if (rt_WriteItemToMatFile(fp,&item,SIGNALS_STRUCT_ITEM)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n              } else {\n                  if (rt_ProcessMatItem(fp, &item, SIGNALS_STRUCT_ITEM,0)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n                  nBytesInItem += item.nbytes + matTAG_SIZE;\n              }\n\n              /* block name */\n              if (var->blockName != NULL) {\n                  item.type = matMATRIX;\n                  item.data = var->blockName;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var        = pItem->data;\n              const LogVar        *values     = var->values;\n              const MatrixData    *dimensions = var->dimensions;\n              const MatrixData    *labels     = var->labels;\n              const MatrixData    *plotStyles = var->plotStyles;\n              const MatrixData    *titles     = var->titles;\n              const MatrixData    *blockNames = var->blockNames;\n              const MatrixData    *stateNames = var->stateNames;\n              const MatrixData    *crossMdlRef = var->crossMdlRef;\n              const boolean_T logValueDimensions = var->logValueDimensions;\n              int_T               i;\n\n              for (i = 0; i < var->numSignals; i++) {\n                  /* values */\n                  item.type = matMATRIX;\n                  item.data = &(values->data);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n\n                  if(logValueDimensions)\n                  {\n                      /* valueDimensions */\n                      /* Since the functions rt_WriteItemToMatFile and \n                         rt_ProcessMatItem deal with MatrixData, \n                         convert valDims to tempData, and fill up the\n                         necessary fields.\n                      */\n                      MatrixData  tempData;\n                      (void)memcpy(tempData.name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n                      tempData.nRows = values->valDims->nRows;\n                      tempData.nCols = values->valDims->nCols;\n                      tempData.nDims = 1;\n                      tempData._dims[0] = values->valDims->nCols;\n                      tempData.re = values->valDims->dimsData;\n                      tempData.im = NULL;\n                      tempData.dTypeID = SS_DOUBLE;\n                      tempData.elSize =  sizeof(real_T);\n                      tempData.mxID = mxDOUBLE_CLASS;\n                      tempData.logical = 0;\n                      tempData.complex = 0;\n                      tempData.frameData = 0;\n                      tempData.frameSize = 1;\n\n                      item.type = matMATRIX;                    \n                      item.data = &tempData; /*values->valDims;*/\n\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  values = values->next;\n\n                  /* dimensions */\n                  if (dimensions != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(dimensions[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n\n                  /* label */\n                  item.type = matMATRIX;\n                  item.data = &(labels[i]);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n                  /* title */\n                  if (titles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(titles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* plot style */\n                  if (plotStyles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(plotStyles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* block name */\n                  if (blockNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(blockNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* state name */\n                  if (stateNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* crossMdlRef */\n                  if (crossMdlRef != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(crossMdlRef[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n              } /* for i=1:numSignals */\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @D\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n    } /* end struct item */\n\n    if (!cmd) {\n        pItem->nbytes = nBytesInItem;\n    }\n\n  EXIT_POINT:\n    if (dims != _dims) {\n        FREE(dims);\n    }\n    return(retStat);\n\n} /* end rt_ProcessMatItem */\n\n\n/* Function: rt_WriteItemToMatFile =============================================\n * Abstract:\n *      Entry function for writing out a mat item to the mat file.\n *\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind itemKind)\n{\n    /* Determine the item size */\n    if (pItem->type == matMATRIX) {\n        if (rt_ProcessMatItem(fp, pItem, itemKind, 0)) return(1);\n    }\n\n    /* Write the item tag and data */\n    if (pItem->nbytes > 4) {\n        int32_T nAlignBytes;\n\n        if (fwrite(pItem, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n\n        if (pItem->type == matMATRIX) {\n            if (rt_ProcessMatItem(fp, pItem, itemKind, 1)) return(1);\n        } else {\n            if ( fwrite(pItem->data, 1, pItem->nbytes, fp) !=\n                                                    ((size_t) pItem->nbytes) ) {\n                return(1);\n            }\n        }\n\n        /* Add offset for 8-byte alignment */\n        nAlignBytes = matINT64_ALIGN(pItem->nbytes) - pItem->nbytes;\n        if (nAlignBytes > 0) {\n            int pad[2] = {0, 0};\n            if ( fwrite(pad,1,nAlignBytes,fp) != ((size_t) nAlignBytes) ) {\n                return(1);\n            }\n        }\n    } else {\n        MatItem item = {0, 0, NULL};\n        item.type = ((uint32_T)(pItem->type))|(((uint32_T)(pItem->nbytes))<<16);\n        (void)memcpy(&item.nbytes, pItem->data, pItem->nbytes);\n        if (fwrite(&item, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n    }\n\n    return(0);\n\n} /* end rt_WriteItemToMatFile */\n\n\n/* Function: rt_WriteMat5FileHeader ============================================\n * Abstract:\n *      Function to write the mat file header.\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteMat5FileHeader(FILE *fp)\n{\n    int_T        nbytes;\n    int_T        nspaces;\n    int_T        i, n;\n    unsigned short ver[2];\n    char_T       spaces[16];\n    const char_T *matversion = \"MATLAB 5.0 MAT-file\";\n\n    (void)memset(spaces, ' ', sizeof(spaces));\n\n    n = (int_T)strlen(matversion);\n    nbytes = (int_T)fwrite(matversion, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    nspaces = matVERSION_INFO_OFFSET - nbytes;\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces % sizeof(spaces);\n    nbytes += (int_T)fwrite(spaces, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces / sizeof(spaces);\n    for (i = 0; i < n; ++i) {\n        nbytes += (int_T)fwrite(spaces, 1, sizeof(spaces), fp);\n    }\n    if (nbytes == matVERSION_INFO_OFFSET) {\n        ver[0] = matVERSION;\n        ver[1] = matKEY;\n        nbytes += (int_T)fwrite(ver, 1, sizeof(ver), fp);\n    }\n    return(nbytes != matVERSION_INFO_OFFSET + sizeof(ver));\n\n} /* end rt_WriteMat5FileHeader */\n\n\n/* Function: rt_FixupLogVar ====================================================\n * Abstract:\n *\tMake the logged variable suitable for MATLAB.\n */\nstatic const char_T *rt_FixupLogVar(LogVar *var,int verbose)\n{\n    int_T  nCols   = var->data.nCols;\n    int_T  maxRows = var->data.nRows;\n    int_T  nDims   = var->data.nDims;\n    size_t elSize  = var->data.elSize;\n    int_T  nRows   = (var->wrapped ?  maxRows : var->rowIdx);\n\n    var->nDataPoints = var->rowIdx + var->wrapped * maxRows;\n\n    if (var->wrapped > 1 || (var->wrapped == 1 && var->rowIdx != 0)) {\n        /*\n         * Warn the user the circular buffer has wrapped, implying that\n         * some data has been lost.\n         */\n        if( verbose) {\n            (void)fprintf(stdout,\n                          \"*** Log variable %s has wrapped %d times\\n\"\n                          \"    using a circular buffer of size %d\\n\",\n                          var->data.name, var->wrapped, var->data.nRows);\n        }\n        if (var->usingDefaultBufSize) {\n            /*\n             * If wrapping occurred using the default buffer size,\n             * let the user know what size buffer to use in the\n             * future to avoid wrapping.  If the default buffer\n             * size was not used, the user has no control to specify\n             * the correct value.  Wrapping may occur when not using\n             * the default buffer if we allocated too small a buffer\n             * size for this logvar.  One common case is a toWorkspace\n             * block inside of an iterative subsystem - we can not take\n             * the number of iterations into account (they may be\n             * variable) when allocating the buffer.  In this case,\n             * just warn the buffer wrapped and don't tell user they\n             * can override the buffer size.\n             */\n            if( verbose ) {\n                (void)fprintf(stdout,\n                              \"*** To avoid wrapping, explicitly specify a\\n\"\n                              \"    buffer size of %d in your Simulink model\\n\"\n                              \"    by adding OPTS=\\\"-DDEFAULT_BUFFER_SIZE=%d\\\"\\n\"\n                              \"    as an argument to the ConfigSet MakeCommand\\n\"\n                              \"    parameter\\n\",\n                              var->nDataPoints, var->nDataPoints);\n            }\n        }\n    }\n\n    if (nDims < 2 && nCols > 1) {  /* Transpose? */\n        /* Don't need to transpose valueDimensions */\n        int_T  nEl    = nRows*nCols;\n        char   *src   = var->data.re;\n        char   *pmT;\n        int_T  k;\n\n        /**********************************\n         * If memory cannot be allocated, *\n         * write to a temporary buffer    *\n         **********************************/\n        if ((pmT = malloc(nEl*elSize)) == NULL) {\n            FILE  *fptr;\n            char  fName[mxMAXNAM+13];\n\n            (void)sprintf(fName, \"%s%s\", var->data.name, \"_rtw_tmw.tmw\");\n            if ((fptr=fopen(fName,\"w+b\")) == NULL) {\n                (void)fprintf(stderr,\"*** Error opening %s\",fName);\n                return(\"unable to open data file\\n\");\n            }\n\n            /****************************\n             * Write the data to a file *\n             ****************************/\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nCols*(k%nRows) + (k/nRows);\n                char  *dst = src + kT*elSize;\n                (void)fwrite(dst, elSize, 1, fptr);\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n\n            /*******************************\n             * Read the data from the file *\n             *******************************/\n            (void)rewind(fptr);\n            (void)fread(var->data.re, elSize, nEl, fptr);\n            (void)fclose(fptr);\n            (void)remove(fName);\n        } else {\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nRows*(k%nCols) + (k/nCols);\n                char  *dst = pmT + kT*elSize;\n                (void)memcpy(dst, src, elSize);\n                src += elSize;\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n            FREE(var->data.re);\n            var->data.re = pmT;\n        }\n    } /* Transpose? */\n\n    if (var->wrapped > 0 && var->rowIdx != 0 ) {  /* Rotate? */\n        char_T *buffer    = var->data.re;\n        int_T  done       = 0; /* done: 0 (1) rotate real (imag) part. */\n\n        do {\n            char_T *col       = buffer;\n            int_T  rowOffset  = (int_T)((nDims == 1) ? (elSize) : (elSize * nCols));\n            int_T  colOffset  = (int_T)((nDims == 1)?  (nRows*elSize) : elSize);\n            int_T  zeroIdx    = var->rowIdx;\n            int_T  j;\n\n            for (j = 0 ; j < nCols; ++j, col += colOffset) {\n                int_T   swapCount;\n                int_T   srcIdx;\n                int_T   dstIdx;\n                int_T   tmpIdx;\n                MatReal tmp;\n\n                for (tmpIdx=0, swapCount=0; swapCount < nRows; tmpIdx++) {\n                    (void)memcpy(&tmp, col + tmpIdx*rowOffset, elSize);\n\n                    dstIdx=tmpIdx; \n                    srcIdx = ((dstIdx + zeroIdx) % nRows);\n                    while (srcIdx != tmpIdx) {\n                        (void)memcpy(col + dstIdx*rowOffset,\n                                     col + srcIdx*rowOffset,\n                                     elSize);\n                        ++swapCount;\n                        dstIdx = srcIdx;\n                        srcIdx = ((dstIdx + zeroIdx) % nRows);\n                        \n                    }\n                    (void)memcpy(col + dstIdx*rowOffset, &tmp, elSize);\n                    ++swapCount;\n                }\n            }\n            done ++;\n            /* need to rotate the imaginary part */\n        } while ((done == 1) && ((buffer = var->data.im) != NULL));\n\n        var->rowIdx = 0;\n    } /* Rotate? */\n\n    /*\n     * We might have allocated more number of rows than the number of data\n     * points that have been logged, in which case set nRows to nDataPoints\n     * so that only these values get saved.\n     */\n    if (var->nDataPoints < var->data.nRows) {\n        var->data.nRows = var->nDataPoints;\n        if(var->valDims != NULL){\n            size_t elSizeValDims = sizeof(real_T);\n            int_T  k;\n            real_T *dimsData = var->valDims->dimsData + nRows;\n            /* \n               Keep nRows of values and that of valueDimensions consistent \n               for variable-size signals.\n            */\n            var->valDims->nRows = var->data.nRows;\n            /*\n               Also need to move data when shrinking the array size,\n               because valueDimensions data is stored in array format. \n               e.g. maxRows = 4; nRows = 2; nDims = 3;\n               Before fixing up the logVar, the locations of data are as below:\n               (x, y, z -- useful data / o -- junk)\n               a[0] = x    a[4] = y    a[8] = z\n               a[1] = x    a[5] = y    a[9] = z\n               a[2] = o    a[6] = o    a[10]= o\n               a[3] = o    a[7] = o    a[11]= o\n               After fixing up the logVar, we want the data to be stored as:\n               a[0] = x    a[4] = z    a[8] = o\n               a[1] = x    a[5] = z    a[9] = o\n               a[2] = y    a[6] = o    a[10]= o\n               a[3] = y    a[7] = o    a[11]= o\n            */\n            for(k = 1; k < nDims; k++){\n                (void) memmove(dimsData, \n                              var->valDims->dimsData + k*maxRows,\n                              elSizeValDims * nRows);\n                dimsData += nRows;\n            }\n        }\n    }\n    return(NULL);\n\n} /* end rt_FixupLogVar */\n\n\n/* Function: rt_LoadModifiedLogVarName =========================================\n * Abstract:\n *      The name of the logged variable is obtained from the input argument\n *      varName and the nameModifier which is obtained from the simstruct. If\n *      the nameModifier begins with an '_', then nameModifier is post-pended to\n *      varName to obtain the name of the logged variable. If the first\n *      character does not begin with an '_', then the nameModifier is\n *      pre-pended to varName.\n *\n * Examples:\n *     a)  varName = \"tout\" & nameModifier = \"_rt\"  => logVarName = \"tout_rt\"\n *     b)  varName = \"tout\" & nameModifier = \"rt_\"  => logVarName = \"rt_tout\"\n *     c)  varName = \"tout\" & nameModifier = \"none\" => logVarName = \"tout\"\n */\nstatic void rt_LoadModifiedLogVarName(const RTWLogInfo *li,         /* in  */\n                                      const char       *varName,    /* in  */\n                                      char             *logVarName) /* out */\n{\n    int_T        nameLen;\n    const char_T *nameModifier = rtliGetLogVarNameModifier(li);\n\n    if (nameModifier != NULL && strcmp(nameModifier,\"none\")==0) {\n        nameModifier = NULL;\n    }\n\n    logVarName[mxMAXNAM-1] = '\\0';\n    if (nameModifier == NULL) {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n    } else if (nameModifier[0] == '_') {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, nameModifier, (size_t)mxMAXNAM-1-nameLen);\n    } else {\n        (void)strncpy(logVarName, nameModifier, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, varName, (size_t)mxMAXNAM-1-nameLen);\n    }\n\n} /* end rt_LoadModifiedLogVarName */\n\n\n/* Function: rt_GetActualDTypeID ===============================================\n * Abstract:\n *\tGiven a built-in data type id, return the actual data type id.\n *\tThe only time these are different is when real_T has been mapped\n *\tto a single.\n */\n#if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable: 4127)\n#endif\nstatic BuiltInDTypeId rt_GetActualDTypeID(BuiltInDTypeId dTypeID)\n{\n    /*LINTED E_FALSE_LOGICAL_EXPR*/\n    if (dTypeID == SS_DOUBLE && sizeof(real_T) != 8) {     /* polyspace DEFECT:DEAD_CODE \n                                                              [Not a defect:Unset] \n                                                              \"Needed for when real_T has been \n                                                              mapped to a single\" */\n        return(SS_SINGLE);\n    } else {\n        return(dTypeID);\n    }\n\n} /* end rt_GetActualDTypeID */\n#if defined(_MSC_VER)\n #pragma warning(pop)\n#endif\n\n\n/* Function: rt_DestroyLogVar ==================================================\n * Abstract:\n *      Destroy the log var linked list.\n */\nstatic void rt_DestroyLogVar(LogVar *head)\n{\n    while(head) {\n        LogVar *var = head;\n        head = var->next;\n        FREE(var->data.re);\n        FREE(var->data.im);\n        if (var->data.dims != var->data._dims) {\n            FREE(var->data.dims);\n        }\n        /* free valDims if necessary */\n        if(var->valDims != NULL) {\n            FREE(var->valDims->dimsData);\n            FREE(var->valDims);\n        }\n        /* free coords, strides and currStrides if necessary */\n        FREE(var->coords);\n        FREE(var->strides);\n        FREE(var->currStrides);\n\n        FREE(var);\n    }\n\n} /* end rt_DestroyLogVar */\n\n\n/* Function: rt_DestroyStructLogVar ============================================\n * Abstract:\n *      Destroy the struct log var linked list.\n */\nstatic void rt_DestroyStructLogVar(StructLogVar *head)\n{\n    while(head) {\n        StructLogVar *var = head;\n\n        head = var->next;\n\n        if (var->logTime) { /* time is LogVar */\n            rt_DestroyLogVar(var->time);\n        } else {        /* time is MatrixData */\n            FREE(var->time);\n        }\n        rt_DestroyLogVar(var->signals.values);\n        FREE(var->signals.labels);\n        FREE(var->signals.plotStyles);\n        FREE(var->signals.dimensions);\n        FREE(var->signals.titles);\n        FREE(var->signals.blockNames);\n        FREE(var->signals.stateNames);\n        FREE(var->signals.crossMdlRef);\n        FREE(var->blockName);\n        FREE(var);\n    }\n\n} /* end rt_DestroyStructLogVar */\n\n\n/* Function: rt_InitSignalsStruct ==============================================\n * Abstract:\n *      Initialize the signals structure in the struct log variable.\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nstatic const char_T *rt_InitSignalsStruct(RTWLogInfo             *li,\n                                          const real_T           startTime,\n                                          const real_T           finalTime,\n                                          const real_T           inStepSize,\n                                          const char_T           **errStatus,\n                                          StructLogVar           *var,\n                                          int_T                  maxRows,\n                                          int_T                  decimation,\n                                          real_T                 sampleTime,\n                                          const RTWLogSignalInfo *sigInfo)\n{\n    int_T                i, sigIdx;\n    SignalsStruct        *sig          = &(var->signals);\n    int_T                nSignals      = sigInfo->numSignals;\n    const int_T          *numCols      = sigInfo->numCols;\n    const int_T          *numDims      = sigInfo->numDims;\n    const int_T          *dims         = sigInfo->dims;\n    const BuiltInDTypeId *dTypes       = sigInfo->dataTypes;\n    const int_T          *cSgnls       = sigInfo->complexSignals;\n    const int_T          *fData        = sigInfo->frameData;\n    const char_T         **labels      = sigInfo->labels.cptr;\n    const int_T          *plotStyles   = sigInfo->plotStyles;\n    const char_T         *titles       = sigInfo->titles;\n    const int_T          *titleLen     = sigInfo->titleLengths;\n    const char_T         **blockNames  = sigInfo->blockNames.cptr;\n    const char_T         **stateNames  = sigInfo->stateNames.cptr;\n    const boolean_T      *crossMdlRef  = sigInfo->crossMdlRef;\n    void                 **currSigDims = sigInfo->currSigDims;\n    int_T                *currSigDimsSize = sigInfo->currSigDimsSize;\n    LogVar               *prevValues   = NULL;\n    int_T                dimsOffset    = 0;\n    boolean_T            *isVarDims    = sigInfo->isVarDims;\n    /* if any signal is variable-size, the field 'valueDimensions' is needed */\n    boolean_T            logValueDimensions = false;\n    const RTWLogDataTypeConvert *pDTConvInfo = sigInfo->dataTypeConvert;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    sig->numActiveFields = 1;\n    sig->numSignals      = nSignals;\n\n    sig->isVarDims = isVarDims;\n    /* check whether we need valueDimensions field*/\n    for (i=0; i<nSignals; i++){\n        if(isVarDims[i]){\n            logValueDimensions = true;\n            break;\n        }\n    }\n\n    /* values */\n    dimsOffset = 0;\n    for (i = 0; i < nSignals; i++) {\n        BuiltInDTypeId dt = (dTypes) ? dTypes[i] : SS_DOUBLE;\n        int_T          cs = (cSgnls) ? cSgnls[i] : 0;\n        int_T          fd = (fData)  ? fData[i]  : 0;\n        int_T          nd = (numDims) ? numDims[i] : 1;\n\n        const RTWLogDataTypeConvert *pDTConvInfoCur =\n                       (pDTConvInfo)  ? (pDTConvInfo+i)  : 0;\n\n        LogVar *values = NULL;\n        LogValDimsStat logValDimsStat;\n\n        if(!logValueDimensions){\n            logValDimsStat = NO_LOGVALDIMS;\n        }\n        else{\n            logValDimsStat = isVarDims[i] ? LOGVALDIMS_VARDIMS :  \n                                            LOGVALDIMS_EMPTYMX;\n        }\n\n        values = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                            inStepSize, errStatus,\n                                            &VALUES_FIELD_NAME,\n                                            dt, \n                                            pDTConvInfoCur,\n                                            0, cs, fd,\n                                            numCols[i],nd,\n                                            dims + dimsOffset,\n                                            logValDimsStat,\n                                            currSigDims + dimsOffset,\n                                            currSigDimsSize + dimsOffset,\n                                            maxRows,decimation,sampleTime, 0);\n\n        if (values == NULL) goto ERROR_EXIT;\n\n        if (sig->values == NULL) {\n            sig->values = values;\n        } else {\n            if (prevValues == NULL) goto ERROR_EXIT;\n            prevValues->next = values;\n        }\n        prevValues = values;\n        dimsOffset += nd;\n    }\n\n    if(logValueDimensions){\n        ++sig->numActiveFields;\n        sig->logValueDimensions = true;\n    }\n    else{\n        sig->logValueDimensions = false;\n    }\n\n    /* Dimensions */\n    {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            int_T nd = (numDims) ? numDims[i] : 1;\n            dataLen += nd;\n        }\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->dimensions = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->dimensions)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n          data[i] = dims[i]; /* cannot memcpy double <- int */\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->dimensions[i]);\n            int_T nd = (numDims) ? numDims[i] : 1;\n\n            (void)memcpy(mtxData->name, &DIMENSION_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = 1;\n            mtxData->nCols   = nd;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += nd;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* labels */\n    if (labels != NULL) {\n        unsigned short   *data;\n        size_t  nbytes;\n        int_T   dataLen    = 0;\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (labels[i] != NULL){\n                dataLen = dataLen + (int_T)strlen(labels[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->labels = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->labels)) + dataOffset);\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T labelLen = (labels[sigIdx]==NULL) ? 0 : (int_T)strlen(labels[sigIdx]);\n            for (i = 0; i < labelLen; i++) {\n                data[dataIdx++] = (uint8_T)labels[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->labels[i]);\n            int_T labelLen = (int_T)strlen(labels[i]);\n\n            (void)memcpy(mtxData->name, &LABEL_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (labelLen) ? 1 : 0;\n            mtxData->nCols   = labelLen;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += labelLen;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* plot styles */\n    if (plotStyles != NULL) {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            dataLen += numCols[i];\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->plotStyles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (real_T*) (((char_T*) (sig->plotStyles)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n            data[i] = plotStyles[i];\n        }\n\n        dimsOffset = 0;\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->plotStyles[i]);\n            \n            (void)memcpy(mtxData->name, &PLOTSTYLE_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = (numCols[i]) ? 1 : 0;\n            mtxData->nCols   = numCols[i];\n\n            mtxData->nDims   = numDims[i];\n            \n            if(mtxData->nDims > 2) {\n                if ((mtxData->dims = calloc(mtxData->nDims, sizeof(int_T))) == NULL) goto ERROR_EXIT;\n            } else {\n                mtxData->dims    = mtxData->_dims;\n            }\n            \n            mtxData->dims[0] = *(dims + dimsOffset);\n            if(mtxData->nDims >= 2) {\n                int32_T j;\n                for (j=1; j<mtxData->nDims; j++) {\n                    mtxData->dims[j] = *(dims + dimsOffset + j);\n                }\n            }\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data       += numCols[i];\n            dimsOffset += numDims[i];\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* titles */\n    if (titles != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen    = (int_T)strlen(titles);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->titles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (unsigned short*) (((char_T*) (sig->titles)) + dataOffset);\n        for (i = 0; i < dataLen; i++) {\n            data[i] = titles[i];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->titles[i]);\n\n            (void)memcpy(mtxData->name, &TITLE_FIELD_NAME, mxMAXNAM);\n            if (titleLen) {\n                mtxData->nRows   = (titleLen[i]) ? 1 : 0;\n                mtxData->nCols   = titleLen[i];\n            } else {\n                mtxData->nRows   = (dataLen) ? 1 : 0;\n                mtxData->nCols   = dataLen;\n            }\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += ((titleLen) ? titleLen[i] : dataLen);\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* block names */\n    if (blockNames != NULL)     {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (blockNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(blockNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->blockNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->blockNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (blockNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(blockNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)blockNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->blockNames[i]);\n            int_T blockNameLen = (int_T)strlen(blockNames[i]);\n\n            (void)memcpy(mtxData->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (blockNameLen) ? 1 : 0;\n            mtxData->nCols   = blockNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += blockNameLen;\n        }\n        ++sig->numActiveFields;\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    } else {\n        if(logValueDimensions){\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* state names */\n    if (stateNames != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (stateNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(stateNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->stateNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->stateNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (stateNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(stateNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)stateNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateNames[i]);\n            int_T stateNameLen = (int_T)strlen(stateNames[i]);\n\n            (void)memcpy(mtxData->name, &STATENAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (stateNameLen) ? 1 : 0;\n            mtxData->nCols   = stateNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += stateNameLen;\n        }\n        ++sig->numActiveFields;\n\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* CrossMdlRef */\n    if (crossMdlRef != NULL) {\n        real_T  *data;\n        size_t nbytes;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->crossMdlRef = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->crossMdlRef)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = crossMdlRef[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->crossMdlRef[i]);\n\n            (void)memcpy(mtxData->name, &CROSS_MDL_REF_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_DOUBLE;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(SS_DOUBLE);\n            mtxData->elSize  = sizeof(real_T);\n            mtxData->logical = matLOGICAL_BIT;\n            mtxData->complex = 0U;\n            mtxData->frameData = 0;\n            mtxData->frameSize = 1;\n        }\n        ++sig->numActiveFields;\n    }\n    \n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n\n    (void)fprintf(stderr, \"*** Error creating signals structure \"\n                  \"in the struct log variable %s\\n\", var->name);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyLogVar(sig->values);\n    FREE(sig->labels);\n    FREE(sig->plotStyles);\n    FREE(sig->dimensions);\n    FREE(sig->titles);\n    FREE(sig->blockNames);\n    FREE(sig->stateNames);\n    FREE(sig->crossMdlRef);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\n\n/* Function: local_CreateStructLogVar ==========================================\n * Abstract:\n *      Create a logging variable in the structure format.\n *\n * Returns:\n *      ~= NULL  => success, returns the log variable created.\n *      == NULL  => failure, error message set in the simstruct.\n */\nstatic StructLogVar *local_CreateStructLogVar(\n    RTWLogInfo              *li,\n    const real_T            startTime,\n    const real_T            finalTime,\n    const real_T            inStepSize,\n    const char_T            **errStatus,\n    const char_T            *varName,\n    boolean_T               logTime,\n    int_T                   maxRows,\n    int_T                   decimation,\n    real_T                  sampleTime,\n    const RTWLogSignalInfo  *sigInfo,\n    const char_T            *blockName)\n{\n    StructLogVar *var;\n    LogInfo      *logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ( (var = calloc(1, sizeof(StructLogVar))) == NULL ) goto ERROR_EXIT;\n\n    var->numActiveFields = 2;\n\n    /* Setup the structure name using varName and nameModifier */\n    rt_LoadModifiedLogVarName(li,varName,var->name);\n\n    /* time field */\n    if (logTime) {\n        /* need to create a LogVar to log time */\n        int_T dims = 1;\n        var->time = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                               inStepSize, errStatus,\n                                               &TIME_FIELD_NAME, SS_DOUBLE, \n                                               NULL,\n                                               0, 0, 0, 1,\n                                               1, &dims, NO_LOGVALDIMS, \n                                               NULL, NULL, maxRows,\n                                               decimation, sampleTime, 0);\n        if (var->time == NULL) goto ERROR_EXIT;\n    } else {\n        /* create a dummy MatrixData to write out time as an empty matrix */\n        BuiltInDTypeId dt     = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         nbytes = sizeof(MatrixData);\n        MatrixData     *time;\n\n        if ( (var->time = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n        time = var->time;\n\n        (void)memcpy(time->name, &TIME_FIELD_NAME, mxMAXNAM);\n        time->nRows   = 0;\n        time->nCols   = 0;\n        time->nDims   = 0;\n        time->re      = NULL;\n        time->im      = NULL;\n        time->dTypeID = dt;\n        time->mxID    = rt_GetMxIdFromDTypeId(dt);\n        time->elSize  = rt_GetSizeofDataType(dt);\n        time->logical = 0U;\n        time->complex = 0U;\n    }\n    var->logTime = logTime;\n\n    /* signals field */\n    if (sigInfo) {\n        if (rt_InitSignalsStruct(li,startTime,finalTime,inStepSize,errStatus,\n                                 var,maxRows,decimation,sampleTime,sigInfo)) {\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* blockName Field */\n    if (blockName != NULL) {\n        int_T  dataLen = (int_T)strlen(blockName);\n        size_t nbytes;\n        size_t dataOffset = sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (var->blockName = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        (void)memcpy(var->blockName->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n        var->blockName->nRows   = (dataLen) ? 1 : 0;\n        var->blockName->nCols   = dataLen;\n\n        var->blockName->nDims   = 1;\n        var->blockName->dims    = var->blockName->_dims;\n        var->blockName->dims[0] = dataLen;\n        {\n            /*LINTED E_BAD_PTR_CAST_ALIGN*/\n            unsigned short *data = (unsigned short*)(((char_T*) (var->blockName))+dataOffset);\n            int_T   i;\n\n            for (i=0; i<dataLen; i++) {\n                data[i] = (uint8_T)blockName[i];\n            }\n            var->blockName->re  = data;\n        }\n        var->blockName->im      = NULL;\n        var->blockName->dTypeID = SS_INT16;\n        var->blockName->mxID    = mxCHAR_CLASS;\n        var->blockName->elSize  = sizeof(short);\n        var->blockName->logical = 0U;\n        var->blockName->complex = 0U;\n\n        ++var->numActiveFields;\n    }\n\n    /* Add this struct log var to the linked list in log info */\n    {\n        StructLogVar *list = logInfo->structLogVarsList;\n\n        if (list != NULL) {\n            while (list->next != NULL) {\n                list = list->next;\n            }\n            list->next = var;\n        } else {\n            logInfo->structLogVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Error creating log variable %s\\n\", varName);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyStructLogVar(var);\n    return(NULL);\n\n} /* end local_CreateStructLogVar */\n\n\n/* Function: rt_StartDataLoggingForOutput ======================================\n * Abstract:\n */\nstatic const char_T *rt_StartDataLoggingForOutput(RTWLogInfo   *li,\n                                                  const real_T startTime,\n                                                  const real_T finalTime,\n                                                  const real_T stepSize,\n                                                  const char_T **errStatus)\n{\n    const char_T   *varName;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    LogInfo *       logInfo;\n    logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    /* outputs */\n    varName = rtliGetLogY(li);\n    if (varName[0] != '\\0') {\n        int_T                  i;\n        int_T                  ny;\n        int_T                  yIdx;\n        char_T                 name[mxMAXNAM];\n        const char_T           *cp        = strchr(varName,',');\n        LogSignalPtrsType      ySigPtrs   = rtliGetLogYSignalPtrs(li);\n        const RTWLogSignalInfo *yInfo     = rtliGetLogYSignalInfo(li);\n\n        /* count the number of variables (matrices or structures) to create */\n        for (ny=1; cp != NULL; ny++) {\n            cp = strchr(cp+1,',');\n        }\n        logInfo->ny = ny;\n\n        if (logFormat==0) {\n            if ( (logInfo->y = calloc(ny,sizeof(LogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        } else {\n            if ( (logInfo->y = calloc(ny,sizeof(StructLogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        }\n\n        for (i = yIdx = 0, cp = varName; i < ny; i++) {\n            int_T        len;\n            const char_T *cp1 = strchr(cp+1,',');\n\n            if (cp1 != NULL) {\n                /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n                len = (int_T)(cp1 - cp);\n                if (len >= mxMAXNAM) len = mxMAXNAM - 1;\n            } else {\n                len = mxMAXNAM - 1;\n            }\n            (void)strncpy(name, cp, len);\n            name[len] = '\\0';\n\n            if (ny > 1 && ySigPtrs[i] == NULL) {\n                goto NEXT_NAME;\n            }\n\n            if (logFormat == 0) {\n                int            numCols;\n                int            nDims;\n                const int      *dims;\n                BuiltInDTypeId dataType;\n                int            isComplex;\n\n                if (ny == 1) {\n                    int_T op;\n\n                    numCols = yInfo[0].numCols[0];\n                    for (op = 1; op < yInfo[0].numSignals; op++) {\n                        numCols += yInfo[0].numCols[op];\n                    }\n                    /*\n                     * If we have only one \"matrix\" outport,\n                     * we can still log it as a matrix\n                     */\n                    if (yInfo[0].numSignals == 1) {\n                        nDims = yInfo[0].numDims ? yInfo[0].numDims[0] : 1;\n                        dims  = yInfo[0].dims;\n                    } else {\n                        nDims = 1;\n                        dims  = &numCols;\n                    }\n\n                    dataType  = yInfo[0].dataTypes[0];\n                    isComplex = yInfo[0].complexSignals[0];\n                } else {\n                    numCols   = yInfo[yIdx].numCols[0];\n                    nDims     = yInfo[yIdx].numDims ? yInfo[yIdx].numDims[0] : 1;\n                    dims      = yInfo[yIdx].dims;\n                    dataType  = yInfo[yIdx].dataTypes[0];\n                    isComplex = yInfo[yIdx].complexSignals[0];\n                }\n\n                logInfo->y[yIdx] = rt_CreateLogVarWithConvert(\n                    li, startTime, finalTime,\n                    stepSize, errStatus,\n                    name,\n                    dataType,\n                    yInfo[yIdx].dataTypeConvert,\n                    0,isComplex,\n                    0,numCols,nDims,dims,\n                    NO_LOGVALDIMS, NULL, NULL,\n                    maxRows,decimation,\n                    sampleTime,1);\n                if (logInfo->y[yIdx] == NULL)  goto ERROR_EXIT;\n            } else {\n                logInfo->y[yIdx] = local_CreateStructLogVar(li, startTime,\n                                                            finalTime, stepSize,\n                                                            errStatus, name,\n                                                            logTime, maxRows,\n                                                            decimation, sampleTime,\n                                                            &yInfo[yIdx], NULL);\n                if (logInfo->y[yIdx] == NULL) goto ERROR_EXIT;\n            }\n            ++yIdx;\n        NEXT_NAME:\n            cp = cp1;\n            if (cp != NULL && *cp == ',') cp++;\n        }\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) { /* polyspace DEFECT:USELESS_IF [No action planned:Unset] \n                     \"Defense coding.\" */\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingForOutput */\n\n\n/* Function: rt_ReallocLogVar ==================================================\n * Abstract:\n *   Allocate more memory for the data buffers in the log variable.\n *   Exit if unable to allocate more memory.\n */\nstatic void rt_ReallocLogVar(LogVar *var, boolean_T isVarDims)\n{\n    void *tmp;\n    int_T nCols = var->data.nCols;\n    int_T nRows;\n    size_t elSize = var->data.elSize;\n\n    if (isVarDims)\n    {\n        nRows = var->data.nRows + DEFAULT_BUFFER_SIZE;\n    }\n    else\n    {\n        nRows = var->data.nRows == 0 ? 1 : 2*var->data.nRows;\n    }\n    \n    tmp = realloc(var->data.re, nRows*nCols*elSize);\n    if (tmp == NULL) {\n        (void)fprintf(stderr,\n                      \"*** Memory allocation error.\\n\");\n        (void)fprintf(stderr, \"\"\n                      \"    varName          = %s%s\\n\"\n                      \"    nRows            = %d\\n\"\n                      \"    nCols            = %d\\n\"\n                      \"    elementSize      = %lu\\n\"\n                      \"    Current Size     = %.16g\\n\"\n                      \"    Failed resize    = %.16g\\n\\n\",\n                      var->data.name,\n                      var->data.complex ? \" (real part)\" : \"\",\n                      var->data.nRows,\n                      var->data.nCols,\n                      (unsigned long)  var->data.elSize,\n                      (double)nRows*nCols*elSize,\n                      (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n        exit(1);\n    }\n    var->data.re = tmp;\n\n    if (var->data.complex) {\n        tmp = realloc(var->data.im, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s (complex part)\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->data.name,\n                          var->data.nRows,\n                          var->data.nCols,\n                          (unsigned long)  var->data.elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n        var->data.im = tmp;\n    }\n    var->data.nRows = nRows;\n\n    /* Also reallocate memory for \"valueDimensions\" \n       when logging the variable-size signal\n    */\n    if(isVarDims){\n        int_T k;\n        \n        nCols = var->valDims->nCols;\n        nRows = var->valDims->nRows + DEFAULT_BUFFER_SIZE;\n        elSize = sizeof(real_T);\n        tmp = realloc(var->valDims->dimsData, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->valDims->name,\n                          var->valDims->nRows,\n                          var->valDims->nCols,\n                          (unsigned long)  elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n\n        /*\n         * valueDimensions data is stored in array format and must be\n         * adjusted after reallocation (see also rt_FixupLogVar())\n         *\n         * Example: maxRows = 4; nRows = 4; nDims = 3;\n         * Before realloc of the logVar, the locations of data are as below:\n         * (x, y, z -- useful data / o -- junk, don't care)\n         * a[0] = x    a[4] = y    a[8] = z\n         * a[1] = x    a[5] = y    a[9] = z\n         * a[2] = x    a[6] = y    a[10]= z\n         * a[3] = x    a[7] = y    a[11]= z\n         *\n         * After realloc of the logVar (suppose 2 extra rows are added),\n         * the locations of data are as below:\n         * a[0] = x    a[6] = y    a[12]= o\n         * a[1] = x    a[7] = y    a[13]= o\n         * a[2] = x    a[8] = z    a[14]= o\n         * a[3] = x    a[9] = z    a[15]= o\n         * a[4] = y    a[10]= z    a[16]= o\n         * a[5] = y    a[11]= z    a[17]= o\n         *\n         * The data must be adjusted as below:\n         * a[0] = x    a[6] = y    a[12]= z\n         * a[1] = x    a[7] = y    a[13]= z\n         * a[2] = x    a[8] = y    a[14]= z\n         * a[3] = x    a[9] = y    a[15]= z\n         * a[4] = o    a[10]= o    a[16]= o\n         * a[5] = o    a[11]= o    a[17]= o\n         */\n        for(k = var->data.nDims-1; k > 0; k--){\n            (void) memcpy((real_T*)tmp + k*nRows, \n                          (real_T*)tmp + k*var->valDims->nRows,\n                          elSize * var->valDims->nRows);\n        }\n\n        var->valDims->dimsData = tmp;\n        var->valDims->nRows = nRows;\n    }\n\n} /* end rt_ReallocLogVar */\n\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs);\n                                             \n/* Function: rt_UpdateLogVarWithDiscontinuousData ==============================\n * Abstract:\n *      Log one row of the LogVar with data that is not contiguous.\n */\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs)\n{\n    size_t elSize = 0;\n    size_t offset = 0;\n    int    segIdx = 0;\n\n    if (++var->numHits % var->decimation) return(NULL);\n    var->numHits = 0;\n\n    /*\n     * Reallocate or wrap the LogVar\n     */\n    if (var->rowIdx == var->data.nRows) {\n        if (var->okayToRealloc == 1) {\n            rt_ReallocLogVar(var, false);\n        } else {\n            /* Circular buffer */\n            var->rowIdx = 0;\n            ++(var->wrapped); /* increment the wrap around counter */\n        }\n    }\n\n    /* This function is only used to log states, there's no var-dims issue. */\n    elSize = var->data.elSize;\n    offset = (size_t)(elSize * var->rowIdx * var->data.nCols);\n\n    if (var->data.complex) {\n        char_T *dstRe = (char_T*)(var->data.re) + offset;\n        char_T *dstIm = (char_T*)(var->data.im) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            int_T         nEl  = segmentLengths[segIdx];\n            char_T *src        = (char_T *)data[segIdx];\n            int_T         el;\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(elSize * nEl * 2);\n                preprocessingPtr(src, (void *)data[segIdx]);\n            }\n\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);\n            }\n            else {\n                for (el = 0; el < nEl; el++) {\n                    (void)memcpy(dstRe, src, elSize);\n                    dstRe += elSize;   src += elSize;\n                    (void)memcpy(dstIm, src, elSize);\n                    dstIm += elSize;   src += elSize;\n                }\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    } else {\n        char_T *dst = (char_T*)(var->data.re) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            size_t      segSize = elSize*segmentLengths[segIdx];\n            char_T *src         = (void *) data[segIdx];\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(segSize);\n                preprocessingPtr(src, data[segIdx]);\n            }\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);            }\n            else {\n                (void)memcpy(dst, src, segSize);\n                dst += segSize;\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    }\n\n    ++var->rowIdx;\n    return(NULL);\n\n} /* end rt_UpdateLogVarWithDiscontinuousData */\n\n\n/*==================*\n * Visible routines *\n *==================*/\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_CreateLogVarWithConvert ========================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList)\n{\n    int_T          usingDefaultBufSize = 0;\n#ifdef NO_LOGGING_REALLOC\n    int_T          okayToRealloc       = 0;\n#else\n    int_T          okayToRealloc       = 1;\n#endif\n    LogVar         *var                = NULL;\n    /*inpDataTypeID is the rt_LoggedOutputDataTypeId*/\n    BuiltInDTypeId dTypeID             = (BuiltInDTypeId)inpDataTypeID; \n    size_t         elementSize         = rt_GetSizeofDataType(dTypeID);\n    int_T          frameSize;\n    int_T          nRows;\n    int_T          nColumns;\n\n    /*===================================================================*\n     * Determine the frame size if the data is frame based               *\n     *===================================================================*/\n    frameSize = frameData ? dims[0] : 1;\n\n    /*===================================================================*\n     * Calculate maximum number of rows needed in the buffer             *\n     *===================================================================*/\n\n    if (finalTime > startTime && finalTime != rtInf) {\n        real_T nPoints;            /* Tfinal is finite  ===>  nRows can be  */\n        real_T stepSize;           /* computed since the StepSize is fixed  */\n\n        if (sampleTime == -2.0) {  /* The signal being logged is constant,  *\n                                    * Hence, only one data point is logged. */\n            stepSize = finalTime;\n        } else if (sampleTime == -1.0 || sampleTime == 0.0) {\n                                /* Signal being logged is either inside a    *\n                                 * triggered sub-system or it is continuous. */\n            stepSize = inStepSize;\n        } else {                /* Discrete signal */\n            stepSize = sampleTime;\n        }\n\n        if (stepSize == 0.0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {\n            nPoints = 1.0 + floor((finalTime-startTime)/stepSize);\n\n            /*\n             * Add one more data point if needed.\n             */\n            if ( stepSize*(nPoints-1.0) < (finalTime-startTime) ) {\n                nPoints += 1.0;\n            }\n\n            /*\n             * Actual number of points to log = nPoints * size of\n             * each frame if data is frame-based\n             */\n            nPoints = frameData ? (nPoints * frameSize) : nPoints;\n\n            nPoints /= decimation;\n            if (nPoints != floor(nPoints)) {\n                nPoints += 1.0;\n            }\n            nRows = (nPoints <= INT_MAX) ? ((int_T) nPoints) : INT_MAX;\n        }\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (finalTime == startTime) {\n        /*\n         * Number of rows to log is equal to 1 if not frame-based and\n         * equal to frame size if frame-based\n         */\n        nRows = frameData ? frameSize : 1;\n\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (maxRows > 0) {     /* maxRows is specified => nRows=maxRows  */\n        nRows = maxRows;\n        okayToRealloc = 0;\n    } else {\n\n        if (inStepSize == 0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {                    /* Use a default value for nRows          */\n            usingDefaultBufSize = 1;\n            nRows = DEFAULT_BUFFER_SIZE;\n            okayToRealloc = 0;  /* No realloc with infinite stop time */\n            (void)fprintf(stdout, \"*** Using a default buffer of size %d for \"\n                          \"logging variable %s\\n\", nRows, varName);\n        }\n    }\n\n    /*\n     * Figure out the number of columns that the log variable should have.\n     * If the data is not frame based, then number of columns should equal\n     * nCols that is provided as input to the function. If the data is\n     * frame-based, then the number of columns should be equal to the\n     * number of channels = nCols/frameSize = dims[1];\n     */\n    nColumns = frameData ? dims[1] : nCols;\n\n    /*\n     * Error out if the size of the circular buffer is absurdly large, this\n     * error message is more informative than the one we get when we try to\n     * malloc this many number of bytes in one fell swoop.\n     */\n    {\n        double tmpDbl = ((double)elementSize)*((double)nRows)*\n                                              ((double)nColumns);\n\n        if (tmpDbl >= UINT_MAX) {\n            (void)fprintf(stderr,\n                          \"\\n*** Memory required to log variable '%s' is too\"\n                          \"\\n    big. Use the 'Limit rows to last:' and (or)\"\n                          \"\\n    'Decimation:' options to reduce the required\"\n                          \"\\n    memory size.\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Required  = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long)\n                          elementSize, tmpDbl);\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* Allocate memory for the log variable */\n    if ( (var = calloc(1, sizeof(LogVar))) == NULL ) {\n        (void)fprintf(stderr, \"*** Error allocating memory for logging %s\\n\",\n                      varName);\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer (real part) */\n    if ( (var->data.re = malloc(nRows*nColumns*elementSize)) == NULL ) {\n        (void)fprintf(stderr,\n                      \"*** Error allocating memory for the circular buffer\\n\");\n        (void)fprintf(stderr, \"*** Details:\\n\"\n                      \"       varName         = %s\\n\"\n                      \"       nRows           = %d\\n\"\n                      \"       nCols           = %d\\n\"\n                      \"       elementSize     = %lu\\n\"\n                      \"       Bytes Requested = %.16g\\n\\n\",\n                      varName, nRows, nColumns, (unsigned long) elementSize,\n                      ((double)elementSize)*((double)nRows)*((double)nColumns));\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer for the imaginary part */\n    if (complex) {\n        if ( (var->data.im = malloc(nRows*nColumns*elementSize)) == NULL ) {\n            (void)fprintf(stderr,\n                          \"*** Error allocating memory for the circular buffer \"\n                          \"for logging the imaginary part of %s\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Requested = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long) elementSize,\n                          ((double)elementSize)*((double)nRows)*\n                                                 ((double)nColumns));\n            goto ERROR_EXIT;\n        }\n    }\n    /*\n     * Initialize the fields in LogVar structure.\n     */\n    if (appendToLogVarsList) {\n        rt_LoadModifiedLogVarName(li,varName,var->data.name);\n    } else {\n        var->data.name[mxMAXNAM-1] = '\\0';\n        (void)strncpy(var->data.name,varName,mxMAXNAM-1);\n    }\n    var->data.nCols           = nColumns;\n    var->data.nRows           = nRows;\n\n    var->data.nDims           = frameData ? 1 : nDims;\n    if (var->data.nDims > 2) {\n        var->data.dims = (int_T*)malloc(sizeof(int_T)*var->data.nDims);\n    } else {\n        var->data.dims = var->data._dims;\n    }\n    if (frameData) {\n        var->data.dims[0] = nColumns;\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        (void)memcpy(var->data.dims, dims, (size_t)(nDims*sizeof(int_T)));\n    }\n\n    var->data.dTypeID         = dTypeID;\n    var->data.elSize          = elementSize;\n\n    var->data.dataTypeConvertInfo = rt_GetDataTypeConvertInfo(\n        pDataTypeConvertInfo, dTypeID);\n\n    var->data.mxID            = rt_GetMxIdFromDTypeId(dTypeID);\n    /* over-ride logical bit if data type is boolean */\n    logical = dTypeID == SS_BOOLEAN ? 1 : 0;\n    var->data.logical         = (logical)   ? matLOGICAL_BIT : 0x0;\n    var->data.complex         = (complex)   ? matCOMPLEX_BIT : 0x0;\n    var->data.frameData       = frameData;\n    var->data.frameSize       = (frameData) ? frameSize : 1;\n\n    /* fill up valDims field */\n    if(logValDimsStat == NO_LOGVALDIMS){\n        /* All signals are fixed-size, no need to log valueDimensions field */\n        var->valDims     = NULL;\n        /* Set these pointers to NULLs in this case */\n        var->coords      = NULL;\n        var->strides     = NULL;\n        var->currStrides = NULL;\n    }\n    else{\n        if ( (var->valDims = calloc(1, sizeof(ValDimsData))) == NULL ) {\n            goto ERROR_EXIT;\n        }\n\n        (void)memcpy(var->valDims->name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n\n        if (logValDimsStat == LOGVALDIMS_EMPTYMX) {\n            /* At least one signal is variable-size, \n               but the current signal is fixed-size. \n               Therefore, create a dummy MatrixData to write out valueDimensions \n               as an empty matrix. \n            */\n            var->valDims->nRows = 0;\n            var->valDims->nCols = 0;\n            var->valDims->currSigDims = NULL;\n            var->valDims->currSigDimsSize = NULL;\n            var->valDims->dimsData = NULL;\n            /* Set these pointers to NULLs in this case */\n            var->coords      = NULL;\n            var->strides     = NULL;\n            var->currStrides = NULL;\n        } else { /* The current signal is a variable-size signal. */\n            /* The \"valueDimensions\" must be double, so re-assign element size */\n            elementSize = sizeof(real_T);\n\n            /* When signals are frame-based, 'valueDimensions' has 1 column */\n            if(frameData){\n                /* When signal is frame-based, the first dimension is always fixed, \n                   so we only need to record the second dimension.\n                   e.g. Two frame-based signals [10x4] and [10x3], \n                   'valueDimensions' and 'currSigDims'\n                   only record 4 or 3.\n                */\n                nColumns = 1;\n                var->valDims->currSigDims = (void**) (currSigDims + 1);\n                var->valDims->currSigDimsSize = (int_T*) (currSigDimsSize + 1);\n            } else { /* non-frame based */\n                nColumns = nDims;\n                var->valDims->currSigDims = (void**) currSigDims;\n                var->valDims->currSigDimsSize = (int_T*) currSigDimsSize;\n            }\n            \n            /* Allocate memory for the circular buffer */\n            if ( (var->valDims->dimsData = malloc(nRows*nColumns*elementSize)) == NULL ) {\n                (void)fprintf(stderr,\n                              \"*** Error allocating memory for the circular buffer\\n\");\n                (void)fprintf(stderr, \"*** Details:\\n\"\n                              \"       varName         = %s\\n\"\n                              \"       nRows           = %d\\n\"\n                              \"       nCols           = %d\\n\"\n                              \"       elementSize     = %lu\\n\"\n                              \"       Bytes Requested = %.16g\\n\\n\",\n                              var->valDims->name, nRows, nColumns, (unsigned long) elementSize,\n                              ((double)elementSize)*((double)nRows)*((double)nColumns));\n                goto ERROR_EXIT;\n            }\n            var->valDims->nRows = nRows;\n            var->valDims->nCols = nColumns;\n\n            /* Allocate memory for these dynamic arrays */\n            {\n                size_t nbytes = var->data.nDims*sizeof(int_T);\n                if( ((var->coords = calloc(nbytes, 1)) == NULL)\n                    ||((var->strides = calloc(nbytes, 1)) == NULL)\n                    ||((var->currStrides = calloc(nbytes, 1)) == NULL) )\n                    goto ERROR_EXIT;\n            }\n        }\n    }\n\n    var->rowIdx               = 0;\n    var->wrapped              = 0;\n    var->nDataPoints          = 0;\n    var->usingDefaultBufSize  = usingDefaultBufSize;\n    var->okayToRealloc        = okayToRealloc;\n    var->decimation           = decimation;\n    var->numHits              = -1;  /* so first point gets logged */\n\n    /* Add this log var to list in log info, if necessary */\n    if (appendToLogVarsList) {\n        LogInfo *logInfo = (LogInfo*) rtliGetLogInfo(li);\n        LogVar  *varList = logInfo->logVarsList;\n\n        if (varList != NULL) {\n            while (varList->next != NULL) {\n                varList = varList->next;\n            }\n            varList->next = var;\n        } else {\n            logInfo->logVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    \n    *errStatus = rtMemAllocError;\n    rt_DestroyLogVar(var);\n    return(NULL);\n\n} /* end rt_CreateLogVarWithConvert */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVar ===================================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList)\n{\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo = NULL;\n\n    return rt_CreateLogVarWithConvert(li,\n                                      startTime,\n                                      finalTime,\n                                      inStepSize,\n                                      errStatus,\n                                      varName,\n                                      inpDataTypeID,\n                                      pDataTypeConvertInfo,\n                                      logical,\n                                      complex,\n                                      frameData,\n                                      nCols,\n                                      nDims,\n                                      dims,\n                                      logValDimsStat,\n                                      currSigDims,\n                                      currSigDimsSize,\n                                      maxRows,\n                                      decimation,\n                                      sampleTime,\n                                      appendToLogVarsList);\n\n} /* end rt_CreateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateStructLogVar =============================================\n * Abstract:\n *\tCreate a logging variable in the structure format.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nStructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName)\n{\n\n    return( local_CreateStructLogVar(li,\n                                     startTime,\n                                     finalTime,\n                                     inStepSize,\n                                     errStatus,\n                                     varName,\n                                     logTime,\n                                     maxRows,\n                                     decimation,\n                                     sampleTime,\n                                     sigInfo,\n                                     blockName));\n\n} /* end rt_CreateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_StartDataLoggingWithStartTime ==================================\n * Abstract:\n *      Initialize data logging info based upon the following settings cached\n *      in the RTWLogging data structure of the SimStruct.\n *\n * Return value is:\n *\t== NULL  => success\n *\t!= NULL  => failure (the return value is a pointer that points to the\n *                           error message, which is also set in the simstruct)\n */\nconst char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus)\n{\n    const char_T   *varName;\n    LogInfo        *logInfo;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ((logInfo=calloc(1,sizeof(LogInfo))) == NULL) {\n        *errStatus = rtMemAllocError;\n        goto ERROR_EXIT;\n    }\n    rtliSetLogInfo(li, (void*)logInfo);\n\n    /* time */\n    varName = rtliGetLogT(li);\n    if (varName[0] != '\\0') {\n        int_T dims = 1;\n        logInfo->t = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                stepSize, errStatus,\n                                                varName,SS_DOUBLE,\n                                                NULL,\n                                                0,0,0,1,1,\n                                                &dims, NO_LOGVALDIMS, NULL, NULL,\n                                                maxRows,decimation,\n                                                sampleTime,1);\n        if (logInfo->t == NULL) goto ERROR_EXIT;\n    }\n\n    /* states */\n    if ( rtliGetLogX(li)[0] != '\\0' ||  rtliGetLogXFinal(li)[0] != '\\0' ) {\n        const RTWLogSignalInfo  *xInfo = rtliGetLogXSignalInfo(li);\n\n        if (logFormat == 0) {                                /* Matrix Format */\n            int            numCols;\n            int            nDims;\n            const int      *dims;\n            BuiltInDTypeId dataType;\n            int            isComplex;\n            int_T          sIdx;\n\n            const RTWLogDataTypeConvert *pDTConvInfo;\n\n            numCols = xInfo[0].numCols ? xInfo[0].numCols[0] : 0;\n            for (sIdx = 1; sIdx < xInfo[0].numSignals; sIdx++) {\n                numCols += xInfo[0].numCols[sIdx];\n            }\n            /* If we have only one \"matrix\" state, we can log as a matrix */\n            if (xInfo[0].numSignals == 1) {\n                nDims     = xInfo[0].numDims ? xInfo[0].numDims[0] : 1;\n                dims      = xInfo[0].dims;\n            } else {\n                nDims     = 1;\n                dims      = &numCols;\n            }\n            dataType  = xInfo[0].dataTypes ? xInfo[0].dataTypes[0] : 0;\n            isComplex = xInfo[0].complexSignals ? xInfo[0].complexSignals[0] : 0;\n\n            pDTConvInfo = xInfo[0].dataTypeConvert;\n\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                        stepSize, errStatus,\n                                                        rtliGetLogX(li),dataType,\n                                                        pDTConvInfo,\n                                                        0,\n                                                        isComplex,0,numCols,nDims,dims,\n                                                        NO_LOGVALDIMS, NULL, NULL,\n                                                        maxRows,decimation,sampleTime,1);\n                if (logInfo->x == NULL)  goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                             stepSize, errStatus,\n                                                             rtliGetLogXFinal(li),dataType,\n                                                             pDTConvInfo,\n                                                             0,isComplex,0,numCols,nDims,\n                                                             dims, NO_LOGVALDIMS, NULL, \n                                                             NULL, 1,decimation,\n                                                             sampleTime,1);\n                if (logInfo->xFinal == NULL)  goto ERROR_EXIT;\n            }\n        } else {                                          /* Structure Format */\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = local_CreateStructLogVar(li, startTime, finalTime,\n                                                      stepSize, errStatus,\n                                                      rtliGetLogX(li), logTime,\n                                                      maxRows, decimation,\n                                                      sampleTime, xInfo, NULL);\n                if (logInfo->x == NULL) goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = local_CreateStructLogVar(li, startTime, finalTime,\n                                                           stepSize, errStatus,\n                                                           rtliGetLogXFinal(li),\n                                                           logTime,1,decimation,\n                                                           sampleTime,xInfo,NULL);\n                if (logInfo->xFinal == NULL) goto ERROR_EXIT;\n            }\n        }\n    }\n\n    /* outputs */\n    *errStatus = rt_StartDataLoggingForOutput(li,startTime,finalTime,\n                                              stepSize,errStatus);\n    if (*errStatus != NULL)  goto ERROR_EXIT;\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingWithStartTime */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLogging ===============================================\n * Abstract:\n */\nconst char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus)\n{\n    return rt_StartDataLoggingWithStartTime(li,\n                                            0.0,\n                                            finalTime,\n                                            stepSize,\n                                            errStatus);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_UpdateLogVar ===================================================\n * Abstract:\n *\tCalled to log data for a log variable.\n */\nvoid rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims)\n{\n    size_t        elSize    = var->data.elSize;\n    const  char_T *cData    = data;\n    const  int_T  frameData = var->data.frameData;\n    const  int_T  frameSize = frameData ? (var->data.frameSize) : 1;\n    const  int_T  logWidth  = var->data.nCols;\n    BuiltInDTypeId dTypeID  = var->data.dTypeID;\n\n    size_t offset        = 0;\n    char_T *currRealRow  = NULL;\n    char_T *currImagRow  = NULL;\n    int_T  pointSize     = (int_T)((var->data.complex) ? rt_GetSizeofComplexType(dTypeID) : elSize);\n\n    int    i, j, k;\n\n    /* The following variables will be used for \n       logging variable-size signals */\n    const  int_T  nDims = var->data.nDims;\n    const  int_T  *dims = var->data.dims;\n    const  void   * const *currDimsPtr = NULL;\n    const  int_T  *currDimsSizePtr = NULL;\n\n    /* The following variables will be used for \n       logging \"valueDimensions\" field */\n    size_t offset_valDims   = 0;\n    char_T *currValDimsRow  = NULL;\n    size_t elSize_valDims   = sizeof(real_T);\n    real_T currentSigDims   = 0;\n    int_T  nRows_valDims    = 0;\n    int_T  logWidth_valDims = 0;\n\n    for (i = 0; i < frameSize; i++) {\n        if (++var->numHits % var->decimation) continue;\n        var->numHits = 0;\n\n        if (var->rowIdx == var->data.nRows) {\n            if (var->okayToRealloc == 1) {\n                rt_ReallocLogVar(var, isVarDims);\n            } else {\n                /* Circular buffer */\n                var->rowIdx = 0;\n                ++(var->wrapped); /* increment the wrap around counter */\n            }\n        }\n\n        if(isVarDims){\n            currDimsPtr = (const void * const *) var->valDims->currSigDims;\n            currDimsSizePtr = (const int_T*) var->valDims->currSigDimsSize;\n            logWidth_valDims = frameData ? 1 : var->valDims->nCols;\n            nRows_valDims = var->valDims->nRows;\n\n            var->strides[0] = 1;\n            var->currStrides[0] = 1;\n\n            for (k = 1; k < nDims; k++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[k-1]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                }\n                var->strides[k] = var->strides[k-1] * dims[k-1];\n                var->currStrides[k] = var->currStrides[k-1] * currDimsVal;\n            }\n        }\n\n        offset       = (size_t)(elSize * var->rowIdx * logWidth);\n        currRealRow  = ((char_T*) (var->data.re)) + offset;\n        currImagRow  = (var->data.complex) ?\n                       ((char_T*) (var->data.im)) + offset :  NULL;\n\n        /* update logging data */\n        for (j = 0; j < logWidth; j++) {\n\n            boolean_T inRange = true;\n            int idx = j;\n\n            /* Check whether the currently logged value is in range or not.\n               For fixed-size signal logging, always inRange = true; idx = j;\n               For variable-size signal logging, use strides, coordinates\n               and current strides to decide whether the currently logged\n               data is in range or not and its location in the logging \n               matrix.\n             */\n            if(isVarDims){\n                int rem = j;\n                idx = 0;\n                for(k = nDims-1; k>=0; k--){\n                    int32_T currDimsVal=0;\n                    switch (currDimsSizePtr[k]) {\n                      case 1:\n                        currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+k));\n                        break;\n                      case 2:\n                        currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+k));\n                        break;\n                      case 4:\n                        currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+k));\n                        break;\n                    }\n                    var->coords[k] = rem / var->strides[k];\n                    if( var->coords[k] >= currDimsVal ){\n                        inRange = false;\n                        break;\n                    }\n                    rem = rem - var->coords[k] * var->strides[k];\n                }\n                if(inRange){\n                    idx = var->coords[0];\n                    for (k = 1; k < nDims; k++){\n                        idx += var->coords[k] * var->currStrides[k];\n                    }\n                }\n            }\n            \n            if (!var->data.dataTypeConvertInfo.conversionNeeded) {\n                /* NO  conversion needed\n                 */ \n                if (inRange) {\n                    /* If in range, fill in data */\n                    const char *cDataPoint = cData + (i+frameSize*idx) * pointSize;\n\n                    (void) memcpy(currRealRow, cDataPoint, elSize);\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        (void) memcpy(currImagRow, cDataPoint + pointSize/2, elSize);\n                        currImagRow += elSize;\n                    }\n                } else {\n                    /* If out of range, fill in NaN or 0:\n                       1) For bool, int32, uint32, int16, uint16, etc,\n                          memset to zeros;\n                       2) For fixed-point data type, NaN conversion is not\n                          allowed, memset to zeros.\n                    */\n                    if (dTypeID == SS_DOUBLE) {\n                       (void) memcpy(currRealRow, &rtNaN, elSize);\n                    } else if (dTypeID == SS_SINGLE){\n                        (void) memcpy(currRealRow, &rtNaNF, elSize);\n                    } else {\n                        (void) memset(currRealRow, 0, elSize);\n                    }\n                    \n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        /* For imaginary part, fill in 0 */\n                        (void) memset(currImagRow, 0, elSize);\n                        currImagRow += elSize;\n                    }\n                }\n            }\n            else\n            {\n                /* YES conversion needed\n                 */ \n                DTypeId dataTypeIdOriginal = \n                    var->data.dataTypeConvertInfo.dataTypeIdOriginal;\n                int_T DpSize = (int_T)((var->data.complex) ? \n                                       rt_GetSizeofComplexType(dataTypeIdOriginal) : \n                                       rt_GetSizeofDataType(dataTypeIdOriginal));\n\n                DTypeId dataTypeIdLoggingTo = \n                    var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;\n\n                int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;\n                int numOfChunk =  var->data.dataTypeConvertInfo.numOfChunk;\n                unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;\n\n                double fracSlope = var->data.dataTypeConvertInfo.fracSlope;\n                int    fixedExp  = var->data.dataTypeConvertInfo.fixedExp;\n                double bias      = var->data.dataTypeConvertInfo.bias;\n\n                double curRealValue = -0.12345678987654;\n                double curImagValue = -0.12345678987654;\n\n                int_T adjIndexIfComplex = (var->data.complex) ? 2 : 1;\n\n                if(inRange){\n                    if(numOfChunk > 1)\n                    {\n                        /* For multiword */\n                        const char *pInData = (const char *)(cData);\n                        int dtSize = bitsPerChunk*numOfChunk/8;\n                        pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                        \n                        curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                       isSigned, fracSlope, fixedExp, bias);\n                        if (var->data.complex) {\n                            curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                           isSigned, fracSlope, fixedExp, bias);\n                        }\n                    }\n                    else\n                    {\n                        /* if in range, fill in data that is converted first */\n                        switch ( dataTypeIdOriginal )\n                        {\n                          case SS_DOUBLE:\n                            {\n                                const real_T *pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_SINGLE:\n                            {\n                                const real32_T *pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT8:\n                            {\n                                const int8_T *pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT8:\n                            {\n                                const uint8_T *pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT16:\n                            {\n                                const int16_T *pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT16:\n                            {\n                                const uint16_T *pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT32:\n                            {\n                                const int32_T *pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT32:\n                            {\n                                const uint32_T *pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_BOOLEAN:\n                            {\n                                const boolean_T *pInData = ((const boolean_T *)(cData));\n                                \n                                pInData += (i+frameSize*idx) * adjIndexIfComplex;\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          default: \n                            {\n                                /* For biglong */\n                                const char *pInData = (const char *)(cData);\n                                int dtSize = bitsPerChunk*numOfChunk/8;\n                                pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                                \n                                curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                               isSigned, fracSlope, fixedExp, bias);\n                                if (var->data.complex) {\n                                    curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                                   isSigned, fracSlope, fixedExp, bias);\n                                }\n                            }\n                            break;\n                        } /* -- end of switch -- */\n                    }\n                } else {\n                    /* if out of range, just fill NaN or 0 */\n                    if(dTypeID == SS_DOUBLE || dTypeID == SS_SINGLE){\n                        /* vijay 4/11/2013: DO NOT CALL ldexp() with NaN below as it causes \n                         * lcc-win64 to generate inf instead of NaN as output. \n                         * Just use rtNaN directly */\n                        curRealValue = rtNaN;\n                    }\n                    else{\n                        curRealValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                    if (var->data.complex) {\n                        /* fill 0 in imaginary part*/\n                        curImagValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                }\n\n                switch ( dataTypeIdLoggingTo )\n                {\n                  case SS_DOUBLE:\n                    {\n                        *((real_T *)currRealRow) = (real_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real_T *)currImagRow) = (real_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_SINGLE:\n                    {\n                        *((real32_T *)currRealRow) = (real32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real32_T *)currImagRow) = (real32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT8:\n                    {\n                        *((int8_T *)currRealRow) = (int8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int8_T *)currImagRow) = (int8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT8:\n                    {\n                        *((uint8_T *)currRealRow) = (uint8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint8_T *)currImagRow) = (uint8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT16:\n                    {\n                        *((int16_T *)currRealRow) = (int16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int16_T *)currImagRow) = (int16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT16:\n                    {\n                        *((uint16_T *)currRealRow) = (uint16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint16_T *)currImagRow) = (uint16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT32:\n                    {\n                        *((int32_T *)currRealRow) = (int32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int32_T *)currImagRow) = (int32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT32:\n                    {\n                        *((uint32_T *)currRealRow) = (uint32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint32_T *)currImagRow) = (uint32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_BOOLEAN:\n                    {\n                        *((boolean_T *)currRealRow) = (boolean_T)(curRealValue != 0.0);\n\n                        if (var->data.complex) {\n\n                            *((boolean_T *)currImagRow) = (boolean_T)(curImagValue != 0.0);\n                        }\n                    }\n                    break;\n                } /* -- end of switch -- */\n\n                currRealRow += elSize;\n                if (var->data.complex) {\n                    currImagRow += elSize;\n                }\n            }\n        }\n\n        if(isVarDims){ /* update \"valueDimensions\" field */\n            for(j = 0; j < logWidth_valDims; j ++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[j]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+j));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+j));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+j));\n                    break;\n                }\n                offset_valDims  = (size_t)(elSize_valDims *( var->rowIdx + nRows_valDims * j));\n                currValDimsRow  = ((char_T*) (var->valDims->dimsData)) + offset_valDims;\n\n                /* convert int_T to real_T */\n                currentSigDims = (real_T) currDimsVal;\n                (void) memcpy(currValDimsRow, &currentSigDims, elSize_valDims);\n                currValDimsRow += elSize_valDims;\n            }\n        }\n        \n        ++var->rowIdx;\n    }\n\n    return;\n\n} /* end rt_UpdateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n \n \n/* Function: rt_UpdateStructLogVar =============================================\n * Abstract:\n *      Called to log data for a structure log variable.\n */\nvoid rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data)\n{\n    LogVar       *values = var->signals.values;\n    const char_T *signal = data;\n    boolean_T *isVarDims = var->signals.isVarDims;\n    int i = 0;\n\n    /* time */\n    if (var->logTime) {\n        rt_UpdateLogVar(var->time, t, false);\n    }\n\n    /* signals */\n    while (values) {\n        size_t elSz = values->data.elSize;\n\n        rt_UpdateLogVar(values, signal, isVarDims[i]);\n\n        if (values->data.complex) elSz *= 2;\n        signal += elSz * values->data.nCols;\n\n        values = values->next;\n        i++;\n    }\n\n} /* end rt_UpdateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * g1614989:Refactoring this function to accept number of elements\n *          instead of accepting signalInfo and index.\n */\nvoid* rt_getTempMemory(LogVar* var, int_T numEls);\n\nvoid* rt_getTempMemory(LogVar* var, int_T numEls)\n{\n    size_t elSize  = var->data.elSize;\n    size_t cmplxMult = var->data.complex ? 2 : 1;\n    /*\n     * g1689750: With multiword support for mat file logging in row major array layout, we need to allocate more space to\n     * store the data when the transpose operation is being performed. The additional space is required to store multiple\n     * chunks that each multi word contains.\n     */\n    size_t numOfChunks = var->data.dataTypeConvertInfo.conversionNeeded ? var->data.dataTypeConvertInfo.numOfChunk : 1;\n    void* tempMemory = malloc(elSize * numEls * cmplxMult * numOfChunks);\n    return tempMemory;\n}\n\n/*\n* g1614989:This function processes the signal data if a function pointer is available and then logs the data.\n*          If a function pointer is not present, signal data is logged without any processing.\n*          The idx parameter specifies which information from the SignalInfo to be used for processing and logging.\n*          When idx is -1, the provided signal info is to be used for processing and logging the data.\n*/\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    RTWPreprocessingFcnPtr preprocessingPtr = NULL;\n    int_T numEls = -1;\n    if (idx == -1) {\n        preprocessingPtr = *(signalInfo->preprocessingPtrs);\n        numEls = *(signalInfo->numCols);\n    }\n    else {\n        preprocessingPtr = signalInfo->preprocessingPtrs[idx];\n        numEls = signalInfo->numCols[idx];\n    }\n\n    if (preprocessingPtr != NULL) {\n        void* curData = rt_getTempMemory(val, numEls);\n        preprocessingPtr(curData, data);\n        rt_UpdateLogVar(val, curData, isVarDims);\n        free(curData);\n    }\n    else {\n        rt_UpdateLogVar(val, data, isVarDims);\n    }\n}\n\n/*\n* g1614989:This function is called when each signal has a specific RTWLogSignalInfo structure defined.\n*/\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    rt_preProcessAndLogDataWithIndex(&signalInfo, -1, val, data, isVarDims);\n}\n \n/* Function: rt_UpdateTXYLogVars ===============================================\n * Abstract:\n *\tUpdate the xFinal,T,X,Y variables that are being logged.\n */\nconst char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr)\n{\n    return rt_UpdateTXXFYLogVars(li, tPtr, true);\n}\n \n/* Function: rt_UpdateTXXFYLogVars =============================================\n * Abstract:\n *\tUpdate xFinal and/or the T,X,Y variables that are being logged\n */\nconst char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY)\n{\n    LogInfo *logInfo     = rtliGetLogInfo(li);\n    int_T   matrixFormat = (rtliGetLogFormat(li) == 0);\n    const RTWLogSignalInfo* yInfo = rtliGetLogYSignalInfo(li);\n    const RTWLogSignalInfo* xInfo = rtliGetLogXSignalInfo(li);\n\n    /* time */\n    if (logInfo->t != NULL && updateTXY) {\n        rt_UpdateLogVar(logInfo->t, tPtr, false);\n    }\n\n    if (matrixFormat) {                                      /* MATRIX_FORMAT */\n        /* states */\n        if (logInfo->x != NULL || logInfo->xFinal != NULL) {\n            int8_T**               segAddr     = _rtliGetLogXSignalPtrs(li);\n            const int_T            *segLengths = xInfo->numCols;\n            int_T                  nSegments   = xInfo->numSignals;\n            RTWPreprocessingFcnPtr* preprocessingPtrs = xInfo->preprocessingPtrs;\n\n            if (logInfo->x != NULL && updateTXY) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->x, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n            if (logInfo->xFinal != NULL) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->xFinal, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n        }\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            LogVar **var = (LogVar**) (logInfo->y);\n            int_T  ny    = logInfo->ny;\n            int_T  i;\n            int    yIdx;\n            LogSignalPtrsType data = rtliGetLogYSignalPtrs(li);\n\n            for (i = 0, yIdx = 0; i < ny; i++) {\n                if (data[i] != NULL) {\n                    /* \n                       When outputs are logged in Matrix format, \n                       no variable-size signal logging is allowed.\n                    */\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *          Function pointer is now identified by using \n                     *          Y Signal Info instead of iterating over pre-processing \n                     *          function pointers.\n                    */ \n                    rt_preProcessAndLogData(yInfo[yIdx], var[yIdx], data[i], false);\n                    yIdx++;\n                }\n            }\n        }\n    } else {                                              /* STRUCTURE_FORMAT */\n        /* states */\n        if (logInfo->x != NULL && updateTXY) {\n            int_T             i;\n            StructLogVar      *var = logInfo->x;\n            LogVar            *val = var->signals.values;\n            int_T             nsig = var->signals.numSignals;\n            LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n\n            /* time */\n            if (var->logTime) {\n                rt_UpdateLogVar(var->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            int_T             ny      = logInfo->ny;\n            LogSignalPtrsType data    = rtliGetLogYSignalPtrs(li);\n            StructLogVar      **var   = (StructLogVar**) (logInfo->y);\n\n            if (ny == 1) {\n                int_T  i;\n                int_T  dataIdx;\n                LogVar *val = var[0]->signals.values;\n                int_T  nsig = var[0]->signals.numSignals;\n                boolean_T   *isVarDims = var[0]->signals.isVarDims;\n\n                /* time */\n                if (var[0]->logTime) {\n                    rt_UpdateLogVar(var[0]->time, tPtr, false);\n                }\n\n                /* signals */\n                for (i = 0, dataIdx = 0; i < nsig; i++) {                    \n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogDataWithIndex(yInfo, i, val, data[dataIdx], isVarDims[i]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            } else {\n                int_T  i;\n                int_T  dataIdx;\n\n                for (i = 0, dataIdx = 0; i < ny && var[i] != NULL; i++) {\n                    LogVar *val = var[i]->signals.values;\n                    boolean_T   *isVarDims = var[i]->signals.isVarDims;\n\n                    /* time */\n                    if (var[i]->logTime) {\n                        rt_UpdateLogVar(var[i]->time, tPtr, false);\n                    }\n\n                    /* signals */\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogData(yInfo[i], val, data[dataIdx], isVarDims[0]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            }\n        }\n        /* final state */\n        if (logInfo->xFinal != NULL) {\n            StructLogVar *xf  = logInfo->xFinal;\n            LogVar       *val = xf->signals.values;\n            int_T        nsig = xf->signals.numSignals;\n            int_T        i;\n\n            /* time */\n            if (xf->logTime) {\n                rt_UpdateLogVar(xf->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n    }\n    return(NULL);\n} /* end rt_UpdateTXXFYLogVars */\n\n\n#ifdef __cplusplus\n}\n#endif\n          \n\n          \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLoggingImpl =======================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel)\n{\n    FILE          *fptr;\n    LogInfo       *logInfo     = (LogInfo*) rtliGetLogInfo(li);\n    LogVar        *var         = logInfo->logVarsList;\n    StructLogVar  *svar        = logInfo->structLogVarsList;\n    /* At this time, verbose is only needed if running rapid accelerator\n     * simulations. */\n    int           verbose      = isRaccel ? 0: 1;\n\n    boolean_T     emptyFile    = 1; /* assume */\n    boolean_T     errFlag      = 0;\n    const char_T  *msg;\n\n    /*******************************\n     * Create MAT file with header *\n     *******************************/\n    if ((fptr=fopen(file,\"w+b\")) == NULL) {\n        (void)fprintf(stderr,\"*** Error opening %s\",file);\n        goto EXIT_POINT;\n    }\n    if (rt_WriteMat5FileHeader(fptr)) {\n        (void)fprintf(stderr,\"*** Error writing to %s\",file);\n        goto EXIT_POINT;\n    }\n\n    /**************************************************\n     * First log all the variables in the LogVar list *\n     **************************************************/\n    while (var != NULL) {\n        if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n            (void)fprintf(stderr,\"*** Error writing %s due to: %s\\n\",file,msg);\n            errFlag = 1;\n            break;\n        }\n        if (var->nDataPoints > 0 || isRaccel) {\n            MatItem item;\n\n            item.type   = matMATRIX;\n            item.nbytes = 0; /* not yet known */\n            item.data   = &(var->data);\n            if (rt_WriteItemToMatFile(fptr, &item, MATRIX_ITEM)) {\n                (void)fprintf(stderr,\"*** Error writing log variable %s to \"\n                              \"file %s\",var->data.name, file);\n                errFlag = 1;\n                break;\n            }\n            emptyFile = 0;\n        }\n        var = var->next;\n    }\n    /* free up some memory by destroying the log var list here */\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n\n    /*******************************************************\n     * Next log all the variables in the StructLogVar list *\n     *******************************************************/\n    while (svar != NULL) {\n        MatItem item;\n\n        if (svar->logTime) {\n            var = svar->time;\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n        }\n\n        var = svar->signals.values;\n        while (var) {\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n            var = var->next;\n        }\n\n        item.type   = matMATRIX;\n        item.nbytes = 0; /* not yet known */\n        item.data   = svar;\n\n        if (rt_WriteItemToMatFile(fptr, &item, STRUCT_LOG_VAR_ITEM)) {\n            (void)fprintf(stderr,\"*** Error writing structure log variable \"\n                          \"%s to file %s\",svar->name, file);\n            errFlag = 1;\n            break;\n        }\n        emptyFile = 0;\n\n        svar = svar->next;\n    }\n\n    /******************\n     * Close the file *\n     ******************/\n    (void)fclose(fptr);\n    if (emptyFile || errFlag) {\n        (void)remove(file);\n    } else {\n        if( verbose ) {\n            (void)printf(\"** created %s **\\n\\n\", file);\n        }\n    }\n\n EXIT_POINT:\n\n    /****************\n     * free logInfo *\n     ****************/\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n    rt_DestroyStructLogVar(logInfo->structLogVarsList);\n    logInfo->structLogVarsList = NULL;\n    FREE(logInfo->y);\n    logInfo->y = NULL;\n    FREE(logInfo);\n    rtliSetLogInfo(li,NULL);\n\n} /* end rt_StopDataLoggingImpl */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLogging ================================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLogging(const char_T *file, RTWLogInfo *li)\n{\n    rt_StopDataLoggingImpl(file,li,false);\n\n} /* end rt_StopDataLogging */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li) { (void(file)); } /* use file quiet unused macro warning */ /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n\n\n/* [eof] rt_logging.c */\n\n/* LocalWords:  Tfinal MAXNAM nonfinite DType PWS RSim Fixup logvar DDEFAULT th\n * LocalWords:  curr Realloc realloc inp biglong vijay ldexp TXY eof XFinal th\n * LocalWords:  TXXFY NULL typedefs ret polyspace NUL\n */\n"},{"name":"rt_logging_mmi.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2020 The MathWorks, Inc.\n *\n * File: rt_logging_mmi.c\n *\n * Abstract:\n */\n\n#ifndef rt_logging_c\n#define rt_logging_c\n\n#include <stdlib.h>\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#include \"builtin_typeid_types.h\"\n#include \"rtw_matlogging.h\"\n#include \"rtw_modelmap.h\"\n#include <string.h>\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n#define FREE(m) if (m != NULL) free(m)\n\n#define ACCESS_C_API_FOR_RTW_LOGGING true\n\n/* Function: rt_FillStateSigInfoFromMMI =======================================\n * Abstract:\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nconst char_T * rt_FillStateSigInfoFromMMI(RTWLogInfo   *li,\n                                                 const char_T **errStatus)\n{\n    int_T                  i;\n    int_T                  nSignals     = 0;\n    int_T                  *dims        = NULL;\n    BuiltInDTypeId         *dTypes      = NULL;\n    int_T                  *cSgnls      = NULL;\n    char_T                 **labels     = NULL;\n    char_T                 **blockNames = NULL;\n    char_T                 **stateNames = NULL;\n    boolean_T              *crossMdlRef = NULL;\n    char_T                 **pathAlias  = NULL;\n    void                   **sigDataAddr = NULL;\n    RTWLoggingFcnPtr       *RTWLoggingPtrs = NULL;\n    int_T                  *logDataType = NULL;\n    boolean_T              *isVarDims   = NULL;\n    const rtwCAPI_ModelMappingInfo *mmi = (const rtwCAPI_ModelMappingInfo *)rtliGetMMI(li);\n\n    int_T                  sigIdx       = 0;\n\n    RTWLogSignalInfo *     sigInfo;\n    /* reset error status */\n    *errStatus = NULL;\n\n    sigInfo = (RTWLogSignalInfo *)calloc(1,sizeof(RTWLogSignalInfo));\n    if (sigInfo == NULL) goto ERROR_EXIT;\n\n    nSignals = rtwCAPI_GetNumStateRecordsForRTWLogging(mmi);\n\n    if (nSignals >0) {\n        /* These are all freed before exiting this function */\n        dims        = (int_T *)calloc(nSignals,sizeof(int_T));\n        if (dims == NULL) goto ERROR_EXIT;\n        dTypes      = (BuiltInDTypeId *)calloc(nSignals,sizeof(BuiltInDTypeId));\n        if (dTypes == NULL) goto ERROR_EXIT;\n        cSgnls      = (int_T *)calloc(nSignals,sizeof(int_T));\n        if (cSgnls == NULL) goto ERROR_EXIT;\n        labels      = (char_T **)calloc(nSignals, sizeof(char_T*));\n        if (labels == NULL) goto ERROR_EXIT;\n        blockNames  = (char_T**)calloc(nSignals, sizeof(char_T*));\n        if (blockNames == NULL) goto ERROR_EXIT;\n        stateNames  = (char_T**)calloc(nSignals, sizeof(char_T*));\n        if (stateNames == NULL) goto ERROR_EXIT;\n        crossMdlRef  = (boolean_T*)calloc(nSignals, sizeof(boolean_T));\n        if (crossMdlRef == NULL) goto ERROR_EXIT;\n        pathAlias  = (char_T**)calloc(nSignals, sizeof(char_T*));\n        if (pathAlias == NULL) goto ERROR_EXIT;\n        logDataType = (int_T *)calloc(nSignals,sizeof(int_T));\n        if (logDataType == NULL) goto ERROR_EXIT;\n        /* Allocate memory for isVarDims pointer and set all elements to 0's */\n        isVarDims = (boolean_T *)calloc(nSignals,sizeof(boolean_T));\n        if (isVarDims == NULL) goto ERROR_EXIT;\n\n        /* These are freed in stopDataLogging (they're needed in the meantime) */\n        sigDataAddr = (void **)calloc(nSignals,sizeof(void *));\n        if (sigDataAddr == NULL) goto ERROR_EXIT;\n        RTWLoggingPtrs = (RTWLoggingFcnPtr *)calloc(nSignals, sizeof(RTWLoggingFcnPtr));\n        if (RTWLoggingPtrs == NULL) goto ERROR_EXIT;\n\n        *errStatus = rtwCAPI_GetStateRecordInfo(mmi,\n                                                (const char_T**) blockNames,\n                                                (const char_T**) labels,\n                                                (const char_T**) stateNames,\n                                                dims,\n                                                (int_T*)dTypes,\n                                                logDataType,\n                                                cSgnls,\n                                                sigDataAddr,\n                                                RTWLoggingPtrs,\n                                                crossMdlRef,\n                                                NULL, /* sigInProtectedMdl */\n                                                (const char_T**) pathAlias,\n                                                NULL, /* sigSampleTime */\n                                                NULL, /* sigHierInfoIdx */\n                                                NULL, /* sigFlatElemIdx */\n                                                NULL, /* sigMMI */\n                                                &sigIdx,\n                                                false, /* crossingModel */\n                                                false, /* isInProtectedMdl */\n                                                NULL,  /* stateDerivVector */\n                                                ACCESS_C_API_FOR_RTW_LOGGING);\n\n        if (*errStatus != NULL) goto ERROR_EXIT;\n\n        rtliSetLogXSignalPtrs(li,(LogSignalPtrsType)sigDataAddr);\n    }\n\n    /* g2104454 : If pathAlias is available then copy it as block name */\n    for (i = 0; i < nSignals; ++i) {\n        if (pathAlias[i] != NULL) {\n            utFree(blockNames[i]);\n            blockNames[i] = pathAlias[i];\n        }\n    }\n\n    /* Done with pathAlias */\n    FREE(pathAlias);\n\n    sigInfo->numSignals = nSignals;\n    sigInfo->numCols = dims;\n    sigInfo->numDims = NULL;\n    sigInfo->dims = dims;\n    sigInfo->dataTypes = dTypes;\n    sigInfo->complexSignals = cSgnls;\n    sigInfo->frameData = NULL;\n    sigInfo->preprocessingPtrs = (RTWPreprocessingFcnPtr*) RTWLoggingPtrs;\n    sigInfo->labels.ptr = labels;\n    sigInfo->titles = NULL;\n    sigInfo->titleLengths = NULL;\n    sigInfo->plotStyles = NULL;\n    sigInfo->blockNames.ptr = blockNames;\n    sigInfo->stateNames.ptr = stateNames;\n    sigInfo->crossMdlRef = crossMdlRef;\n    sigInfo->dataTypeConvert = NULL;\n\n    sigInfo->isVarDims = isVarDims;\n    sigInfo->currSigDims = NULL;\n\n    rtliSetLogXSignalInfo(li,sigInfo);\n\n    /* Free logDataType it's not needed any more,\n     * the rest of them will be freed later */\n    FREE(logDataType);\n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    /* Free local stuff that was allocated. It is no longer needed */\n    for (i = 0; i < nSignals; ++i) utFree(blockNames[i]);\n    FREE(blockNames);\n    for (i = 0; i < nSignals; ++i) utFree(stateNames[i]);\n    FREE(stateNames);\n    FREE(labels);\n    FREE(dims);\n    FREE(dTypes);\n    FREE(logDataType);\n    FREE(cSgnls);\n    FREE(isVarDims);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\nvoid rt_CleanUpForStateLogWithMMI(RTWLogInfo *li)\n{\n    int_T i;\n    RTWLogSignalInfo *sigInfo = _rtliGetLogXSignalInfo(li); /* get the non-const ptr */\n    int_T nSignals = sigInfo->numSignals;\n\n    if ( nSignals > 0 ) {\n\n        for (i = 0; i < nSignals; ++i) utFree(sigInfo->blockNames.ptr[i]);\n        FREE(sigInfo->blockNames.ptr);\n        FREE(sigInfo->labels.ptr);\n        FREE(sigInfo->crossMdlRef);\n        FREE(sigInfo->dims);\n        FREE(sigInfo->dataTypes);\n        FREE(sigInfo->complexSignals);\n        FREE(sigInfo->isVarDims);\n        FREE(sigInfo);\n        rtliSetLogXSignalInfo(li, NULL);\n\n        FREE(_rtliGetLogXSignalPtrs(li)); /* get the non-const ptr */\n        rtliSetLogXSignalPtrs(li,NULL);\n    }\n}\n\n#endif /*  rt_logging_mmi_c */\n\n/* LocalWords:  Hier Deriv\n */\n"},{"name":"rt_logging_mmi_simtarget.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2020 The MathWorks, Inc.\n *\n * File: rt_logging_mmi.c\n *\n * Abstract:\n */\n\n#ifndef rt_logging_c\n#define rt_logging_c\n\n#include <stdlib.h>\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#include \"builtin_typeid_types.h\"\n#include \"rtw_matlogging_simtarget.h\"\n#include \"rtw_modelmap_simtarget.h\"\n#include <string.h>\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n#define FREE(m) if (m != NULL) free(m)\n\n#define ACCESS_C_API_FOR_RTW_LOGGING true\n\n/* Function: rt_FillStateSigInfoFromMMI =======================================\n * Abstract:\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nconst char_T * rt_FillStateSigInfoFromMMI(RTWLogInfo   *li,\n                                                 const char_T **errStatus)\n{\n    int_T                  i;\n    int_T                  nSignals     = 0;\n    int_T                  *dims        = NULL;\n    BuiltInDTypeId         *dTypes      = NULL;\n    int_T                  *cSgnls      = NULL;\n    char_T                 **labels     = NULL;\n    char_T                 **blockNames = NULL;\n    char_T                 **stateNames = NULL;\n    boolean_T              *crossMdlRef = NULL;\n    char_T                 **pathAlias  = NULL;\n    void                   **sigDataAddr = NULL;\n    RTWLoggingFcnPtr       *RTWLoggingPtrs = NULL;\n    int_T                  *logDataType = NULL;\n    boolean_T              *isVarDims   = NULL;\n    int_T                  *stateIdxList = NULL;\n    const rtwCAPI_ModelMappingInfo *mmi = (const rtwCAPI_ModelMappingInfo *)rtliGetMMI(li);\n\n    int_T                  sigIdx       = 0;\n\n    RTWLogSignalInfo *     sigInfo;\n    /* reset error status */\n    *errStatus = NULL;\n\n    sigInfo = (RTWLogSignalInfo *)calloc(1,sizeof(RTWLogSignalInfo));\n    if (sigInfo == NULL) goto ERROR_EXIT;\n\n    nSignals = rtwCAPI_GetNumStateRecordsForRTWLogging(mmi);\n\n    if (nSignals >0) {\n        /* These are all freed before exiting this function */\n        dims        = (int_T *)calloc(nSignals,sizeof(int_T));\n        if (dims == NULL) goto ERROR_EXIT;\n        dTypes      = (BuiltInDTypeId *)calloc(nSignals,sizeof(BuiltInDTypeId));\n        if (dTypes == NULL) goto ERROR_EXIT;\n        cSgnls      = (int_T *)calloc(nSignals,sizeof(int_T));\n        if (cSgnls == NULL) goto ERROR_EXIT;\n        labels      = (char_T **)calloc(nSignals, sizeof(char_T*));\n        if (labels == NULL) goto ERROR_EXIT;\n        blockNames  = (char_T**)calloc(nSignals, sizeof(char_T*));\n        if (blockNames == NULL) goto ERROR_EXIT;\n        stateNames  = (char_T**)calloc(nSignals, sizeof(char_T*));\n        if (stateNames == NULL) goto ERROR_EXIT;\n        crossMdlRef  = (boolean_T*)calloc(nSignals, sizeof(boolean_T));\n        if (crossMdlRef == NULL) goto ERROR_EXIT;\n        pathAlias  = (char_T**)calloc(nSignals, sizeof(char_T*));\n        if (pathAlias == NULL) goto ERROR_EXIT;\n        logDataType = (int_T *)calloc(nSignals,sizeof(int_T));\n        if (logDataType == NULL) goto ERROR_EXIT;\n        /* Allocate memory for isVarDims pointer and set all elements to 0's */\n        isVarDims = (boolean_T *)calloc(nSignals,sizeof(boolean_T));\n        if (isVarDims == NULL) goto ERROR_EXIT;\n\n        /* These are freed in stopDataLogging (they're needed in the meantime) */\n        sigDataAddr = (void **)calloc(nSignals,sizeof(void *));\n        if (sigDataAddr == NULL) goto ERROR_EXIT;\n        RTWLoggingPtrs = (RTWLoggingFcnPtr *)calloc(nSignals, sizeof(RTWLoggingFcnPtr));\n        if (RTWLoggingPtrs == NULL) goto ERROR_EXIT;\n\n        stateIdxList = (int_T *)calloc(nSignals, sizeof(int_T));\n        if (stateIdxList == NULL) goto ERROR_EXIT;\n        memset(stateIdxList, -1, nSignals * sizeof(int_T));\n        *errStatus = rtwCAPI_GetStateRecordInfo(mmi,\n                                                (const char_T**) blockNames,\n                                                (const char_T**) labels,\n                                                (const char_T**) stateNames,\n                                                dims,\n                                                (int_T*)dTypes,\n                                                logDataType,\n                                                cSgnls,\n                                                sigDataAddr,\n                                                RTWLoggingPtrs,\n                                                crossMdlRef,\n                                                NULL, /* sigInProtectedMdl */\n                                                (const char_T**) pathAlias,\n                                                NULL, /* sigSampleTime */\n                                                NULL, /* sigHierInfoIdx */\n                                                NULL, /* sigFlatElemIdx */\n                                                NULL, /* sigMMI */\n                                                &sigIdx,\n                                                false, /* crossingModel */\n                                                false, /* isInProtectedMdl */\n                                                NULL,  /* stateDerivVector */\n                                                ACCESS_C_API_FOR_RTW_LOGGING,\n                                                stateIdxList);\n\n        if (*errStatus != NULL) goto ERROR_EXIT;\n\n        rtliSetLogXSignalPtrs(li,(LogSignalPtrsType)sigDataAddr);\n    }\n\n    /* g2104454 : If pathAlias is available then copy it as block name */\n    for (i = 0; i < nSignals; ++i) {\n        if (pathAlias[i] != NULL) {\n            utFree(blockNames[i]);\n            blockNames[i] = pathAlias[i];\n        }\n    }\n\n    /* Done with pathAlias */\n    FREE(pathAlias);\n\n    sigInfo->numSignals = nSignals;\n    sigInfo->numCols = dims;\n    sigInfo->numDims = NULL;\n    sigInfo->dims = dims;\n    sigInfo->dataTypes = dTypes;\n    sigInfo->complexSignals = cSgnls;\n    sigInfo->frameData = NULL;\n    sigInfo->preprocessingPtrs = (RTWPreprocessingFcnPtr*) RTWLoggingPtrs;\n    sigInfo->labels.ptr = labels;\n    sigInfo->titles = NULL;\n    sigInfo->titleLengths = NULL;\n    sigInfo->plotStyles = NULL;\n    sigInfo->blockNames.ptr = blockNames;\n    sigInfo->stateNames.ptr = stateNames;\n    sigInfo->crossMdlRef = crossMdlRef;\n    sigInfo->dataTypeConvert = NULL;\n\n    sigInfo->isVarDims = isVarDims;\n    sigInfo->currSigDims = NULL;\n\n    if(stateIdxList == NULL) {\n    /* There are no states to be logged for this model */\n        sigInfo->stateIdxList = NULL;\n    }\n    else {\n        if(stateIdxList[0] == -1) {\n            /* There are states but save format is not dataset. So no need to add the stateIdxList. */\n            sigInfo->stateIdxList = NULL;\n        }\n        else {\n            /* There are states to be logged and save format is dataset. */\n            sigInfo->stateIdxList = stateIdxList;\n        }\n    }\n    rtliSetLogXSignalInfo(li,sigInfo);\n\n    /* Free logDataType it's not needed any more,\n     * the rest of them will be freed later */\n    FREE(logDataType);\n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    /* Free local stuff that was allocated. It is no longer needed */\n    for (i = 0; i < nSignals; ++i) utFree(blockNames[i]);\n    FREE(blockNames);\n    for (i = 0; i < nSignals; ++i) utFree(stateNames[i]);\n    FREE(stateNames);\n    FREE(labels);\n    FREE(dims);\n    FREE(dTypes);\n    FREE(logDataType);\n    FREE(cSgnls);\n    FREE(isVarDims);\n    FREE(stateIdxList);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\nvoid rt_CleanUpForStateLogWithMMI(RTWLogInfo *li)\n{\n    int_T i;\n    RTWLogSignalInfo *sigInfo = _rtliGetLogXSignalInfo(li); /* get the non-const ptr */\n    int_T nSignals = sigInfo->numSignals;\n\n    if ( nSignals > 0 ) {\n\n        for (i = 0; i < nSignals; ++i) utFree(sigInfo->blockNames.ptr[i]);\n        FREE(sigInfo->blockNames.ptr);\n        FREE(sigInfo->labels.ptr);\n        FREE(sigInfo->crossMdlRef);\n        FREE(sigInfo->dims);\n        FREE(sigInfo->dataTypes);\n        FREE(sigInfo->complexSignals);\n        FREE(sigInfo->isVarDims);\n        FREE(sigInfo->stateIdxList);\n        FREE(sigInfo);\n        rtliSetLogXSignalInfo(li, NULL);\n\n        FREE(_rtliGetLogXSignalPtrs(li)); /* get the non-const ptr */\n        rtliSetLogXSignalPtrs(li,NULL);\n    }\n}\n\n#endif /*  rt_logging_mmi_c */\n\n/* LocalWords:  Hier Deriv\n */\n"},{"name":"rt_logging_simtarget.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n *\n * Copyright 1994-2021 The MathWorks, Inc.\n *\n * File: rt_logging_simtarget.c\n *\n * Abstract:\n *\tReal-Time Workshop data logging routines using circular buffers of\n *      fixed size.  The buffers are allocated at start, filled in at each\n *      major time step and finally written to a MAT-file at the end of the\n *      simulation.\n *\n *      This file handles redefining the following standard MathWorks types\n *      (see tmwtypes.h):\n *         [u]int8_T     to be int32_T (logged as Matlab [u]int32)\n *         [u]int16_T    to be int32_T (logged as Matlab [u]int32)\n *         real_T        to be real32_T (logged as Matlab single)\n *\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rt_logging_simtarget.h\"\n#ifndef IS_RAPID_ACCEL\n#error Not Rapid Accelerator Target\n#endif\n#include \"rtw_matlogging_simtarget.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n#define matLOGICAL_BIT          0x200\n#define matCOMPLEX_BIT          0x800\n\n#define matKEY                 0x4D49\n#define matVERSION             0x0100\n#define matVERSION_INFO_OFFSET   124L\n\n#define matINT64_ALIGN(e)      ( ( ((unsigned)(e))+7 ) & (~7) )\n#define matTAG_SIZE            (sizeof(int32_T) << 1)\n\n#ifndef DEFAULT_BUFFER_SIZE\n#define DEFAULT_BUFFER_SIZE      1024  /* used if maxRows=0 and Tfinal=0.0    */\n#endif\n\n#define FREE(m) if (m != NULL) free(m)\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/*==========*\n * typedefs *\n *==========*/\n\ntypedef struct LogInfo_Tag {\n    LogVar       *t;                   /* Time log variable                   */\n    void         *x;                   /* State log variable                  */\n    int_T        ny;                   /* Length of \"y\" log variables         */\n    void         **y;                  /* Output log vars                     */\n    void         *xFinal;              /* Final state log variable            */\n\n    LogVar       *logVarsList;         /* Linked list of all LogVars          */\n    StructLogVar *structLogVarsList;   /* Linked list of all StructLogVars    */\n\n    boolean_T   haveLogVars;           /* Are logging one or more vars?       */\n} LogInfo;\n\ntypedef struct MatItem_tag {\n  int32_T    type;\n  uint32_T    nbytes;\n  const void *data;\n} MatItem;\n\ntypedef enum {\n    DATA_ITEM,\n    MATRIX_ITEM,\n    STRUCT_LOG_VAR_ITEM,\n    SIGNALS_STRUCT_ITEM\n} ItemDataKind;\n\n/*===========*\n * Constants *\n *===========*/\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n\n#define ZEROS32 \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\n#if mxMAXNAM==32\n\n#define ZERO_PAD\n\n#elif mxMAXNAM==64\n\n#define ZERO_PAD ZEROS32\n\n#elif mxMAXNAM==128\n\n#define ZERO_PAD   ZEROS32  ZEROS32  ZEROS32\n\n#else\n\n#error \"Cannot Handle mxMAXNAM other than 32,64, and 128\"\n\n#endif\n/* field names: for variable-size signal logging */\nstatic const char_T rtStructLogVarFieldNames[] =\n                  \"time\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"signals\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateIdxList\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  ;\n\nstatic const char_T rtLocalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateIdxList\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  ;\n\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateIdxList\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  ;\n\n#define TIME_FIELD_NAME      (rtStructLogVarFieldNames[0*mxMAXNAM])\n#define SIGNALS_FIELD_NAME   (rtStructLogVarFieldNames[1*mxMAXNAM])\n#define BLOCKNAME_FIELD_NAME (rtStructLogVarFieldNames[2*mxMAXNAM])\n\n#define VALUES_FIELD_NAME    (rtLocalLoggingSignalsStructFieldNames[0*mxMAXNAM])\n#define VALUEDIMENSIONS_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[1*mxMAXNAM])\n#define DIMENSION_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[2*mxMAXNAM])\n#define LABEL_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[3*mxMAXNAM])\n#define TITLE_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[4*mxMAXNAM])\n#define PLOTSTYLE_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n\n#define STATENAME_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n#define CROSS_MDL_REF_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[6*mxMAXNAM])\n\n#define STATE_INDEX_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[7*mxMAXNAM])\n\n/* field names: for fixed-size signal logging */\nstatic const char_T rtLocalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateIdxList\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  ;\n\nextern real_T rtInf; /* declared by rt_nonfinite.c */\nextern real_T rtNaN;\nextern real32_T rtNaNF;\n\n/*================*\n * Local routines *\n *================*/\n\n/* Function: rt_GetSizeofDataType ==============================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofDataType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 0; /* unknown */\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        elSz = sizeof(real_T);\n        break;\n      case SS_SINGLE:\n        elSz = sizeof(real32_T);\n        break;\n      case SS_INT8:\n        elSz = sizeof(int8_T);\n        break;\n      case SS_UINT8:\n        elSz = sizeof(uint8_T);\n        break;\n      case SS_INT16:\n        elSz = sizeof(int16_T);\n        break;\n      case SS_UINT16:\n        elSz = sizeof(uint16_T);\n        break;\n      case SS_INT32:\n        elSz = sizeof(int32_T);\n        break;\n      case SS_UINT32:\n        elSz = sizeof(uint32_T);\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n    return(elSz);\n\n} /* end rt_GetSizeofDataType */\n\n\n/* Function: rt_GetSizeofComplexType ===========================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofComplexType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 2*rt_GetSizeofDataType(dTypeID);\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal_T);\n      #endif\n        break;\n      case SS_SINGLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal32_T);\n      #endif\n        break;\n      case SS_INT8:\n      #ifdef CINT8_T\n        elSz = sizeof(cint8_T);\n      #endif\n        break;\n      case SS_UINT8:\n      #ifdef CUINT8_T\n        elSz = sizeof(cuint8_T);\n      #endif\n        break;\n      case SS_INT16:\n      #ifdef CINT16_T\n        elSz = sizeof(cint16_T);\n      #endif\n        break;\n      case SS_UINT16:\n      #ifdef CUINT16_T\n        elSz = sizeof(cuint16_T);\n      #endif\n        break;\n      case SS_INT32:\n      #ifdef CINT32_T\n        elSz = sizeof(cint32_T);\n      #endif\n        break;\n      case SS_UINT32:\n      #ifdef CUINT32_T\n        elSz = sizeof(cuint32_T);\n      #endif\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n\n    return(elSz);\n\n} /* end rt_GetSizeofComplexType */\n\n\n/* Function: rt_GetDataTypeConvertInfo =========================================\n * Abstract:\n *      Directly copy if pointer to structure is non-NULL, otherwise set to\n *      default.\n */\nstatic RTWLogDataTypeConvert rt_GetDataTypeConvertInfo(\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    BuiltInDTypeId dTypeID\n    )\n{\n    RTWLogDataTypeConvert dataTypeConvertInfoCopy;\n\n    if (pDataTypeConvertInfo == NULL) {\n        dataTypeConvertInfoCopy.conversionNeeded = 0;\n        dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;\n        dataTypeConvertInfoCopy.dataTypeIdOriginal  = (DTypeId)dTypeID;\n        dataTypeConvertInfoCopy.bitsPerChunk = 0;\n        dataTypeConvertInfoCopy.numOfChunk = 0;\n        dataTypeConvertInfoCopy.isSigned = 0;\n        dataTypeConvertInfoCopy.fracSlope = 1.0;\n        dataTypeConvertInfoCopy.fixedExp = 0;\n        dataTypeConvertInfoCopy.bias = 0.0;\n    } else {\n        dataTypeConvertInfoCopy = *pDataTypeConvertInfo;\n    }\n\n    return dataTypeConvertInfoCopy;\n\n} /* end rt_GetDataTypeConvertInfo */\n\n\n/* Function: rt_GetDblValueFromOverSizedData ===================================\n * Abstract:\n */\nstatic double rt_GetDblValueFromOverSizedData(\n    const void *pVoid,\n    int bitsPerChunk,\n    int numOfChunk,\n    unsigned int isSigned,\n    double fracSlope,\n    int fixedExp,\n    double bias)\n{\n    double retValue = 0;\n\n    double *dblValue = (double *) calloc(numOfChunk, sizeof(double));\n\n    int i;\n    double isSignedNeg;\n\n    if(isSigned) {\n        const chunk_T *pData = (const chunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    } else  {\n        const uchunk_T *pData = (const uchunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    }\n\n    /*\n       Assuming multi chunks b_n ... b_2 b_1 b_0, and the length of each chunk is N.\n       Suppose b_i is the i-th chunk's value.\n       Then for unsigned data or data with one chunk: we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0;\n       But for signed data, we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0+ (b_0<0) * 2^N +\n       ... (b_(n-1) <0) * 2^(n*N)\n       = (b_n + (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + (b_0<0)) * 2^N + b_0 * 2^0;\n       Together:\n       retValue =\n       (b_n + isSigned * (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + isSigned * (b_0<0)) * 2^N + b_0 * 2^0;\n    */\n\n    retValue = dblValue[numOfChunk - 1];\n\n    for(i = numOfChunk - 1; i > 0; i--) {\n        isSignedNeg = dblValue[i - 1] < 0 ? (double)isSigned : 0;\n        retValue = retValue + isSignedNeg;\n\n        retValue = ldexp(retValue, bitsPerChunk)+ dblValue[i-1];\n    }\n    retValue = ldexp( fracSlope * retValue, fixedExp ) + bias;\n\n    FREE(dblValue);\n    return (retValue);\n\n} /* end rt_GetDblValueFromOverSizedData */\n\n\n/* Function: rt_GetNonBoolMxIdFromDTypeId ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nstatic mxClassID rt_GetNonBoolMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        mxID = (sizeof(real_T)==4? mxSINGLE_CLASS: mxDOUBLE_CLASS);\n        break;\n      case SS_SINGLE:\n        mxID = mxSINGLE_CLASS;\n        break;\n      case SS_INT8:\n        switch (sizeof(int8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                     \"Needed for when PWS maps int8_T into 32-bits\" */\n            mxID = mxINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                     \"Needed for when PWS maps int8_T into 16-bits\" */\n            mxID = mxINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_UINT8:\n        switch (sizeof(uint8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                     \"Needed for when PWS maps uint8_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                     \"Needed for when PWS maps uint8_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxUINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_INT16:\n        mxID = (sizeof(int16_T)==4? mxINT32_CLASS: mxINT16_CLASS);\n        break;\n      case SS_UINT16:\n        mxID = (sizeof(uint16_T)==4? mxUINT32_CLASS: mxUINT16_CLASS);\n        break;\n      case SS_INT32:\n        mxID = mxINT32_CLASS;\n        break;\n      case SS_UINT32:\n        mxID = mxUINT32_CLASS;\n        break;\n        /*case SS_BOOLEAN:\n          mxID = (sizeof(boolean_T)==4? mxUINT32_CLASS: mxLOGICAL_CLASS);\n          break;*/\n      default:\n        mxID = mxUNKNOWN_CLASS;\n        break;\n    }\n\n    return(mxID);\n\n} /* end rt_GetNonBoolMxIdFromDTypeId */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeIdForRSim ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxLOGICAL_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeIdForRSim */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeId =============================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxUINT8_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeId */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n/* Function: rt_GetMatIdFromMxId ===============================================\n * Abstract:\n *      Get the MatId given the mxClassID.\n */\nstatic int_T rt_GetMatIdFromMxId(mxClassID mxID)\n{\n    int_T matID;\n\n    switch (mxID) {\n      case mxCELL_CLASS:\n      case mxSTRUCT_CLASS:\n      case mxOBJECT_CLASS:\n        matID = -1;\n        break;\n      case mxCHAR_CLASS:\n        matID = matUINT16;\n        break;\n      case mxDOUBLE_CLASS:\n        matID = matDOUBLE;\n        break;\n      case mxSINGLE_CLASS:\n        matID = matFLOAT;\n        break;\n      case mxINT8_CLASS:\n        matID = matINT8;\n        break;\n      case mxUINT8_CLASS:\n        matID = matUINT8;\n        break;\n      case mxINT16_CLASS:\n        matID = matINT16;\n        break;\n      case mxUINT16_CLASS:\n        matID = matUINT16;\n        break;\n      case mxINT32_CLASS:\n        matID = matINT32;\n        break;\n      case mxUINT32_CLASS:\n        matID = matUINT32;\n        break;\n      case mxINT64_CLASS:\n        matID = matINT64;\n        break;\n      case mxUINT64_CLASS:\n        matID = matUINT64;\n        break;\n      default:\n        matID = matUNKNOWN;\n        break;\n    }\n    return(matID);\n\n} /* end rt_GetMatIdFromMxId */\n\n\n/* Forward declaration */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind dataKind);\n\n\n/* Function: rt_ProcessMatItem =================================================\n * Abstract:\n *      This routine along with rt_WriteItemToMatFile() write out a specified\n *      mat-item the .mat file. Note that if the input argument\n *          cmd == 0, then this function just calculates the size of the item.\n *          cmd <> 0, this function writes the mat-item to the file.\n *      Return values is\n *           -1 : coding/logic error\n *            0 : upon success\n *          > 0 : upon write failure (1)\n */\nstatic int_T rt_ProcessMatItem(FILE         *fp,\n                               MatItem      *pItem,\n                               ItemDataKind itemKind,\n                               int_T        cmd)\n{\n    mxClassID    mxID          = mxUNKNOWN_CLASS;\n    uint32_T     arrayFlags[2] = {0, 0};\n    int32_T      *dims         = NULL;\n    int32_T      _dims[3]      = {0, 0, 0};\n    int32_T      nDims         = 2;\n    int32_T      nBytesInItem  = 0;\n    const char_T *itemName;\n    MatItem      item;\n    int_T        retStat       = 0;\n\n    switch (itemKind) {\n      case DATA_ITEM: {\n          (void)fprintf(stderr,\"Unexpected itemKind = DATA_ITEM in \"\n                               \"rt_ProcessMatItem @A\\n\");\n          retStat = -1;\n          goto EXIT_POINT;\n      }\n      case MATRIX_ITEM: {\n          const MatrixData *var = (const MatrixData *) pItem->data;\n\n          mxID           = var->mxID;\n          arrayFlags[0]  = mxID;\n          arrayFlags[0] |= var->logical;\n          arrayFlags[0] |= var->complex;\n          if (var->nDims < 2) {\n              dims         = _dims;\n              dims[0]      = var->nRows;\n              dims[1]      = var->nCols;\n              nDims        = 2;\n          } else {\n              int32_T k;\n              dims = (int32_T*)malloc(sizeof(int32_T)*(var->nDims+1));\n              for (k = 0; k < var->nDims; k++) {\n                  dims[k] = var->dims[k];\n              }\n              dims[var->nDims] = var->nRows;\n              nDims = var->nDims + 1;\n          }\n          itemName = var->name;\n          break;\n      }\n      case STRUCT_LOG_VAR_ITEM: {\n          const StructLogVar *var = (const StructLogVar *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = 1;\n          itemName      = var->name;\n          break;\n      }\n      case SIGNALS_STRUCT_ITEM: {\n          const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = var->numSignals;\n          itemName      = &SIGNALS_FIELD_NAME;\n          break;\n      }\n      default:\n        (void)fprintf(stderr,\"Unexpected itemKind=%d in rt_ProcessMatItem @B\\n\",\n                      itemKind);\n        retStat = -1;\n        goto EXIT_POINT;\n    }\n\n    /* array flags */\n    item.nbytes = 2*sizeof(uint32_T);\n    if (cmd) {\n        item.type = matUINT32;\n        item.data = arrayFlags;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* dimensions */\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    item.nbytes = nDims*sizeof(int32_T);\n    if (cmd) {\n        item.type = matINT32;\n        item.data = dims;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* name */\n    item.nbytes = (int32_T)strlen(itemName);\n    if (cmd) {\n        item.type = matINT8;\n        item.data = (const char_T*) itemName;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        nBytesInItem += (item.nbytes <= 4) ? /*LINTED E_CAST_INT_TO_SMALL_INT*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n\n    if (itemKind == MATRIX_ITEM) {\n        const MatrixData *var   = (const MatrixData*) pItem->data;\n        int_T            matID  = rt_GetMatIdFromMxId(mxID);\n        size_t           elSize = var->elSize;\n\n        /* data */\n        item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n        if (cmd) {\n            item.type = matID;\n            item.data = var->re;\n            if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n        }\n        /* imaginary part */\n        if (var->complex) {\n            item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n            if (cmd) {\n                item.type = matID;\n                item.data = var->im;\n                if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                    retStat = 1;\n                    goto EXIT_POINT;\n                }\n            } else {\n                nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n            }\n        }\n    } else {  /* some type of structure item */\n        const char_T *fieldNames;\n        int_T        sizeofFieldNames;\n\n        /* field names */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = (const StructLogVar *) pItem->data;\n              fieldNames        = rtStructLogVarFieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n              fieldNames        = var->fieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @C\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n\n        /* write field names */\n        if (cmd) {\n            int32_T tmpInt = mxMAXNAM;\n\n            item.nbytes = sizeof(int32_T);\n            item.type   = matINT32;\n            item.data   = &tmpInt;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n\n            item.nbytes = sizeofFieldNames;\n            item.type   = matINT8;\n            item.data   = (const char_T*) fieldNames;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            /*LINTED E_CAST_INT_TO_SMALL_INT*/\n            nBytesInItem += matINT64_ALIGN( matTAG_SIZE + matTAG_SIZE +\n                                            sizeofFieldNames );\n        }\n\n        /* process each field of the structure */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = pItem->data;\n\n              /* time */\n              {\n                  const void *data = var->time;\n\n                  if (var->logTime) { /* time is a LogVar, get the MatrixData */\n                      data = &(((const LogVar*) (var->time))->data);\n                  }\n\n                  item.type = matMATRIX;\n                  item.data = data;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp,&item,MATRIX_ITEM)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM,0)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n\n              /* signals */\n              item.type = matMATRIX;\n              item.data = &(var->signals);\n              if (cmd) {\n                  if (rt_WriteItemToMatFile(fp,&item,SIGNALS_STRUCT_ITEM)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n              } else {\n                  if (rt_ProcessMatItem(fp, &item, SIGNALS_STRUCT_ITEM,0)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n                  nBytesInItem += item.nbytes + matTAG_SIZE;\n              }\n\n              /* block name */\n              if (var->blockName != NULL) {\n                  item.type = matMATRIX;\n                  item.data = var->blockName;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var        = pItem->data;\n              const LogVar        *values     = var->values;\n              const MatrixData    *dimensions = var->dimensions;\n              const MatrixData    *labels     = var->labels;\n              const MatrixData    *plotStyles = var->plotStyles;\n              const MatrixData    *titles     = var->titles;\n              const MatrixData    *blockNames = var->blockNames;\n              const MatrixData    *stateNames = var->stateNames;\n              const MatrixData    *crossMdlRef = var->crossMdlRef;\n              const MatrixData    *stateIdxList = var->stateIdxList;\n              const boolean_T logValueDimensions = var->logValueDimensions;\n              int_T               i;\n\n              for (i = 0; i < var->numSignals; i++) {\n                  /* values */\n                  item.type = matMATRIX;\n                  item.data = &(values->data);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n\n                  if(logValueDimensions)\n                  {\n                      /* valueDimensions */\n                      /* Since the functions rt_WriteItemToMatFile and\n                         rt_ProcessMatItem deal with MatrixData,\n                         convert valDims to tempData, and fill up the\n                         necessary fields.\n                      */\n                      MatrixData  tempData;\n                      (void)memcpy(tempData.name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n                      tempData.nRows = values->valDims->nRows;\n                      tempData.nCols = values->valDims->nCols;\n                      tempData.nDims = 1;\n                      tempData._dims[0] = values->valDims->nCols;\n                      tempData.re = values->valDims->dimsData;\n                      tempData.im = NULL;\n                      tempData.dTypeID = SS_DOUBLE;\n                      tempData.elSize =  sizeof(real_T);\n                      tempData.mxID = mxDOUBLE_CLASS;\n                      tempData.logical = 0;\n                      tempData.complex = 0;\n                      tempData.frameData = 0;\n                      tempData.frameSize = 1;\n\n                      item.type = matMATRIX;\n                      item.data = &tempData; /*values->valDims;*/\n\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  values = values->next;\n\n                  /* dimensions */\n                  if (dimensions != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(dimensions[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n\n                  /* label */\n                  item.type = matMATRIX;\n                  item.data = &(labels[i]);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n                  /* title */\n                  if (titles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(titles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* plot style */\n                  if (plotStyles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(plotStyles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* block name */\n                  if (blockNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(blockNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* state name */\n                  if (stateNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* crossMdlRef */\n                  if (crossMdlRef != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(crossMdlRef[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                /* stateIdxList */\n                  if (stateIdxList != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateIdxList[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n              } /* for i=1:numSignals */\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @D\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n    } /* end struct item */\n\n    if (!cmd) {\n        pItem->nbytes = nBytesInItem;\n    }\n\n  EXIT_POINT:\n    if (dims != _dims) {\n        FREE(dims);\n    }\n    return(retStat);\n\n} /* end rt_ProcessMatItem */\n\n\n/* Function: rt_WriteItemToMatFile =============================================\n * Abstract:\n *      Entry function for writing out a mat item to the mat file.\n *\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind itemKind)\n{\n    /* Determine the item size */\n    if (pItem->type == matMATRIX) {\n        if (rt_ProcessMatItem(fp, pItem, itemKind, 0)) return(1);\n    }\n\n    /* Write the item tag and data */\n    if (pItem->nbytes > 4) {\n        int32_T nAlignBytes;\n\n        if (fwrite(pItem, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n\n        if (pItem->type == matMATRIX) {\n            if (rt_ProcessMatItem(fp, pItem, itemKind, 1)) return(1);\n        } else {\n            if ( fwrite(pItem->data, 1, pItem->nbytes, fp) !=\n                                                    ((size_t) pItem->nbytes) ) {\n                return(1);\n            }\n        }\n\n        /* Add offset for 8-byte alignment */\n        nAlignBytes = matINT64_ALIGN(pItem->nbytes) - pItem->nbytes;\n        if (nAlignBytes > 0) {\n            int pad[2] = {0, 0};\n            if ( fwrite(pad,1,nAlignBytes,fp) != ((size_t) nAlignBytes) ) {\n                return(1);\n            }\n        }\n    } else {\n        MatItem item = {0, 0, NULL};\n        item.type = ((uint32_T)(pItem->type))|(((uint32_T)(pItem->nbytes))<<16);\n        (void)memcpy(&item.nbytes, pItem->data, pItem->nbytes);\n        if (fwrite(&item, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n    }\n\n    return(0);\n\n} /* end rt_WriteItemToMatFile */\n\n\n/* Function: rt_WriteMat5FileHeader ============================================\n * Abstract:\n *      Function to write the mat file header.\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteMat5FileHeader(FILE *fp)\n{\n    int_T        nbytes;\n    int_T        nspaces;\n    int_T        i, n;\n    unsigned short ver[2];\n    char_T       spaces[16];\n    const char_T *matversion = \"MATLAB 5.0 MAT-file\";\n\n    (void)memset(spaces, ' ', sizeof(spaces));\n\n    n = (int_T)strlen(matversion);\n    nbytes = (int_T)fwrite(matversion, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    nspaces = matVERSION_INFO_OFFSET - nbytes;\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces % sizeof(spaces);\n    nbytes += (int_T)fwrite(spaces, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces / sizeof(spaces);\n    for (i = 0; i < n; ++i) {\n        nbytes += (int_T)fwrite(spaces, 1, sizeof(spaces), fp);\n    }\n    if (nbytes == matVERSION_INFO_OFFSET) {\n        ver[0] = matVERSION;\n        ver[1] = matKEY;\n        nbytes += (int_T)fwrite(ver, 1, sizeof(ver), fp);\n    }\n    return(nbytes != matVERSION_INFO_OFFSET + sizeof(ver));\n\n} /* end rt_WriteMat5FileHeader */\n\n\n/* Function: rt_FixupLogVar ====================================================\n * Abstract:\n *\tMake the logged variable suitable for MATLAB.\n */\nstatic const char_T *rt_FixupLogVar(LogVar *var, boolean_T isVarDims, boolean_T finalOutput)\n{\n    int_T  nCols   = var->data.nCols;\n    int_T  maxRows = var->data.nRows;\n    int_T  nDims   = var->data.nDims;\n    size_t elSize  = var->data.elSize;\n    int_T  nRows   = (var->wrapped ?  maxRows : var->rowIdx);\n\n    var->nDataPoints = var->rowIdx + var->wrapped * maxRows;\n\n    if (finalOutput && nDims < 2 && nCols > 1) {  /* Transpose? */\n        /* Don't need to transpose valueDimensions */\n        int_T  nEl    = nRows*nCols;\n        char   *src   = var->data.re;\n        char   *pmT;\n        int_T  k;\n\n        /**********************************\n         * If memory cannot be allocated, *\n         * write to a temporary buffer    *\n         **********************************/\n        if ((pmT = malloc(nEl*elSize)) == NULL) {\n            FILE  *fptr;\n            char  fName[mxMAXNAM+13];\n\n            (void)sprintf(fName, \"%s%s\", var->data.name, \"_rtw_tmw.tmw\");\n            if ((fptr=fopen(fName,\"w+b\")) == NULL) {\n                (void)fprintf(stderr,\"*** Error opening %s\",fName);\n                return(\"unable to open data file\\n\");\n            }\n\n            /****************************\n             * Write the data to a file *\n             ****************************/\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nCols*(k%nRows) + (k/nRows);\n                char  *dst = src + kT*elSize;\n                (void)fwrite(dst, elSize, 1, fptr);\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n\n            /*******************************\n             * Read the data from the file *\n             *******************************/\n            (void)rewind(fptr);\n            (void)fread(var->data.re, elSize, nEl, fptr);\n            (void)fclose(fptr);\n            (void)remove(fName);\n        } else {\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nRows*(k%nCols) + (k/nCols);\n                char  *dst = pmT + kT*elSize;\n                (void)memcpy(dst, src, elSize);\n                src += elSize;\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n            FREE(var->data.re);\n            var->data.re = pmT;\n        }\n    } /* Transpose? */\n\n    if (var->wrapped > 0 && var->rowIdx != 0 ) {  /* Rotate? */\n        char_T *buffer    = var->data.re;\n        int_T  done       = 0; /* done: 0 (1) rotate real (imag) part. */\n\n        do {\n            char_T *col       = buffer;\n            int_T  rowOffset  = (int_T)((nDims == 1) ? (elSize) : (elSize * nCols));\n            int_T  colOffset  = (int_T)((nDims == 1)?  (nRows*elSize) : elSize);\n            int_T  zeroIdx    = var->rowIdx;\n            int_T  j;\n\n            for (j = 0 ; j < nCols; ++j, col += colOffset) {\n                int_T   swapCount;\n                int_T   srcIdx;\n                int_T   dstIdx;\n                int_T   tmpIdx;\n                MatReal tmp;\n\n                for (tmpIdx=0, swapCount=0; swapCount < nRows; tmpIdx++) {\n                    (void)memcpy(&tmp, col + tmpIdx*rowOffset, elSize);\n\n                    dstIdx=tmpIdx;\n                    srcIdx = ((dstIdx + zeroIdx) % nRows);\n                    while (srcIdx != tmpIdx) {\n                        (void)memcpy(col + dstIdx*rowOffset,\n                                     col + srcIdx*rowOffset,\n                                     elSize);\n                        ++swapCount;\n                        dstIdx = srcIdx;\n                        srcIdx = ((dstIdx + zeroIdx) % nRows);\n\n                    }\n                    (void)memcpy(col + dstIdx*rowOffset, &tmp, elSize);\n                    ++swapCount;\n                }\n            }\n            done ++;\n            /* need to rotate the imaginary part */\n        } while ((done == 1) && ((buffer = var->data.im) != NULL));\n\n        var->rowIdx = 0;\n    } /* Rotate? */\n\n    /*\n     * We might have allocated more number of rows than the number of data\n     * points that have been logged, in which case set nRows to nDataPoints\n     * so that only these values get saved.\n     */\n    if (var->nDataPoints < var->data.nRows) {\n        var->data.nRows = var->nDataPoints;\n        if (isVarDims) {\n            size_t elSizeValDims = sizeof(real_T);\n            int_T  k;\n            real_T *dimsData = var->valDims->dimsData + nRows;\n            /*\n               Keep nRows of values and that of valueDimensions consistent\n               for variable-size signals.\n            */\n            var->valDims->nRows = var->data.nRows;\n            /*\n               Also need to move data when shrinking the array size,\n               because valueDimensions data is stored in array format.\n               e.g. maxRows = 4; nRows = 2; nDims = 3;\n               Before fixing up the logVar, the locations of data are as below:\n               (x, y, z -- useful data / o -- junk)\n               a[0] = x    a[4] = y    a[8] = z\n               a[1] = x    a[5] = y    a[9] = z\n               a[2] = o    a[6] = o    a[10]= o\n               a[3] = o    a[7] = o    a[11]= o\n               After fixing up the logVar, we want the data to be stored as:\n               a[0] = x    a[4] = z    a[8] = o\n               a[1] = x    a[5] = z    a[9] = o\n               a[2] = y    a[6] = o    a[10]= o\n               a[3] = y    a[7] = o    a[11]= o\n            */\n            for(k = 1; k < nDims; k++){\n                (void) memmove(dimsData,\n                              var->valDims->dimsData + k*maxRows,\n                              elSizeValDims * nRows);\n                dimsData += nRows;\n            }\n        }\n    }\n    return(NULL);\n\n} /* end rt_FixupLogVar */\n\n\n/* Function: rt_LoadModifiedLogVarName =========================================\n * Abstract:\n *      The name of the logged variable is obtained from the input argument\n *      varName and the nameModifier which is obtained from the simstruct. If\n *      the nameModifier begins with an '_', then nameModifier is post-pended to\n *      varName to obtain the name of the logged variable. If the first\n *      character does not begin with an '_', then the nameModifier is\n *      pre-pended to varName.\n *\n * Examples:\n *     a)  varName = \"tout\" & nameModifier = \"_rt\"  => logVarName = \"tout_rt\"\n *     b)  varName = \"tout\" & nameModifier = \"rt_\"  => logVarName = \"rt_tout\"\n *     c)  varName = \"tout\" & nameModifier = \"none\" => logVarName = \"tout\"\n */\nstatic void rt_LoadModifiedLogVarName(const RTWLogInfo *li,         /* in  */\n                                      const char       *varName,    /* in  */\n                                      char             *logVarName) /* out */\n{\n    int_T        nameLen;\n    const char_T *nameModifier = rtliGetLogVarNameModifier(li);\n\n    if (nameModifier != NULL && strcmp(nameModifier,\"none\")==0) {\n        nameModifier = NULL;\n    }\n\n    logVarName[mxMAXNAM-1] = '\\0';\n    if (nameModifier == NULL) {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n    } else if (nameModifier[0] == '_') {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, nameModifier, (size_t)mxMAXNAM-1-nameLen);\n    } else {\n        (void)strncpy(logVarName, nameModifier, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, varName, (size_t)mxMAXNAM-1-nameLen);\n    }\n\n} /* end rt_LoadModifiedLogVarName */\n\n\n/* Function: rt_GetActualDTypeID ===============================================\n * Abstract:\n *\tGiven a built-in data type id, return the actual data type id.\n *\tThe only time these are different is when real_T has been mapped\n *\tto a single.\n */\n#if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable: 4127)\n#endif\nstatic BuiltInDTypeId rt_GetActualDTypeID(BuiltInDTypeId dTypeID)\n{\n    /*LINTED E_FALSE_LOGICAL_EXPR*/\n    if (dTypeID == SS_DOUBLE && sizeof(real_T) != 8) {     /* polyspace DEFECT:DEAD_CODE\n                                                              [Not a defect:Unset]\n                                                              \"Needed for when real_T has been\n                                                              mapped to a single\" */\n        return(SS_SINGLE);\n    } else {\n        return(dTypeID);\n    }\n\n} /* end rt_GetActualDTypeID */\n#if defined(_MSC_VER)\n #pragma warning(pop)\n#endif\n\n\n/* Function: rt_DestroyLogVar ==================================================\n * Abstract:\n *      Destroy the log var linked list.\n */\nstatic void rt_DestroyLogVar(LogVar *head)\n{\n    while(head) {\n        LogVar *var = head;\n        head = var->next;\n        FREE(var->data.re);\n        FREE(var->data.im);\n        if (var->data.dims != var->data._dims) {\n            FREE(var->data.dims);\n        }\n        /* free valDims if necessary */\n        if(var->valDims != NULL) {\n            FREE(var->valDims->dimsData);\n            FREE(var->valDims);\n        }\n        /* free coords, strides and currStrides if necessary */\n        FREE(var->coords);\n        FREE(var->strides);\n        FREE(var->currStrides);\n\n        FREE(var);\n    }\n\n} /* end rt_DestroyLogVar */\n\n\n/* Function: rt_DestroyStructLogVar ============================================\n * Abstract:\n *      Destroy the struct log var linked list.\n */\nstatic void rt_DestroyStructLogVar(StructLogVar *head)\n{\n    while(head) {\n        StructLogVar *var = head;\n\n        head = var->next;\n\n        if (var->logTime) { /* time is LogVar */\n            rt_DestroyLogVar(var->time);\n        } else {        /* time is MatrixData */\n            FREE(var->time);\n        }\n        rt_DestroyLogVar(var->signals.values);\n        FREE(var->signals.labels);\n        FREE(var->signals.plotStyles);\n        FREE(var->signals.dimensions);\n        FREE(var->signals.titles);\n        FREE(var->signals.blockNames);\n        FREE(var->signals.stateNames);\n        FREE(var->signals.crossMdlRef);\n        FREE(var->signals.stateIdxList);\n        FREE(var->blockName);\n        FREE(var);\n    }\n\n} /* end rt_DestroyStructLogVar */\n\n\n/* Function: rt_InitSignalsStruct ==============================================\n * Abstract:\n *      Initialize the signals structure in the struct log variable.\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nstatic const char_T *rt_InitSignalsStruct(RTWLogInfo             *li,\n                                          const real_T           startTime,\n                                          const real_T           finalTime,\n                                          const real_T           inStepSize,\n                                          const char_T           **errStatus,\n                                          StructLogVar           *var,\n                                          int_T                  maxRows,\n                                          int_T                  decimation,\n                                          real_T                 sampleTime,\n                                          const RTWLogSignalInfo *sigInfo,\n                                          boolean_T isStateIdxListRequired)\n{\n    int_T                i, sigIdx;\n    SignalsStruct        *sig          = &(var->signals);\n    int_T                nSignals      = sigInfo->numSignals;\n    const int_T          *numCols      = sigInfo->numCols;\n    const int_T          *numDims      = sigInfo->numDims;\n    const int_T          *dims         = sigInfo->dims;\n    const BuiltInDTypeId *dTypes       = sigInfo->dataTypes;\n    const int_T          *cSgnls       = sigInfo->complexSignals;\n    const int_T          *fData        = sigInfo->frameData;\n    const char_T         **labels      = sigInfo->labels.cptr;\n    const int_T          *plotStyles   = sigInfo->plotStyles;\n    const char_T         *titles       = sigInfo->titles;\n    const int_T          *titleLen     = sigInfo->titleLengths;\n    const char_T         **blockNames  = sigInfo->blockNames.cptr;\n    const char_T         **stateNames  = sigInfo->stateNames.cptr;\n    const boolean_T      *crossMdlRef  = sigInfo->crossMdlRef;\n    const int_T          *stateIdxList    = sigInfo->stateIdxList;\n    void                 **currSigDims = sigInfo->currSigDims;\n    int_T                *currSigDimsSize = sigInfo->currSigDimsSize;\n    LogVar               *prevValues   = NULL;\n    int_T                dimsOffset    = 0;\n    boolean_T            *isVarDims    = sigInfo->isVarDims;\n    /* if any signal is variable-size, the field 'valueDimensions' is needed */\n    boolean_T            logValueDimensions = false;\n    const RTWLogDataTypeConvert *pDTConvInfo = sigInfo->dataTypeConvert;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    sig->numActiveFields = 1;\n    sig->numSignals      = nSignals;\n\n    sig->isVarDims = isVarDims;\n    /* check whether we need valueDimensions field*/\n    for (i=0; i<nSignals; i++){\n        if(isVarDims[i]){\n            logValueDimensions = true;\n            break;\n        }\n    }\n\n    /* values */\n    dimsOffset = 0;\n    for (i = 0; i < nSignals; i++) {\n        BuiltInDTypeId dt = (dTypes) ? dTypes[i] : SS_DOUBLE;\n        int_T          cs = (cSgnls) ? cSgnls[i] : 0;\n        int_T          fd = (fData)  ? fData[i]  : 0;\n        int_T          nd = (numDims) ? numDims[i] : 1;\n\n        const RTWLogDataTypeConvert *pDTConvInfoCur =\n                       (pDTConvInfo)  ? (pDTConvInfo+i)  : 0;\n\n        LogVar *values = NULL;\n        LogValDimsStat logValDimsStat;\n\n        if(!logValueDimensions){\n            logValDimsStat = NO_LOGVALDIMS;\n        }\n        else{\n            logValDimsStat = isVarDims[i] ? LOGVALDIMS_VARDIMS :\n                                            LOGVALDIMS_EMPTYMX;\n        }\n\n        values = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                            inStepSize, errStatus,\n                                            &VALUES_FIELD_NAME,\n                                            dt,\n                                            pDTConvInfoCur,\n                                            0, cs, fd,\n                                            numCols[i],nd,\n                                            dims + dimsOffset,\n                                            logValDimsStat,\n                                            currSigDims + dimsOffset,\n                                            currSigDimsSize + dimsOffset,\n                                            maxRows,decimation,sampleTime, 0);\n\n        if (values == NULL) goto ERROR_EXIT;\n\n        if (sig->values == NULL) {\n            sig->values = values;\n        } else {\n            if (prevValues == NULL) goto ERROR_EXIT;\n            prevValues->next = values;\n        }\n        prevValues = values;\n        dimsOffset += nd;\n    }\n\n    if(logValueDimensions){\n        ++sig->numActiveFields;\n        sig->logValueDimensions = true;\n    }\n    else{\n        sig->logValueDimensions = false;\n    }\n\n    /* Dimensions */\n    {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            int_T nd = (numDims) ? numDims[i] : 1;\n            dataLen += nd;\n        }\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->dimensions = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->dimensions)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n          data[i] = dims[i]; /* cannot memcpy double <- int */\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->dimensions[i]);\n            int_T nd = (numDims) ? numDims[i] : 1;\n\n            (void)memcpy(mtxData->name, &DIMENSION_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = 1;\n            mtxData->nCols   = nd;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += nd;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* labels */\n    if (labels != NULL) {\n        unsigned short   *data;\n        size_t  nbytes;\n        int_T   dataLen    = 0;\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (labels[i] != NULL){\n                dataLen = dataLen + (int_T)strlen(labels[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->labels = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->labels)) + dataOffset);\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T labelLen = (labels[sigIdx]==NULL) ? 0 : (int_T)strlen(labels[sigIdx]);\n            for (i = 0; i < labelLen; i++) {\n                data[dataIdx++] = (uint8_T)labels[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->labels[i]);\n            int_T labelLen = (int_T)strlen(labels[i]);\n\n            (void)memcpy(mtxData->name, &LABEL_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (labelLen) ? 1 : 0;\n            mtxData->nCols   = labelLen;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += labelLen;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* plot styles */\n    if (plotStyles != NULL) {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            dataLen += numCols[i];\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->plotStyles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (real_T*) (((char_T*) (sig->plotStyles)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n            data[i] = plotStyles[i];\n        }\n\n        dimsOffset = 0;\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->plotStyles[i]);\n\n            (void)memcpy(mtxData->name, &PLOTSTYLE_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = (numCols[i]) ? 1 : 0;\n            mtxData->nCols   = numCols[i];\n\n            mtxData->nDims   = numDims[i];\n\n            if(mtxData->nDims > 2) {\n                if ((mtxData->dims = calloc(mtxData->nDims, sizeof(int_T))) == NULL) goto ERROR_EXIT;\n            } else {\n                mtxData->dims    = mtxData->_dims;\n            }\n\n            mtxData->dims[0] = *(dims + dimsOffset);\n            if(mtxData->nDims >= 2) {\n                int32_T j;\n                for (j=1; j<mtxData->nDims; j++) {\n                    mtxData->dims[j] = *(dims + dimsOffset + j);\n                }\n            }\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data       += numCols[i];\n            dimsOffset += numDims[i];\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* titles */\n    if (titles != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen    = (int_T)strlen(titles);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->titles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (unsigned short*) (((char_T*) (sig->titles)) + dataOffset);\n        for (i = 0; i < dataLen; i++) {\n            data[i] = titles[i];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->titles[i]);\n\n            (void)memcpy(mtxData->name, &TITLE_FIELD_NAME, mxMAXNAM);\n            if (titleLen) {\n                mtxData->nRows   = (titleLen[i]) ? 1 : 0;\n                mtxData->nCols   = titleLen[i];\n            } else {\n                mtxData->nRows   = (dataLen) ? 1 : 0;\n                mtxData->nCols   = dataLen;\n            }\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += ((titleLen) ? titleLen[i] : dataLen);\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* block names */\n    if (blockNames != NULL)     {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (blockNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(blockNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->blockNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->blockNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (blockNames[sigIdx]==NULL) ? 0 :\n                (int_T)strlen(blockNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)blockNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->blockNames[i]);\n            int_T blockNameLen = (int_T)strlen(blockNames[i]);\n\n            (void)memcpy(mtxData->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (blockNameLen) ? 1 : 0;\n            mtxData->nCols   = blockNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += blockNameLen;\n        }\n        ++sig->numActiveFields;\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    } else {\n        if(logValueDimensions){\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* state names */\n    if (stateNames != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (stateNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(stateNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->stateNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->stateNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (stateNames[sigIdx]==NULL) ? 0 :\n                (int_T)strlen(stateNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)stateNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateNames[i]);\n            int_T stateNameLen = (int_T)strlen(stateNames[i]);\n\n            (void)memcpy(mtxData->name, &STATENAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (stateNameLen) ? 1 : 0;\n            mtxData->nCols   = stateNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += stateNameLen;\n        }\n        ++sig->numActiveFields;\n\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* CrossMdlRef */\n    if (crossMdlRef != NULL) {\n        real_T  *data;\n        size_t nbytes;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->crossMdlRef = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->crossMdlRef)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = crossMdlRef[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->crossMdlRef[i]);\n\n            (void)memcpy(mtxData->name, &CROSS_MDL_REF_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_DOUBLE;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(SS_DOUBLE);\n            mtxData->elSize  = sizeof(real_T);\n            mtxData->logical = matLOGICAL_BIT;\n            mtxData->complex = 0U;\n            mtxData->frameData = 0;\n            mtxData->frameSize = 1;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* stateIdxList */\n    if (stateIdxList != NULL && isStateIdxListRequired) {\n        real_T  *data;\n        size_t nbytes;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(int_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->stateIdxList = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->stateIdxList)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = stateIdxList[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateIdxList[i]);\n\n            (void)memcpy(mtxData->name, &STATE_INDEX_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);;\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n        }\n        ++sig->numActiveFields;\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n\n    (void)fprintf(stderr, \"*** Error creating signals structure \"\n                  \"in the struct log variable %s\\n\", var->name);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyLogVar(sig->values);\n    FREE(sig->labels);\n    FREE(sig->plotStyles);\n    FREE(sig->dimensions);\n    FREE(sig->titles);\n    FREE(sig->blockNames);\n    FREE(sig->stateNames);\n    FREE(sig->crossMdlRef);\n\n    FREE(sig->stateIdxList);\n\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\n\n/* Function: local_CreateStructLogVar ==========================================\n * Abstract:\n *      Create a logging variable in the structure format.\n *\n * Returns:\n *      ~= NULL  => success, returns the log variable created.\n *      == NULL  => failure, error message set in the simstruct.\n */\nstatic StructLogVar *local_CreateStructLogVar(\n    RTWLogInfo              *li,\n    const real_T            startTime,\n    const real_T            finalTime,\n    const real_T            inStepSize,\n    const char_T            **errStatus,\n    const char_T            *varName,\n    boolean_T               logTime,\n    int_T                   maxRows,\n    int_T                   decimation,\n    real_T                  sampleTime,\n    const RTWLogSignalInfo  *sigInfo,\n    const char_T            *blockName,\n    boolean_T               isStateIdxListRequired)\n{\n    StructLogVar *var;\n    LogInfo      *logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ( (var = calloc(1, sizeof(StructLogVar))) == NULL ) goto ERROR_EXIT;\n\n    var->numActiveFields = 2;\n\n    /* Setup the structure name using varName and nameModifier */\n    rt_LoadModifiedLogVarName(li,varName,var->name);\n\n    /* time field */\n    if (logTime) {\n        /* need to create a LogVar to log time */\n        int_T dims = 1;\n        var->time = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                               inStepSize, errStatus,\n                                               &TIME_FIELD_NAME, SS_DOUBLE,\n                                               NULL,\n                                               0, 0, 0, 1,\n                                               1, &dims, NO_LOGVALDIMS,\n                                               NULL, NULL, maxRows,\n                                               decimation, sampleTime, 0);\n        if (var->time == NULL) goto ERROR_EXIT;\n    } else {\n        /* create a dummy MatrixData to write out time as an empty matrix */\n        BuiltInDTypeId dt     = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         nbytes = sizeof(MatrixData);\n        MatrixData     *time;\n\n        if ( (var->time = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n        time = var->time;\n\n        (void)memcpy(time->name, &TIME_FIELD_NAME, mxMAXNAM);\n        time->nRows   = 0;\n        time->nCols   = 0;\n        time->nDims   = 0;\n        time->re      = NULL;\n        time->im      = NULL;\n        time->dTypeID = dt;\n        time->mxID    = rt_GetMxIdFromDTypeId(dt);\n        time->elSize  = rt_GetSizeofDataType(dt);\n        time->logical = 0U;\n        time->complex = 0U;\n    }\n    var->logTime = logTime;\n\n    /* signals field */\n    if (sigInfo) {\n        if (rt_InitSignalsStruct(li,startTime,finalTime,inStepSize,errStatus,\n                                 var,maxRows,decimation,sampleTime,sigInfo, isStateIdxListRequired)) {\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* blockName Field */\n    if (blockName != NULL) {\n        int_T  dataLen = (int_T)strlen(blockName);\n        size_t nbytes;\n        size_t dataOffset = sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset]\n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (var->blockName = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        (void)memcpy(var->blockName->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n        var->blockName->nRows   = (dataLen) ? 1 : 0;\n        var->blockName->nCols   = dataLen;\n\n        var->blockName->nDims   = 1;\n        var->blockName->dims    = var->blockName->_dims;\n        var->blockName->dims[0] = dataLen;\n        {\n            /*LINTED E_BAD_PTR_CAST_ALIGN*/\n            unsigned short *data = (unsigned short*)(((char_T*) (var->blockName))+dataOffset);\n            int_T   i;\n\n            for (i=0; i<dataLen; i++) {\n                data[i] = (uint8_T)blockName[i];\n            }\n            var->blockName->re  = data;\n        }\n        var->blockName->im      = NULL;\n        var->blockName->dTypeID = SS_INT16;\n        var->blockName->mxID    = mxCHAR_CLASS;\n        var->blockName->elSize  = sizeof(short);\n        var->blockName->logical = 0U;\n        var->blockName->complex = 0U;\n\n        ++var->numActiveFields;\n    }\n\n    /* Add this struct log var to the linked list in log info */\n    {\n        StructLogVar *list = logInfo->structLogVarsList;\n\n        if (list != NULL) {\n            while (list->next != NULL) {\n                list = list->next;\n            }\n            list->next = var;\n        } else {\n            logInfo->structLogVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Error creating log variable %s\\n\", varName);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyStructLogVar(var);\n    return(NULL);\n\n} /* end local_CreateStructLogVar */\n\n\n/* Function: rt_StartDataLoggingForOutput ======================================\n * Abstract:\n */\nstatic const char_T *rt_StartDataLoggingForOutput(RTWLogInfo   *li,\n                                                  const real_T startTime,\n                                                  const real_T finalTime,\n                                                  const real_T stepSize,\n                                                  const char_T **errStatus)\n{\n    const char_T   *varName;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2 || logFormat == 3) ? 1 : 0;\n\n    LogInfo *       logInfo;\n    logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    /* outputs */\n    varName = rtliGetLogY(li);\n    if (varName[0] != '\\0') {\n        int_T                  i;\n        int_T                  ny;\n        int_T                  yIdx;\n        char_T                 name[mxMAXNAM];\n        const char_T           *cp        = strchr(varName,',');\n        LogSignalPtrsType      ySigPtrs   = rtliGetLogYSignalPtrs(li);\n        const RTWLogSignalInfo *yInfo     = rtliGetLogYSignalInfo(li);\n\n        /* count the number of variables (matrices or structures) to create */\n        for (ny=1; cp != NULL; ny++) {\n            cp = strchr(cp+1,',');\n        }\n        logInfo->ny = ny;\n\n        if (logFormat==0) {\n            if ( (logInfo->y = calloc(ny,sizeof(LogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        } else {\n            if ( (logInfo->y = calloc(ny,sizeof(StructLogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        }\n\n        for (i = yIdx = 0, cp = varName; i < ny; i++) {\n            int_T        len;\n            const char_T *cp1 = strchr(cp+1,',');\n\n            if (cp1 != NULL) {\n                /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n                len = (int_T)(cp1 - cp);\n                if (len >= mxMAXNAM) len = mxMAXNAM - 1;\n            } else {\n                len = mxMAXNAM - 1;\n            }\n            (void)strncpy(name, cp, len);\n            name[len] = '\\0';\n\n            if (ny > 1 && ySigPtrs[i] == NULL) {\n                goto NEXT_NAME;\n            }\n\n            if (logFormat == 0) {\n                int            numCols;\n                int            nDims;\n                const int      *dims;\n                BuiltInDTypeId dataType;\n                int            isComplex;\n\n                if (ny == 1) {\n                    int_T op;\n\n                    numCols = yInfo[0].numCols[0];\n                    for (op = 1; op < yInfo[0].numSignals; op++) {\n                        numCols += yInfo[0].numCols[op];\n                    }\n                    /*\n                     * If we have only one \"matrix\" outport,\n                     * we can still log it as a matrix\n                     */\n                    if (yInfo[0].numSignals == 1) {\n                        nDims = yInfo[0].numDims ? yInfo[0].numDims[0] : 1;\n                        dims  = yInfo[0].dims;\n                    } else {\n                        nDims = 1;\n                        dims  = &numCols;\n                    }\n\n                    dataType  = yInfo[0].dataTypes[0];\n                    isComplex = yInfo[0].complexSignals[0];\n                } else {\n                    numCols   = yInfo[yIdx].numCols[0];\n                    nDims     = yInfo[yIdx].numDims ? yInfo[yIdx].numDims[0] : 1;\n                    dims      = yInfo[yIdx].dims;\n                    dataType  = yInfo[yIdx].dataTypes[0];\n                    isComplex = yInfo[yIdx].complexSignals[0];\n                }\n\n                logInfo->y[yIdx] = rt_CreateLogVarWithConvert(\n                    li, startTime, finalTime,\n                    stepSize, errStatus,\n                    name,\n                    dataType,\n                    yInfo[yIdx].dataTypeConvert,\n                    0,isComplex,\n                    0,numCols,nDims,dims,\n                    NO_LOGVALDIMS, NULL, NULL,\n                    maxRows,decimation,\n                    sampleTime,1);\n                if (logInfo->y[yIdx] == NULL)  goto ERROR_EXIT;\n            } else {\n                logInfo->y[yIdx] = local_CreateStructLogVar(li, startTime,\n                                                            finalTime, stepSize,\n                                                            errStatus, name,\n                                                            logTime, maxRows,\n                                                            decimation, sampleTime,\n                                                            &yInfo[yIdx], NULL, false);\n                if (logInfo->y[yIdx] == NULL) goto ERROR_EXIT;\n            }\n            ++yIdx;\n        NEXT_NAME:\n            cp = cp1;\n            if (cp != NULL && *cp == ',') cp++;\n        }\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) { /* polyspace DEFECT:USELESS_IF [No action planned:Unset]\n                     \"Defense coding.\" */\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingForOutput */\n\n\n/* Function: rt_ReallocLogVar ==================================================\n * Abstract:\n *   Allocate more memory for the data buffers in the log variable.\n *   Exit if unable to allocate more memory.\n */\nstatic void rt_ReallocLogVar(LogVar *var, boolean_T isVarDims)\n{\n    void *tmp;\n    int_T nCols = var->data.nCols;\n    int_T nRows;\n    size_t elSize = var->data.elSize;\n\n    if (isVarDims)\n    {\n        nRows = var->data.nRows + DEFAULT_BUFFER_SIZE;\n    }\n    else\n    {\n        nRows = var->data.nRows == 0 ? 1 : 2*var->data.nRows;\n    }\n\n    tmp = realloc(var->data.re, nRows*nCols*elSize);\n    if (tmp == NULL) {\n        (void)fprintf(stderr,\n                      \"*** Memory allocation error.\\n\");\n        (void)fprintf(stderr, \"\"\n                      \"    varName          = %s%s\\n\"\n                      \"    nRows            = %d\\n\"\n                      \"    nCols            = %d\\n\"\n                      \"    elementSize      = %lu\\n\"\n                      \"    Current Size     = %.16g\\n\"\n                      \"    Failed resize    = %.16g\\n\\n\",\n                      var->data.name,\n                      var->data.complex ? \" (real part)\" : \"\",\n                      var->data.nRows,\n                      var->data.nCols,\n                      (unsigned long)  var->data.elSize,\n                      (double)nRows*nCols*elSize,\n                      (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n        exit(1);\n    }\n    var->data.re = tmp;\n\n    if (var->data.complex) {\n        tmp = realloc(var->data.im, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s (complex part)\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->data.name,\n                          var->data.nRows,\n                          var->data.nCols,\n                          (unsigned long)  var->data.elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n        var->data.im = tmp;\n    }\n    var->data.nRows = nRows;\n\n    /* Also reallocate memory for \"valueDimensions\"\n       when logging the variable-size signal\n    */\n    if(isVarDims){\n        int_T k;\n\n        nCols = var->valDims->nCols;\n        nRows = var->valDims->nRows + DEFAULT_BUFFER_SIZE;\n        elSize = sizeof(real_T);\n        tmp = realloc(var->valDims->dimsData, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->valDims->name,\n                          var->valDims->nRows,\n                          var->valDims->nCols,\n                          (unsigned long)  elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n\n        /*\n         * valueDimensions data is stored in array format and must be\n         * adjusted after reallocation (see also rt_FixupLogVar())\n         *\n         * Example: maxRows = 4; nRows = 4; nDims = 3;\n         * Before realloc of the logVar, the locations of data are as below:\n         * (x, y, z -- useful data / o -- junk, don't care)\n         * a[0] = x    a[4] = y    a[8] = z\n         * a[1] = x    a[5] = y    a[9] = z\n         * a[2] = x    a[6] = y    a[10]= z\n         * a[3] = x    a[7] = y    a[11]= z\n         *\n         * After realloc of the logVar (suppose 2 extra rows are added),\n         * the locations of data are as below:\n         * a[0] = x    a[6] = y    a[12]= o\n         * a[1] = x    a[7] = y    a[13]= o\n         * a[2] = x    a[8] = z    a[14]= o\n         * a[3] = x    a[9] = z    a[15]= o\n         * a[4] = y    a[10]= z    a[16]= o\n         * a[5] = y    a[11]= z    a[17]= o\n         *\n         * The data must be adjusted as below:\n         * a[0] = x    a[6] = y    a[12]= z\n         * a[1] = x    a[7] = y    a[13]= z\n         * a[2] = x    a[8] = y    a[14]= z\n         * a[3] = x    a[9] = y    a[15]= z\n         * a[4] = o    a[10]= o    a[16]= o\n         * a[5] = o    a[11]= o    a[17]= o\n         */\n        for(k = var->data.nDims-1; k > 0; k--){\n            (void) memcpy((real_T*)tmp + k*nRows,\n                          (real_T*)tmp + k*var->valDims->nRows,\n                          elSize * var->valDims->nRows);\n        }\n\n        var->valDims->dimsData = tmp;\n        var->valDims->nRows = nRows;\n    }\n\n} /* end rt_ReallocLogVar */\n\n/* Function: rt_UpdateLogVarWithDiscontinuousData ==============================\n * Abstract:\n *      Log one row of the LogVar with data that is not contiguous.\n */\nstatic const char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                                          int8_T**               data,\n                                                          const int_T            *segmentLengths,\n                                                          int_T                  nSegments)\n{\n    size_t elSize = 0;\n    size_t offset = 0;\n    int    segIdx = 0;\n\n    if (++var->numHits % var->decimation) return(NULL);\n    var->numHits = 0;\n\n    /*\n     * Reallocate or wrap the LogVar\n     */\n    if (var->rowIdx == var->data.nRows) {\n        if (var->okayToRealloc == 1) {\n            rt_ReallocLogVar(var, false);\n        } else {\n            /* Circular buffer */\n            var->rowIdx = 0;\n            ++(var->wrapped); /* increment the wrap around counter */\n        }\n    }\n\n    /* This function is only used to log states, there's no var-dims issue. */\n    elSize = var->data.elSize;\n    offset = (size_t)(elSize * var->rowIdx * var->data.nCols);\n\n    if (var->data.complex) {\n        char_T *dstRe = (char_T*)(var->data.re) + offset;\n        char_T *dstIm = (char_T*)(var->data.im) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            int_T         nEl = segmentLengths[segIdx];\n            const char_T* src = (const char_T*)data[segIdx];\n            int_T         el;\n\n            for (el = 0; el < nEl; el++) {\n                (void)memcpy(dstRe, src, elSize);\n                dstRe += elSize;   src += elSize;\n                (void)memcpy(dstIm, src, elSize);\n                dstIm += elSize;   src += elSize;\n            }\n        }\n    } else {\n        char_T *dst = (char_T*)(var->data.re) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            size_t segSize = elSize*segmentLengths[segIdx];\n            (void)memcpy(dst, data[segIdx], segSize);\n            dst += segSize;\n        }\n    }\n\n    ++var->rowIdx;\n    return(NULL);\n\n} /* end rt_UpdateLogVarWithDiscontinuousData */\n\n\n/*==================*\n * Visible routines *\n *==================*/\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVarWithConvert ========================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList)\n{\n    int_T          usingDefaultBufSize = 0;\n#ifdef NO_LOGGING_REALLOC\n    int_T          okayToRealloc       = 0;\n#else\n    int_T          okayToRealloc       = 1;\n#endif\n    LogVar         *var                = NULL;\n    /*inpDataTypeID is the rt_LoggedOutputDataTypeId*/\n    BuiltInDTypeId dTypeID             = (BuiltInDTypeId)inpDataTypeID;\n    size_t         elementSize         = rt_GetSizeofDataType(dTypeID);\n    int_T          frameSize;\n    int_T          nRows;\n    int_T          nColumns;\n\n    /*===================================================================*\n     * Determine the frame size if the data is frame based               *\n     *===================================================================*/\n    frameSize = frameData ? dims[0] : 1;\n\n    /*===================================================================*\n     * Calculate maximum number of rows needed in the buffer             *\n     *===================================================================*/\n\n    if (finalTime > startTime && finalTime != rtInf) {\n        real_T nPoints;            /* Tfinal is finite  ===>  nRows can be  */\n        real_T stepSize;           /* computed since the StepSize is fixed  */\n\n        if (sampleTime == -2.0) {  /* The signal being logged is constant,  *\n                                    * Hence, only one data point is logged. */\n            stepSize = finalTime;\n        } else if (sampleTime == -1.0 || sampleTime == 0.0) {\n                                /* Signal being logged is either inside a    *\n                                 * triggered sub-system or it is continuous. */\n            stepSize = inStepSize;\n        } else {                /* Discrete signal */\n            stepSize = sampleTime;\n        }\n\n        if (stepSize == 0.0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {\n            nPoints = 1.0 + floor((finalTime-startTime)/stepSize);\n\n            /*\n             * Add one more data point if needed.\n             */\n            if ( stepSize*(nPoints-1.0) < (finalTime-startTime) ) {\n                nPoints += 1.0;\n            }\n\n            /*\n             * Actual number of points to log = nPoints * size of\n             * each frame if data is frame-based\n             */\n            nPoints = frameData ? (nPoints * frameSize) : nPoints;\n\n            nPoints /= decimation;\n            if (nPoints != floor(nPoints)) {\n                nPoints += 1.0;\n            }\n            nRows = (nPoints <= INT_MAX) ? ((int_T) nPoints) : INT_MAX;\n        }\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (finalTime == startTime) {\n        /*\n         * Number of rows to log is equal to 1 if not frame-based and\n         * equal to frame size if frame-based\n         */\n        nRows = frameData ? frameSize : 1;\n\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (maxRows > 0) {     /* maxRows is specified => nRows=maxRows  */\n        nRows = maxRows;\n        okayToRealloc = 0;\n    } else {\n\n        if (inStepSize == 0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {                    /* Use a default value for nRows          */\n            usingDefaultBufSize = 1;\n            nRows = DEFAULT_BUFFER_SIZE;\n            okayToRealloc = 0;  /* No realloc with infinite stop time */\n            (void)fprintf(stdout, \"*** Using a default buffer of size %d for \"\n                          \"logging variable %s\\n\", nRows, varName);\n        }\n    }\n\n    /*\n     * Figure out the number of columns that the log variable should have.\n     * If the data is not frame based, then number of columns should equal\n     * nCols that is provided as input to the function. If the data is\n     * frame-based, then the number of columns should be equal to the\n     * number of channels = nCols/frameSize = dims[1];\n     */\n    nColumns = frameData ? dims[1] : nCols;\n\n    /*\n     * Error out if the size of the circular buffer is absurdly large, this\n     * error message is more informative than the one we get when we try to\n     * malloc this many number of bytes in one fell swoop.\n     */\n    {\n        double tmpDbl = ((double)elementSize)*((double)nRows)*\n                                              ((double)nColumns);\n\n        if (tmpDbl >= UINT_MAX) {\n            (void)fprintf(stderr,\n                          \"\\n*** Memory required to log variable '%s' is too\"\n                          \"\\n    big. Use the 'Limit rows to last:' and (or)\"\n                          \"\\n    'Decimation:' options to reduce the required\"\n                          \"\\n    memory size.\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Required  = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long)\n                          elementSize, tmpDbl);\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* Allocate memory for the log variable */\n    if ( (var = calloc(1, sizeof(LogVar))) == NULL ) {\n        (void)fprintf(stderr, \"*** Error allocating memory for logging %s\\n\",\n                      varName);\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer (real part) */\n    if ( (var->data.re = malloc(nRows*nColumns*elementSize)) == NULL ) {\n        (void)fprintf(stderr,\n                      \"*** Error allocating memory for the circular buffer\\n\");\n        (void)fprintf(stderr, \"*** Details:\\n\"\n                      \"       varName         = %s\\n\"\n                      \"       nRows           = %d\\n\"\n                      \"       nCols           = %d\\n\"\n                      \"       elementSize     = %lu\\n\"\n                      \"       Bytes Requested = %.16g\\n\\n\",\n                      varName, nRows, nColumns, (unsigned long) elementSize,\n                      ((double)elementSize)*((double)nRows)*((double)nColumns));\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer for the imaginary part */\n    if (complex) {\n        if ( (var->data.im = malloc(nRows*nColumns*elementSize)) == NULL ) {\n            (void)fprintf(stderr,\n                          \"*** Error allocating memory for the circular buffer \"\n                          \"for logging the imaginary part of %s\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Requested = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long) elementSize,\n                          ((double)elementSize)*((double)nRows)*\n                                                 ((double)nColumns));\n            goto ERROR_EXIT;\n        }\n    }\n    /*\n     * Initialize the fields in LogVar structure.\n     */\n    if (appendToLogVarsList) {\n        rt_LoadModifiedLogVarName(li,varName,var->data.name);\n    } else {\n        var->data.name[mxMAXNAM-1] = '\\0';\n        (void)strncpy(var->data.name,varName,mxMAXNAM-1);\n    }\n    var->data.nCols           = nColumns;\n    var->data.nRows           = nRows;\n\n    var->data.nDims           = frameData ? 1 : nDims;\n    if (var->data.nDims > 2) {\n        var->data.dims = (int_T*)malloc(sizeof(int_T)*var->data.nDims);\n    } else {\n        var->data.dims = var->data._dims;\n    }\n    if (frameData) {\n        var->data.dims[0] = nColumns;\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        (void)memcpy(var->data.dims, dims, (size_t)(nDims*sizeof(int_T)));\n    }\n\n    var->data.dTypeID         = dTypeID;\n    var->data.elSize          = elementSize;\n\n    var->data.dataTypeConvertInfo = rt_GetDataTypeConvertInfo(\n        pDataTypeConvertInfo, dTypeID);\n\n    var->data.mxID            = rt_GetMxIdFromDTypeId(dTypeID);\n    /* over-ride logical bit if data type is boolean */\n    logical = dTypeID == SS_BOOLEAN ? 1 : 0;\n    var->data.logical         = (logical)   ? matLOGICAL_BIT : 0x0;\n    var->data.complex         = (complex)   ? matCOMPLEX_BIT : 0x0;\n    var->data.frameData       = frameData;\n    var->data.frameSize       = (frameData) ? frameSize : 1;\n\n    /* fill up valDims field */\n    if(logValDimsStat == NO_LOGVALDIMS){\n        /* All signals are fixed-size, no need to log valueDimensions field */\n        var->valDims     = NULL;\n        /* Set these pointers to NULLs in this case */\n        var->coords      = NULL;\n        var->strides     = NULL;\n        var->currStrides = NULL;\n    }\n    else{\n        if ( (var->valDims = calloc(1, sizeof(ValDimsData))) == NULL ) {\n            goto ERROR_EXIT;\n        }\n\n        (void)memcpy(var->valDims->name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n\n        if (logValDimsStat == LOGVALDIMS_EMPTYMX) {\n            /* At least one signal is variable-size,\n               but the current signal is fixed-size.\n               Therefore, create a dummy MatrixData to write out valueDimensions\n               as an empty matrix.\n            */\n            var->valDims->nRows = 0;\n            var->valDims->nCols = 0;\n            var->valDims->currSigDims = NULL;\n            var->valDims->currSigDimsSize = NULL;\n            var->valDims->dimsData = NULL;\n            /* Set these pointers to NULLs in this case */\n            var->coords      = NULL;\n            var->strides     = NULL;\n            var->currStrides = NULL;\n        } else { /* The current signal is a variable-size signal. */\n            /* The \"valueDimensions\" must be double, so re-assign element size */\n            elementSize = sizeof(real_T);\n\n            /* When signals are frame-based, 'valueDimensions' has 1 column */\n            if(frameData){\n                /* When signal is frame-based, the first dimension is always fixed,\n                   so we only need to record the second dimension.\n                   e.g. Two frame-based signals [10x4] and [10x3],\n                   'valueDimensions' and 'currSigDims'\n                   only record 4 or 3.\n                */\n                nColumns = 1;\n                var->valDims->currSigDims = (void**) (currSigDims + 1);\n                var->valDims->currSigDimsSize = (int_T*) (currSigDimsSize + 1);\n            } else { /* non-frame based */\n                nColumns = nDims;\n                var->valDims->currSigDims = (void**) currSigDims;\n                var->valDims->currSigDimsSize = (int_T*) currSigDimsSize;\n            }\n\n            /* Allocate memory for the circular buffer */\n            if ( (var->valDims->dimsData = malloc(nRows*nColumns*elementSize)) == NULL ) {\n                (void)fprintf(stderr,\n                              \"*** Error allocating memory for the circular buffer\\n\");\n                (void)fprintf(stderr, \"*** Details:\\n\"\n                              \"       varName         = %s\\n\"\n                              \"       nRows           = %d\\n\"\n                              \"       nCols           = %d\\n\"\n                              \"       elementSize     = %lu\\n\"\n                              \"       Bytes Requested = %.16g\\n\\n\",\n                              var->valDims->name, nRows, nColumns, (unsigned long) elementSize,\n                              ((double)elementSize)*((double)nRows)*((double)nColumns));\n                goto ERROR_EXIT;\n            }\n            var->valDims->nRows = nRows;\n            var->valDims->nCols = nColumns;\n\n            /* Allocate memory for these dynamic arrays */\n            {\n                size_t nbytes = var->data.nDims*sizeof(int_T);\n                if( ((var->coords = calloc(nbytes, 1)) == NULL)\n                    ||((var->strides = calloc(nbytes, 1)) == NULL)\n                    ||((var->currStrides = calloc(nbytes, 1)) == NULL) )\n                    goto ERROR_EXIT;\n            }\n        }\n    }\n\n    var->rowIdx               = 0;\n    var->wrapped              = 0;\n    var->nDataPoints          = 0;\n    var->usingDefaultBufSize  = usingDefaultBufSize;\n    var->okayToRealloc        = okayToRealloc;\n    var->decimation           = decimation;\n    var->numHits              = -1;  /* so first point gets logged */\n\n    /* Add this log var to list in log info, if necessary */\n    if (appendToLogVarsList) {\n        LogInfo *logInfo = (LogInfo*) rtliGetLogInfo(li);\n        LogVar  *varList = logInfo->logVarsList;\n\n        if (varList != NULL) {\n            while (varList->next != NULL) {\n                varList = varList->next;\n            }\n            varList->next = var;\n        } else {\n            logInfo->logVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n\n    *errStatus = rtMemAllocError;\n    rt_DestroyLogVar(var);\n    return(NULL);\n\n} /* end rt_CreateLogVarWithConvert */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVar ===================================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList)\n{\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo = NULL;\n\n    return rt_CreateLogVarWithConvert(li,\n                                      startTime,\n                                      finalTime,\n                                      inStepSize,\n                                      errStatus,\n                                      varName,\n                                      inpDataTypeID,\n                                      pDataTypeConvertInfo,\n                                      logical,\n                                      complex,\n                                      frameData,\n                                      nCols,\n                                      nDims,\n                                      dims,\n                                      logValDimsStat,\n                                      currSigDims,\n                                      currSigDimsSize,\n                                      maxRows,\n                                      decimation,\n                                      sampleTime,\n                                      appendToLogVarsList);\n\n} /* end rt_CreateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateStructLogVar =============================================\n * Abstract:\n *\tCreate a logging variable in the structure format.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nStructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName)\n{\n\n    return( local_CreateStructLogVar(li,\n                                     startTime,\n                                     finalTime,\n                                     inStepSize,\n                                     errStatus,\n                                     varName,\n                                     logTime,\n                                     maxRows,\n                                     decimation,\n                                     sampleTime,\n                                     sigInfo,\n                                     blockName,\n                                     false));\n\n} /* end rt_CreateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLoggingWithStartTime ==================================\n * Abstract:\n *      Initialize data logging info based upon the following settings cached\n *      in the RTWLogging data structure of the SimStruct.\n *\n * Return value is:\n *\t== NULL  => success\n *\t!= NULL  => failure (the return value is a pointer that points to the\n *                           error message, which is also set in the simstruct)\n */\nconst char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus)\n{\n    const char_T   *varName;\n    LogInfo        *logInfo;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2 || logFormat == 3) ? 1 : 0; // For structure : 2 and dataset : 3\n    boolean_T      isStateIdxListRequired = (logFormat == 3)? true : false;\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ((logInfo=calloc(1,sizeof(LogInfo))) == NULL) {\n        *errStatus = rtMemAllocError;\n        goto ERROR_EXIT;\n    }\n    rtliSetLogInfo(li, (void*)logInfo);\n\n    /* time */\n    varName = rtliGetLogT(li);\n    if (varName[0] != '\\0') {\n        int_T dims = 1;\n        logInfo->t = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                stepSize, errStatus,\n                                                varName,SS_DOUBLE,\n                                                NULL,\n                                                0,0,0,1,1,\n                                                &dims, NO_LOGVALDIMS, NULL, NULL,\n                                                maxRows,decimation,\n                                                sampleTime,1);\n        if (logInfo->t == NULL) goto ERROR_EXIT;\n    }\n\n    /* states */\n    if ( rtliGetLogX(li)[0] != '\\0' ||  rtliGetLogXFinal(li)[0] != '\\0' ) {\n        const RTWLogSignalInfo  *xInfo = rtliGetLogXSignalInfo(li);\n\n        if (logFormat == 0) {                                /* Matrix Format */\n            int            numCols;\n            int            nDims;\n            const int      *dims;\n            BuiltInDTypeId dataType;\n            int            isComplex;\n            int_T          sIdx;\n\n            const RTWLogDataTypeConvert *pDTConvInfo;\n\n            numCols = xInfo[0].numCols ? xInfo[0].numCols[0] : 0;\n            for (sIdx = 1; sIdx < xInfo[0].numSignals; sIdx++) {\n                numCols += xInfo[0].numCols[sIdx];\n            }\n            /* If we have only one \"matrix\" state, we can log as a matrix */\n            if (xInfo[0].numSignals == 1) {\n                nDims     = xInfo[0].numDims ? xInfo[0].numDims[0] : 1;\n                dims      = xInfo[0].dims;\n            } else {\n                nDims     = 1;\n                dims      = &numCols;\n            }\n            dataType  = xInfo[0].dataTypes ? xInfo[0].dataTypes[0] : 0;\n            isComplex = xInfo[0].complexSignals ? xInfo[0].complexSignals[0] : 0;\n\n            pDTConvInfo = xInfo[0].dataTypeConvert;\n\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                        stepSize, errStatus,\n                                                        rtliGetLogX(li),dataType,\n                                                        pDTConvInfo,\n                                                        0,\n                                                        isComplex,0,numCols,nDims,dims,\n                                                        NO_LOGVALDIMS, NULL, NULL,\n                                                        maxRows,decimation,sampleTime,1);\n                if (logInfo->x == NULL)  goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                             stepSize, errStatus,\n                                                             rtliGetLogXFinal(li),dataType,\n                                                             pDTConvInfo,\n                                                             0,isComplex,0,numCols,nDims,\n                                                             dims, NO_LOGVALDIMS, NULL,\n                                                             NULL, 1,decimation,\n                                                             sampleTime,1);\n                if (logInfo->xFinal == NULL)  goto ERROR_EXIT;\n            }\n        } else {                                          /* Structure Format */\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = local_CreateStructLogVar(li, startTime, finalTime,\n                                                      stepSize, errStatus,\n                                                      rtliGetLogX(li), logTime,\n                                                      maxRows, decimation,\n                                                      sampleTime, xInfo, NULL, false);\n                if (logInfo->x == NULL) goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = local_CreateStructLogVar(li, startTime, finalTime,\n                                                           stepSize, errStatus,\n                                                           rtliGetLogXFinal(li),\n                                                           logTime,1,decimation,\n                                                           sampleTime,xInfo,NULL, isStateIdxListRequired);\n                if (logInfo->xFinal == NULL) goto ERROR_EXIT;\n            }\n        }\n    }\n\n    /* outputs */\n    *errStatus = rt_StartDataLoggingForOutput(li,startTime,finalTime,\n                                              stepSize,errStatus);\n    if (*errStatus != NULL)  goto ERROR_EXIT;\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingWithStartTime */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLogging ===============================================\n * Abstract:\n */\nconst char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus)\n{\n    return rt_StartDataLoggingWithStartTime(li,\n                                            0.0,\n                                            finalTime,\n                                            stepSize,\n                                            errStatus);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_UpdateLogVar ===================================================\n * Abstract:\n *\tCalled to log data for a log variable.\n */\nvoid rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims)\n{\n    size_t        elSize    = var->data.elSize;\n    const  char_T *cData    = data;\n    const  int_T  frameData = var->data.frameData;\n    const  int_T  frameSize = frameData ? (var->data.frameSize) : 1;\n    const  int_T  logWidth  = var->data.nCols;\n    BuiltInDTypeId dTypeID  = var->data.dTypeID;\n\n    size_t offset        = 0;\n    char_T *currRealRow  = NULL;\n    char_T *currImagRow  = NULL;\n    int_T  pointSize     = (int_T)((var->data.complex) ? rt_GetSizeofComplexType(dTypeID) : elSize);\n\n    int    i, j, k;\n\n    /* The following variables will be used for\n       logging variable-size signals */\n    const  int_T  nDims = var->data.nDims;\n    const  int_T  *dims = var->data.dims;\n    const  void   * const *currDimsPtr = NULL;\n    const  int_T  *currDimsSizePtr = NULL;\n\n    /* The following variables will be used for\n       logging \"valueDimensions\" field */\n    size_t offset_valDims   = 0;\n    char_T *currValDimsRow  = NULL;\n    size_t elSize_valDims   = sizeof(real_T);\n    real_T currentSigDims   = 0;\n    int_T  nRows_valDims    = 0;\n    int_T  logWidth_valDims = 0;\n\n    for (i = 0; i < frameSize; i++) {\n        if (++var->numHits % var->decimation) continue;\n        var->numHits = 0;\n\n        if (var->rowIdx == var->data.nRows) {\n            if (var->okayToRealloc == 1) {\n                rt_ReallocLogVar(var, isVarDims);\n            } else {\n                /* Circular buffer */\n                var->rowIdx = 0;\n                ++(var->wrapped); /* increment the wrap around counter */\n            }\n        }\n\n        if(isVarDims){\n            currDimsPtr = (const void * const *) var->valDims->currSigDims;\n            currDimsSizePtr = (const int_T*) var->valDims->currSigDimsSize;\n            logWidth_valDims = frameData ? 1 : var->valDims->nCols;\n            nRows_valDims = var->valDims->nRows;\n\n            var->strides[0] = 1;\n            var->currStrides[0] = 1;\n\n            for (k = 1; k < nDims; k++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[k-1]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                }\n                var->strides[k] = var->strides[k-1] * dims[k-1];\n                var->currStrides[k] = var->currStrides[k-1] * currDimsVal;\n            }\n        }\n\n        offset       = (size_t)(elSize * var->rowIdx * logWidth);\n        currRealRow  = ((char_T*) (var->data.re)) + offset;\n        currImagRow  = (var->data.complex) ?\n                       ((char_T*) (var->data.im)) + offset :  NULL;\n\n        /* update logging data */\n        for (j = 0; j < logWidth; j++) {\n\n            boolean_T inRange = true;\n            int idx = j;\n\n            /* Check whether the currently logged value is in range or not.\n               For fixed-size signal logging, always inRange = true; idx = j;\n               For variable-size signal logging, use strides, coordinates\n               and current strides to decide whether the currently logged\n               data is in range or not and its location in the logging\n               matrix.\n             */\n            if(isVarDims){\n                int rem = j;\n                idx = 0;\n                for(k = nDims-1; k>=0; k--){\n                    int32_T currDimsVal=0;\n                    switch (currDimsSizePtr[k]) {\n                      case 1:\n                        currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+k));\n                        break;\n                      case 2:\n                        currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+k));\n                        break;\n                      case 4:\n                        currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+k));\n                        break;\n                    }\n                    var->coords[k] = rem / var->strides[k];\n                    if( var->coords[k] >= currDimsVal ){\n                        inRange = false;\n                        break;\n                    }\n                    rem = rem - var->coords[k] * var->strides[k];\n                }\n                if(inRange){\n                    idx = var->coords[0];\n                    for (k = 1; k < nDims; k++){\n                        idx += var->coords[k] * var->currStrides[k];\n                    }\n                }\n            }\n\n            if (!var->data.dataTypeConvertInfo.conversionNeeded) {\n                /* NO  conversion needed\n                 */\n                if (inRange) {\n                    /* If in range, fill in data */\n                    const char *cDataPoint = cData + (i+frameSize*idx) * pointSize;\n\n                    (void) memcpy(currRealRow, cDataPoint, elSize);\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        (void) memcpy(currImagRow, cDataPoint + pointSize/2, elSize);\n                        currImagRow += elSize;\n                    }\n                } else {\n                    /* If out of range, fill in NaN or 0:\n                       1) For bool, int32, uint32, int16, uint16, etc,\n                          memset to zeros;\n                       2) For fixed-point data type, NaN conversion is not\n                          allowed, memset to zeros.\n                    */\n                    if (dTypeID == SS_DOUBLE) {\n                       (void) memcpy(currRealRow, &rtNaN, elSize);\n                    } else if (dTypeID == SS_SINGLE){\n                        (void) memcpy(currRealRow, &rtNaNF, elSize);\n                    } else {\n                        (void) memset(currRealRow, 0, elSize);\n                    }\n\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        /* For imaginary part, fill in 0 */\n                        (void) memset(currImagRow, 0, elSize);\n                        currImagRow += elSize;\n                    }\n                }\n            }\n            else\n            {\n                /* YES conversion needed\n                 */\n                DTypeId dataTypeIdOriginal =\n                    var->data.dataTypeConvertInfo.dataTypeIdOriginal;\n                int_T DpSize = (int_T)((var->data.complex) ?\n                                       rt_GetSizeofComplexType(dataTypeIdOriginal) :\n                                       rt_GetSizeofDataType(dataTypeIdOriginal));\n\n                DTypeId dataTypeIdLoggingTo =\n                    var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;\n\n                int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;\n                int numOfChunk =  var->data.dataTypeConvertInfo.numOfChunk;\n                unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;\n\n                double fracSlope = var->data.dataTypeConvertInfo.fracSlope;\n                int    fixedExp  = var->data.dataTypeConvertInfo.fixedExp;\n                double bias      = var->data.dataTypeConvertInfo.bias;\n\n                double curRealValue = -0.12345678987654;\n                double curImagValue = -0.12345678987654;\n\n                int_T adjIndexIfComplex = (var->data.complex) ? 2 : 1;\n\n                if(inRange){\n                    if(numOfChunk > 1)\n                    {\n                        /* For multiword */\n                        const char *pInData = (const char *)(cData);\n                        int dtSize = bitsPerChunk*numOfChunk/8;\n                        pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n\n                        curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk,\n                                                                       isSigned, fracSlope, fixedExp, bias);\n                        if (var->data.complex) {\n                            curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk,\n                                                                           isSigned, fracSlope, fixedExp, bias);\n                        }\n                    }\n                    else\n                    {\n                        /* if in range, fill in data that is converted first */\n                        switch ( dataTypeIdOriginal )\n                        {\n                          case SS_DOUBLE:\n                            {\n                                const real_T *pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_SINGLE:\n                            {\n                                const real32_T *pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT8:\n                            {\n                                const int8_T *pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT8:\n                            {\n                                const uint8_T *pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT16:\n                            {\n                                const int16_T *pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT16:\n                            {\n                                const uint16_T *pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT32:\n                            {\n                                const int32_T *pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT32:\n                            {\n                                const uint32_T *pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_BOOLEAN:\n                            {\n                                const boolean_T *pInData = ((const boolean_T *)(cData));\n\n                                pInData += (i+frameSize*idx) * adjIndexIfComplex;\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          default:\n                            {\n                                /* For biglong */\n                                const char *pInData = (const char *)(cData);\n                                int dtSize = bitsPerChunk*numOfChunk/8;\n                                pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n\n                                curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk,\n                                                                               isSigned, fracSlope, fixedExp, bias);\n                                if (var->data.complex) {\n                                    curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk,\n                                                                                   isSigned, fracSlope, fixedExp, bias);\n                                }\n                            }\n                            break;\n                        } /* -- end of switch -- */\n                    }\n                } else {\n                    /* if out of range, just fill NaN or 0 */\n                    if(dTypeID == SS_DOUBLE || dTypeID == SS_SINGLE){\n                        /* vijay 4/11/2013: DO NOT CALL ldexp() with NaN below as it causes\n                         * lcc-win64 to generate inf instead of NaN as output.\n                         * Just use rtNaN directly */\n                        curRealValue = rtNaN;\n                    }\n                    else{\n                        curRealValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                    if (var->data.complex) {\n                        /* fill 0 in imaginary part*/\n                        curImagValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                }\n\n                switch ( dataTypeIdLoggingTo )\n                {\n                  case SS_DOUBLE:\n                    {\n                        *((real_T *)currRealRow) = (real_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real_T *)currImagRow) = (real_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_SINGLE:\n                    {\n                        *((real32_T *)currRealRow) = (real32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real32_T *)currImagRow) = (real32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT8:\n                    {\n                        *((int8_T *)currRealRow) = (int8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int8_T *)currImagRow) = (int8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT8:\n                    {\n                        *((uint8_T *)currRealRow) = (uint8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint8_T *)currImagRow) = (uint8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT16:\n                    {\n                        *((int16_T *)currRealRow) = (int16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int16_T *)currImagRow) = (int16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT16:\n                    {\n                        *((uint16_T *)currRealRow) = (uint16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint16_T *)currImagRow) = (uint16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT32:\n                    {\n                        *((int32_T *)currRealRow) = (int32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int32_T *)currImagRow) = (int32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT32:\n                    {\n                        *((uint32_T *)currRealRow) = (uint32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint32_T *)currImagRow) = (uint32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_BOOLEAN:\n                    {\n                        *((boolean_T *)currRealRow) = (boolean_T)(curRealValue != 0.0);\n\n                        if (var->data.complex) {\n\n                            *((boolean_T *)currImagRow) = (boolean_T)(curImagValue != 0.0);\n                        }\n                    }\n                    break;\n                } /* -- end of switch -- */\n\n                currRealRow += elSize;\n                if (var->data.complex) {\n                    currImagRow += elSize;\n                }\n            }\n        }\n\n        if(isVarDims){ /* update \"valueDimensions\" field */\n            for(j = 0; j < logWidth_valDims; j ++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[j]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+j));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+j));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+j));\n                    break;\n                }\n                offset_valDims  = (size_t)(elSize_valDims *( var->rowIdx + nRows_valDims * j));\n                currValDimsRow  = ((char_T*) (var->valDims->dimsData)) + offset_valDims;\n\n                /* convert int_T to real_T */\n                currentSigDims = (real_T) currDimsVal;\n                (void) memcpy(currValDimsRow, &currentSigDims, elSize_valDims);\n                currValDimsRow += elSize_valDims;\n            }\n        }\n\n        ++var->rowIdx;\n    }\n\n    return;\n\n} /* end rt_UpdateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_UpdateStructLogVar =============================================\n * Abstract:\n *      Called to log data for a structure log variable.\n */\nvoid rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data)\n{\n    LogVar       *values = var->signals.values;\n    const char_T *signal = data;\n    boolean_T *isVarDims = var->signals.isVarDims;\n    int i = 0;\n\n    /* time */\n    if (var->logTime) {\n        rt_UpdateLogVar(var->time, t, false);\n    }\n\n    /* signals */\n    while (values) {\n        size_t elSz = values->data.elSize;\n\n        rt_UpdateLogVar(values, signal, isVarDims[i]);\n\n        if (values->data.complex) elSz *= 2;\n        signal += elSz * values->data.nCols;\n\n        values = values->next;\n        i++;\n    }\n\n} /* end rt_UpdateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Function: rt_UpdateTXYLogVars ===============================================\n * Abstract:\n *\tUpdate the xFinal,T,X,Y variables that are being logged.\n */\nconst char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr)\n{\n    return rt_UpdateTXXFYLogVars(li, tPtr, true);\n}\n\n/* Function: rt_UpdateTXXFYLogVars =============================================\n * Abstract:\n *\tUpdate xFinal and/or the T,X,Y variables that are being logged\n */\nconst char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY)\n{\n    LogInfo *logInfo     = rtliGetLogInfo(li);\n    int_T   matrixFormat = (rtliGetLogFormat(li) == 0);\n    const RTWLogSignalInfo* xInfo = rtliGetLogXSignalInfo(li);\n\n    /* time */\n    if (logInfo->t != NULL && updateTXY) {\n        rt_UpdateLogVar(logInfo->t, tPtr, false);\n    }\n\n    if (matrixFormat) {                                      /* MATRIX_FORMAT */\n        /* states */\n        if (logInfo->x != NULL || logInfo->xFinal != NULL) {\n            int8_T**     segAddr     = _rtliGetLogXSignalPtrs(li);\n            const int_T* segLengths = xInfo->numCols;\n            int_T        nSegments   = xInfo->numSignals;\n\n            if (logInfo->x != NULL && updateTXY) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(\n                    logInfo->x,\n                    segAddr,\n                    segLengths,\n                    nSegments);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n            if (logInfo->xFinal != NULL) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(\n                    logInfo->xFinal,\n                    segAddr,\n                    segLengths,\n                    nSegments);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n        }\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            LogVar **var = (LogVar**) (logInfo->y);\n            int_T  ny    = logInfo->ny;\n            int_T  i;\n            int    yIdx;\n            LogSignalPtrsType data = rtliGetLogYSignalPtrs(li);\n\n            for (i = 0, yIdx = 0; i < ny; i++) {\n                if (data[i] != NULL) {\n                    /*\n                       When outputs are logged in Matrix format,\n                       no variable-size signal logging is allowed.\n                    */\n                    rt_UpdateLogVar(var[yIdx], data[i], false);\n                    yIdx++;\n                }\n            }\n        }\n    } else {                                              /* STRUCTURE_FORMAT */\n        /* states */\n        if (logInfo->x != NULL && updateTXY) {\n            int_T             i;\n            StructLogVar      *var = logInfo->x;\n            LogVar            *val = var->signals.values;\n            int_T             nsig = var->signals.numSignals;\n            LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n\n            /* time */\n            if (var->logTime) {\n                rt_UpdateLogVar(var->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                rt_UpdateLogVar(val, data[i], false);\n                val = val->next;\n            }\n        }\n\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            int_T             ny      = logInfo->ny;\n            LogSignalPtrsType data    = rtliGetLogYSignalPtrs(li);\n            StructLogVar      **var   = (StructLogVar**) (logInfo->y);\n\n            if (ny == 1) {\n                int_T  i;\n                int_T  dataIdx;\n                LogVar *val = var[0]->signals.values;\n                int_T  nsig = var[0]->signals.numSignals;\n                boolean_T   *isVarDims = var[0]->signals.isVarDims;\n\n                /* time */\n                if (var[0]->logTime) {\n                    rt_UpdateLogVar(var[0]->time, tPtr, false);\n                }\n\n                /* signals */\n                for (i = 0, dataIdx = 0; i < nsig; i++) {\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    rt_UpdateLogVar(val, data[dataIdx], isVarDims[i]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            } else {\n                int_T  i;\n                int_T  dataIdx;\n\n                for (i = 0, dataIdx = 0; i < ny && var[i] != NULL; i++) {\n                    LogVar *val = var[i]->signals.values;\n                    boolean_T   *isVarDims = var[i]->signals.isVarDims;\n\n                    /* time */\n                    if (var[i]->logTime) {\n                        rt_UpdateLogVar(var[i]->time, tPtr, false);\n                    }\n\n                    /* signals */\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    rt_UpdateLogVar(val, data[dataIdx], isVarDims[0]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            }\n        }\n        /* final state */\n        if (logInfo->xFinal != NULL) {\n            StructLogVar *xf  = logInfo->xFinal;\n            LogVar       *val = xf->signals.values;\n            int_T        nsig = xf->signals.numSignals;\n            int_T        i;\n\n            /* time */\n            if (xf->logTime) {\n                rt_UpdateLogVar(xf->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n                rt_UpdateLogVar(val, data[i], false);\n                val = val->next;\n            }\n        }\n    }\n    return(NULL);\n} /* end rt_UpdateTXXFYLogVars */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLoggingImpl =======================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel, boolean_T cleanUp)\n{\n    FILE          *fptr;\n    LogInfo       *logInfo     = (LogInfo*) rtliGetLogInfo(li);\n    LogVar        *var         = logInfo->logVarsList;\n    StructLogVar  *svar        = logInfo->structLogVarsList;\n\n    boolean_T     emptyFile    = 1; /* assume */\n    boolean_T     errFlag      = 0;\n    boolean_T*    isVarDims    = NULL;\n    const char_T  *msg;\n    int i;\n\n    assert(isRaccel);\n\n    /*******************************\n     * Create MAT file with header *\n     *******************************/\n    if ((fptr=fopen(file,\"w+b\")) == NULL) {\n        (void)fprintf(stderr,\"*** Error opening %s\",file);\n        goto EXIT_POINT;\n    }\n    if (rt_WriteMat5FileHeader(fptr)) {\n        (void)fprintf(stderr,\"*** Error writing to %s\",file);\n        goto EXIT_POINT;\n    }\n\n    /**************************************************\n     * First log all the variables in the LogVar list *\n     **************************************************/\n    while (var != NULL) {\n        if ( (msg = rt_FixupLogVar(var, (var->valDims != NULL), cleanUp)) != NULL ) {\n            (void)fprintf(stderr,\"*** Error writing %s due to: %s\\n\",file,msg);\n            errFlag = 1;\n            break;\n        }\n        if (var->nDataPoints > 0 || isRaccel) {\n            MatItem item;\n\n            item.type   = matMATRIX;\n            item.nbytes = 0; /* not yet known */\n            item.data   = &(var->data);\n            if (rt_WriteItemToMatFile(fptr, &item, MATRIX_ITEM)) {\n                (void)fprintf(stderr,\"*** Error writing log variable %s to \"\n                              \"file %s\",var->data.name, file);\n                errFlag = 1;\n                break;\n            }\n            emptyFile = 0;\n        }\n        var = var->next;\n    }\n    /* free up some memory by destroying the log var list here */\n    if (cleanUp) {\n      rt_DestroyLogVar(logInfo->logVarsList);\n      logInfo->logVarsList = NULL;\n    }\n\n    /*******************************************************\n     * Next log all the variables in the StructLogVar list *\n     *******************************************************/\n    while (svar != NULL) {\n        MatItem item;\n\n        if (svar->logTime) {\n            var = svar->time;\n            if ( (msg = rt_FixupLogVar(var, false, cleanUp)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n        }\n\n        var = svar->signals.values;\n        isVarDims = svar->signals.isVarDims;\n        i = 0;\n        while (var) {\n            if ( (msg = rt_FixupLogVar(var, isVarDims[i], cleanUp)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n            var = var->next;\n            ++i;\n        }\n\n        item.type   = matMATRIX;\n        item.nbytes = 0; /* not yet known */\n        item.data   = svar;\n\n        if (rt_WriteItemToMatFile(fptr, &item, STRUCT_LOG_VAR_ITEM)) {\n            (void)fprintf(stderr,\"*** Error writing structure log variable \"\n                          \"%s to file %s\",svar->name, file);\n            errFlag = 1;\n            break;\n        }\n        emptyFile = 0;\n\n        svar = svar->next;\n    }\n\n    /******************\n     * Close the file *\n     ******************/\n    (void)fclose(fptr);\n    if (emptyFile || errFlag) {\n        (void)remove(file);\n    }\n\n EXIT_POINT:\n\n    /****************\n     * free logInfo *\n     ****************/\n    if (cleanUp) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n\n} /* end rt_StopDataLoggingImpl */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLogging ================================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLogging(const char_T *file, RTWLogInfo *li)\n{\n    rt_StopDataLoggingImpl(file,li, false, true);\n\n} /* end rt_StopDataLogging */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li) { (void(file)); } /* use file quiet unused macro warning */ /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n\n\n/* [eof] rt_logging.c */\n\n/* LocalWords:  Tfinal MAXNAM nonfinite DType PWS RSim Fixup logvar DDEFAULT th\n * LocalWords:  curr Realloc realloc inp biglong vijay ldexp TXY eof XFinal th\n * LocalWords:  TXXFY NULL typedefs ret polyspace NUL\n */\n"},{"name":"rt_matrx.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* File    : rt_matrx.c\n * Abstract:\n *      Implements stand alone matrix access and creation routines.\n *\tThere are two types of MATLAB objects which can be \"passed\" to\n *\tthe generated code, a 2D real matrix and a string. Strings are\n *\tpassed as 2D real matrices. The first two elements of an S-function\n *\tparameters are the row and column (m and n) dimensions respectively.\n *\tThese are followed by the matrix data.\n */\n\n\n\n/*\n * Copyright 1994-2020 The MathWorks, Inc.\n */\n\n/*==========*\n * Includes *\n *==========*/\n\n#if defined(MDL_REF_SIM_TGT)\n#undef MATLAB_MEX_FILE\n#endif\n\n#if defined(MATLAB_MEX_FILE)\n# error \"rt_matrix cannot be used within a mex file. It is for codegen only.\"\n#endif\n\n#include <stdlib.h>    /* needed for malloc, calloc, free, realloc */\n#include <string.h>    /* needed for strlen                        */\n#include \"rtwtypes.h\"  /* needed for real_T                        */\n#include \"rt_mxclassid.h\" /* needed for mxClassID                     */\n#include \"rt_matrx.h\"\n\n#include <stddef.h> /* needed for size_t and NULL */\n#include <float.h>  /* needed for definition of eps */\n\n/*==========*\n * Typedefs *\n *==========*/\n\n#ifndef rt_typedefs_h\n#define rt_typedefs_h\n\n#if !defined(TYPEDEF_MX_ARRAY)\n# define TYPEDEF_MX_ARRAY\n  typedef real_T mxArray;\n#endif\n\ntypedef real_T mxChar;\n\n#if !defined(TMW_NAME_LENGTH_MAX)\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n\ntypedef enum {\n    mxREAL,\n    mxCOMPLEX\n} mxComplexity;\n\n#endif /* rt_typedefs_h */\n\n/*==================*\n * Extern variables *\n *==================*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\n\n#ifdef __cplusplus\n}\n#endif\n\n/*=======================================*\n * Defines for mx Routines and constants *\n *=======================================*/\n\n\n#define mxCalloc(n,size) \\\n        calloc(n,size)\n\n#define mxCreateCharArray(ndim, dims) \\\n        mxCreateNumericArray(ndim, dims, mxCHAR_CLASS);\n\n#define mxDestroyArray(pa) \\\n        if (pa) free(pa)\n\n/* NOTE: You cannot mxFree(mxGetPr(pa)) !!! */\n#define mxFree(ptr) \\\n        if(ptr)free(ptr)\n\n#define mxGetClassID(pa) \\\n        mxDOUBLE_CLASS\n\n/* NOTE: mxGetClassName(pa) returns \"double\" even on a character array */\n#define mxGetClassName(pa) \\\n        \"double\"\n\n#define mxGetData(pa) \\\n        ((void *)(&((pa)[2])))\n\n#define mxGetElementSize(pa) \\\n        (sizeof(real_T))\n\n#define mxGetInf() \\\n        rtInf\n\n#define mxGetM(pa) \\\n        ((size_t) ((pa)[0]))\n#define mxGetN(pa) \\\n        ((size_t) ((pa)[1]))\n\n#define mxGetNaN() \\\n        rtNaN\n\n#define mxGetNumberOfDimensions(pa) \\\n        (2)\n#define mxGetNumberOfElements(pa) \\\n        (mxGetM(pa)*mxGetN(pa))\n\n/* NOTE: mxGetPr() of an empty matrix does NOT return NULL */\n#define mxGetPr(pa) \\\n        ( &((pa)[2]) )\n\n/* NOTE: mxGetDoubles() of an empty matrix does NOT return NULL */\n#define mxGetDoubles(pa) \\\n        ( &((pa)[2]) )\n\n#define mxGetScalar(pa) \\\n        ((pa)[2])\n\n#define mxIsComplex(pa) \\\n        false\n\n#define mxIsDouble(pa) \\\n        true\n\n#define mxIsEmpty(pa) \\\n        (mxGetM(pa)==0 || mxGetN(pa)==0)\n\n#define mxIsFinite(r) \\\n        ((r)>rtMinusInf && (r)<rtInf)\n\n#define mxIsInf(r) \\\n        ((r)==rtInf || (r)==rtMinusInf)\n\n#define mxIsInt16(pa) \\\n        false\n\n#define mxIsInt32(pa) \\\n        false\n\n#define mxIsInt8(pa) \\\n        false\n\n#define mxIsLogical(pa) \\\n        false\n\n#define mxIsNumeric(pa) \\\n        true\n\n#define mxIsSingle(pa) \\\n        false\n\n#define mxIsSparse(pa) \\\n        false\n\n#define mxIsStruct(pa) \\\n        false\n\n#define mxIsUint16(pa) \\\n        false\n\n#define mxIsUint32(pa) \\\n        false\n\n#define mxIsUint8(pa) \\\n        false\n\n#define mxMalloc(n) \\\n        malloc(n)\n\n#define mxRealloc(p,n) \\\n        realloc(p,n)\n\n/*==============*\n * Local macros *\n *==============*/\n#define _mxSetM(pa,m) \\\n        (pa)[0] = ((int)(m))\n\n#define _mxSetN(pa,n) \\\n        (pa)[1] = ((int)(n))\n\n\n/*==========================*\n * Visible/extern functions *\n *=========================*/\n\n/* Function: mxCreateCharMatrixFromStrings ====================================\n * Abstract:\n *\tCreate a string array initialized to the strings in str.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateCharMatrixFromStrings(int_T m, const char_T **str)\n{\n    int_T nchars;\n    int_T i, n;\n    mxArray *pa;\n\n    n = 0;\n    for (i = 0; i < m; ++i) {\n\tnchars = (int_T)strlen(str[i]);\n\tif (nchars > n) {\n\t    n = nchars;\n\t}\n    }\n    /*LINTED E_PASS_INT_TO_SMALL_INT*/\n    pa = (mxArray *)malloc((m*n+2)*sizeof(real_T));\n    if(pa!=NULL) {\n\tmxChar *chars;\n\tint_T  j;\n\t_mxSetM(pa, m);\n\t_mxSetN(pa, n);\n\tchars = mxGetPr(pa);\n\tfor (j = 0; j < m; ++j) {\n\t    const char_T *src  = str[j];\n\t    mxChar *dest = chars + j;\n\n\t    nchars = (int_T)strlen(src);\n\t    i = nchars;\n\t    while (i--) {\n\t\t*dest = *src++;\n\t\t dest += m;\n\t    }\n\t    i = n - nchars;\n\t    while (i--) {\n\t\t*dest = 0.0;\n\t\tdest += m;\n\t    }\n\t}\n    }\n    return pa;\n} /* end mxCreateCharMatrixFromStrings */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateString ===================================================\n * Abstract:\n *\tCreate a 1-by-n string array initialized to null terminated string\n *\twhere n is the length of the string.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateString(const char *str)\n{\n    int_T   len = (int_T)strlen(str);\n    /*LINTED E_PASS_INT_TO_SMALL_INT*/\n    mxArray *pa = (mxArray *)malloc((len+2)*sizeof(real_T));\n\n    if(pa!=NULL) {\n\treal_T *pr;\n\tconst unsigned char *ustr_ptr = (const unsigned char *) str;\n\n\t_mxSetM(pa, 1);\n\t_mxSetN(pa, len);\n\tpr = mxGetPr(pa);\n\twhile (len--) {\n            *pr++ = (real_T)*ustr_ptr++;\n        }\n    }\n    return(pa);\n\n} /* end mxCreateString */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateDoubleMatrix =============================================\n * Abstract:\n *\tCreate a two-dimensional array to hold real_T data,\n *\tinitialize each data element to 0.\n */\n/*LINTLIBRARY*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateDoubleMatrix(int m, int n, mxComplexity flag)\n{\n    if (flag == mxREAL) {\n        mxArray *pa = (mxArray *)calloc(m*n+2, sizeof(real_T));\n        if(pa!=NULL) {\n            _mxSetM(pa, m);\n            _mxSetN(pa, n);\n        }\n        return(pa);\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateDoubleMatrix */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateNumericArray =============================================\n * Abstract:\n *\tCreate a numeric array and initialize all its data elements to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateNumericArray(int_T ndims, const mwSize *dims, \n                                        mxClassID classid, mxComplexity flag)\n{\n    if (ndims == 2 && classid==mxDOUBLE_CLASS) {\n        return(rt_mxCreateDoubleMatrix((int)(dims[0]), (int)(dims[1]), flag));\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateNumericArray */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxDuplicateArray =================================================\n * Abstract:\n *\tMake a deep copy of an array, return a pointer to the copy.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nmxArray *rt_mxDuplicateArray(const mxArray *pa)\n{\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    size_t   nbytes = (mxGetNumberOfElements(pa)+2)*mxGetElementSize(pa);\n    mxArray *pcopy = (mxArray *)malloc(nbytes);\n\n    if (pcopy!=NULL) {\n\t(void)memcpy(pcopy, pa, nbytes);\n    }\n    return(pcopy);\n\n} /* end mxDuplicateArray */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetDimensions ==================================================\n * Abstract:\n *\tGet pointer to dimension array\n * \tNOTE: This routine is not reentrant.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nconst mwSize *rt_mxGetDimensions(const mxArray *pa)\n{\n    static mwSize dims[2];\n    dims[0] = mxGetM(pa);\n    dims[1] = mxGetN(pa);\n    return dims;\n} /* end mxGetDimensions */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetEps =========================================================\n * Abstract:\n *\tReturn eps, the difference between 1.0 and the least value\n *\tgreater than 1.0 that is representable as a real_T.\n *\tNOTE: Assumes real_T is either double or float.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nreal_T rt_mxGetEps(void)\n{\n    return (sizeof(double)==sizeof(real_T)) ? DBL_EPSILON : FLT_EPSILON;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetString ======================================================\n * Abstract:\n *\tConverts a string array to a C-style string.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint_T rt_mxGetString(const mxArray *pa, char_T *buf, int_T buflen)\n{\n    int_T        nchars;\n    const real_T *pr;\n    char_T       *pc;\n    int_T        truncate = 0;\n\n    nchars = (int_T)mxGetNumberOfElements(pa);\n    if (nchars >= buflen) {\n\t/* leave room for null byte */\n\tnchars = buflen - 1;\n\ttruncate = 1;\n    }\n    pc = buf;\n    pr = mxGetPr(pa);\n    while (nchars--) {\n\t*pc++ = (char) (*pr++ + .5);\n    }\n    *pc = '\\0';\n    return truncate;\n} /* end mxGetString */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#define mxCreateCharMatrixFromStrings(m, str) \\\n        rt_mxCreateCharMatrixFromStrings(m, str)\n\n#define mxCreateString(str) \\\n        rt_mxCreateString(str) \n\n#define mxCreateDoubleMatrix(m, n, flag) \\\n        rt_mxCreateDoubleMatrix(m, n, flag)\n\n#define mxCreateNumericArray(ndims, dims, classid, flag) \\\n        rt_mxCreateNumericArray(ndims, dims, classid, flag)\n\n#define mxDuplicateArray(pa) \\\n        rt_mxDuplicateArray(pa)\n\n#define mxGetDimensions(pa) \\\n        rt_mxGetDimensions(pa)\n\n#define mxGetEps() \\\n        rt_mxGetEps()\n\n#define mxGetString(pa, buf, buflen) \\\n        rt_mxGetString(pa, buf, buflen)\n\n/*=========================*\n * Unsupported mx Routines *\n *=========================*/\n\n#define mxCalcSingleSubscript(pa,nsubs,subs) \\\n        mxCalcSingleSubscript_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellArray(ndim,dims) \\\n        mxCreateCellArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellMatrix(m,n) \\\n        mxCreateCellMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxCreateSparse(pm,pn,pnzmax,pcmplx_flg) \\\n        mxCreateSparse_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructArray(ndim,dims,nfields,fieldnames) \\\n        mxCreateStructArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructMatrix(m,n,nfields,fieldnames) \\\n        mxCreateStructMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxGetCell(pa,i) \\\n        mxGetCell_is_not_supported_in_Simulink_Coder\n\n#define mxGetField(pa,i,fieldname) \\\n        mxGetField_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldByNumber(s,i,fieldnum) \\\n        mxGetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNameByNumber(pa,n) \\\n        mxGetFieldNameByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNumber(pa,fieldname) \\\n        mxGetFieldNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetImagData(pa) \\\n        mxGetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxGetIr(ppa) \\\n        mxGetIr_is_not_supported_in_Simulink_Coder\n\n#define mxGetJc(ppa) \\\n        mxGetJc_is_not_supported_in_Simulink_Coder\n\n#define mxGetNumberOfFields(pa) \\\n        mxGetNumberOfFields_is_not_supported_in_Simulink_Coder\n\n#define mxGetNzmax(pa) \\\n        mxGetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxGetPi(pa) \\\n        mxGetPi_is_not_supported_in_Simulink_Coder\n\n#define mxIsFromGlobalWS(pa) \\\n        mxIsFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxIsNaN(r) \\\n        mxIsNaN_is_not_supported_in_Simulink_Coder\n\n#define mxIsChar(pa) \\\n        mxIsChar_is_not_supported_in_Simulink_Coder\n\n#define mxIsClass(pa,class) \\\n        mxIsClass_is_not_supported_in_Simulink_Coder\n\n#define mxIsCell(pa) \\\n        mxIsCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetCell(pa,i,value) \\\n        mxSetCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetClassName(pa,classname) \\\n        mxSetClassName_is_not_supported_in_Simulink_Coder\n\n#define mxSetData(pa,pr) \\\n        mxSetData_is_not_supported_in_Simulink_Coder\n\n#define mxSetDimensions(pa, size, ndims) \\\n        mxSetDimensions_is_not_supported_in_Simulink_Coder\n\n#define mxSetField(pa,i,fieldname,value) \\\n        mxSetField_is_not_supported_in_Simulink_Coder\n\n#define mxSetFieldByNumber(pa, index, fieldnum, value) \\\n        mxSetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxSetFromGlobalWS(pa,global) \\\n        mxSetFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxSetImagData(pa,pv) \\\n        mxSetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxSetIr(ppa,ir) \\\n        mxSetIr_is_not_supported_in_Simulink_Coder\n\n#define mxSetJc(ppa,jc) \\\n        mxSetJc_is_not_supported_in_Simulink_Coder\n\n#define mxSetM(pa, m) \\\n        mxSetM_is_not_supported_in_Simulink_Coder\n\n#define mxSetN(pa, m) \\\n        mxSetN_is_not_supported_in_Simulink_Coder\n\n#define mxSetPr(pa,pr) \\\n        mxSetPr_is_not_supported_in_Simulink_Coder\n\n#define mxSetNzmax(pa,nzmax) \\\n        mxSetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxSetPi(pa,pv) \\\n        mxSetPi_is_not_supported_in_Simulink_Coder\n\n\n\n/*==========================*\n * Unsupported mex routines *\n *==========================*/\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexEvalString(str) \\\n        mexEvalString_is_not_supported_by_Simulink_Coder\n\n#define mexErrMsgTxt(str) \\\n        mexErrMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexWarnMsgTxt(warning_msg) \\\n        mexWarnMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexPrintf \\\n        mexPrintf_is_not_supported_by_Simulink_Coder\n\n#define mexMakeArrayPersistent(pa) \\\n        mexMakeArrayPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexMakeMemoryPersistent(ptr) \\\n        mexMakeMemoryPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexLock() \\\n        mexLock_is_not_supported_by_Simulink_Coder\n\n#define mexUnlock() \\\n        mexUnlock_is_not_supported_by_Simulink_Coder\n\n#define mexFunctionName() \\\n        mexFunctionName_is_not_supported_by_Simulink_Coder\n\n#define mexIsLocked() \\\n        mexIsLocked_is_not_supported_by_Simulink_Coder\n\n#define mexGetFunctionHandle() \\\n        mexGetFunctionHandle_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLABFunction() \\\n        mexCallMATLABFunction_is_not_supported_by_Simulink_Coder\n\n#define mexRegisterFunction() \\\n        mexRegisterFunction_is_not_supported_by_Simulink_Coder\n\n#define mexSet(handle,property,value) \\\n        mexSet_is_not_supported_by_Simulink_Coder\n\n#define mexGet(handle,property) \\\n        mexGet_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLAB(nlhs,plhs,nrhs,prhs,fcn) \\\n        mexCallMATLAB_is_not_supported_by_Simulink_Coder\n\n#define mexSetTrapFlag(flag) \\\n        mexSetTrapFlag_is_not_supported_by_Simulink_Coder\n\n#define mexUnlink(a) \\\n        mexUnlink_is_not_supported_by_Simulink_Coderw\n\n#define mexSubsAssign(plhs,sub,nsubs,prhs) \\\n        mexSubsAssign_is_not_supported_by_Simulink_Coder\n\n#define mexSubsReference(prhs,subs,nsubs) \\\n        mexSubsReference_is_not_supported_by_Simulink_Coder\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexAddFlops(count) \\\n        mexAddFlops_is_not_supported_by_Simulink_Coder\n\n#define mexIsGlobal(pa) \\\n        mexIsGlobal_is_not_supported_by_Simulink_Coder\n\n#define mexAtExit(fcn) \\\n        mexAtExit_is_not_supported_by_Simulink_Coder\n\n/* [EOF] rt_matrx.c */\n"},{"name":"rt_printf.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2015 The MathWorks, Inc.\n *\n * File: rt_printf.c\n *\n * Abstract:\n *      Stub I/O printf facility for systems which don't have stdio.\n *\n */\n\n\n\n/* Function: rtPrintfNoOp ======================================================\n * Abstract:\n *      Maps ssPrintf to rtPrintfNoOp if HAVESTDIO is not defined (see\n *      simstruct.h\n */\nint rtPrintfNoOp(const char *fmt, ...)\n{\n    /* do nothing */\n    return(fmt == (const char *)0); /* use fmt to quiet unused var warning */\n}\n\n\n/* [eof] rt_printf.c */\n"},{"name":"rt_sim.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2012 The MathWorks, Inc.\n *\n * File    : rt_sim.c     \n * Abstract:\n *   Performs one time step of a real-time single tasking or multitasking\n *   system for statically or dynamically allocated timing data.\n *\n *   The tasking mode is controlled by the MULTITASKING #define.\n *\n *   The data allocation type is controlled by the RT_MALLOC #define.\n */\n\n\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stddef.h>\n#include \"tmwtypes.h\"\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n#include \"rt_sim.h\"\n\n/*==========*\n * Struct's *\n *==========*/\n\n/*\n * TimingData\n */\n\n#ifdef RT_MALLOC\n\n/* dynamically allocate data */\ntypedef struct TimingData_Tag {\n    real_T *period;       /* Task periods in seconds                   */\n    real_T *offset;       /* Task offsets in seconds                   */\n    real_T *clockTick;    /* Flint task time tick counter              */\n    int_T  *taskTick;     /* Counter for determining task hits         */\n    int_T  *nTaskTicks;   /* Number base rate ticks for a task hit     */\n    int_T  firstDiscIdx;  /* First discrete task index                 */\n} TimingData;\n\n#else\n\n/* statically allocate data */\ntypedef struct TimingData_Tag {\n    real_T period[NUMST];       /* Task periods in seconds                   */\n    real_T offset[NUMST];       /* Task offsets in seconds                   */\n    real_T clockTick[NUMST];    /* Flint task time tick counter              */\n    int_T  taskTick[NUMST];     /* Counter for determining task hits         */\n    int_T  nTaskTicks[NUMST];   /* Number base rate ticks for a task hit     */\n    int_T  firstDiscIdx;        /* First discrete task index                 */\n} TimingData;\n\n#endif\n\n/*=========================*\n * Data local to this file *\n *=========================*/\n\n#if defined(RT_MALLOC) || defined(USE_RTMODEL)\n/* \"td\" will be a pointer to a dynamically allocated struct */\n#else\n/* statically allocate the struct. \"td\" will point to this static struct */\nstatic TimingData td_struct;\n#endif\n\n/*==================*\n * Visible routines *\n *==================*/\n\n/* Function: rt_SimInitTimingEngine ============================================\n * Abstract:\n *      This function is for use with single tasking or multitasking\n *      real-time systems.  \n *\n *      Initializes the timing engine for a fixed-step real-time system. \n *      It is assumed that start time is 0.0.\n *\n * Returns:\n *      NULL     - success\n *      non-NULL - error string\n */\nconst char *rt_SimInitTimingEngine(int_T       rtmNumSampTimes,\n                                   real_T      rtmStepSize,\n                                   real_T      *rtmSampleTimePtr,\n                                   real_T      *rtmOffsetTimePtr,\n                                   int_T       *rtmSampleHitPtr,\n                                   int_T       *rtmSampleTimeTaskIDPtr,\n                                   real_T      rtmTStart,\n                                   SimTimeStep *rtmSimTimeStepPtr,\n                                   void        **rtmTimingDataPtr)\n{\n#ifdef USE_RTMODEL\n\n    /* In the USE_RTMODEL case this function does nothing */\n\n    UNUSED_PARAMETER(rtmNumSampTimes);\n    UNUSED_PARAMETER(rtmStepSize); \n    UNUSED_PARAMETER(rtmSampleTimePtr);\n    UNUSED_PARAMETER(rtmOffsetTimePtr);\n    UNUSED_PARAMETER(rtmSampleHitPtr);\n    UNUSED_PARAMETER(rtmSampleTimeTaskIDPtr);\n    UNUSED_PARAMETER(rtmSimTimeStepPtr);\n    UNUSED_PARAMETER(rtmTimingDataPtr);\n\n    if (rtmTStart != 0.0) {\n        return(\"Start time must be zero for real-time systems.  For non-zero start times you must use the Simulink solver module\");\n    } else {\n        return(NULL);\n    }\n\n#else /* must be !USE_RTMODEL */\n\n    int_T     i;\n    int       *tsMap     = rtmSampleTimeTaskIDPtr;\n    real_T    *period    = rtmSampleTimePtr;\n    real_T    *offset    = rtmOffsetTimePtr;\n    int_T     *sampleHit = rtmSampleHitPtr;\n    real_T    stepSize   = rtmStepSize;\n\n#ifdef RT_MALLOC\n\n    int_T numst = rtmNumSampTimes;\n\n    /* In the dynamically allocated case, we allocate the data here */\n    static const char_T *malloc_error;\n    TimingData *td;\n    malloc_error = \"Memory allocation error\";\n    td = (TimingData *) malloc(sizeof(TimingData));\n    if (!td) {\n        return(malloc_error);\n    }\n\n    td->period = (real_T *) malloc(numst * sizeof(real_T));\n    if (!td->period) {\n        return(malloc_error);\n    }\n\n    td->offset = (real_T *) malloc(numst * sizeof(real_T));\n    if (!td->offset) {\n        return(malloc_error);\n    }\n\n    td->clockTick = (real_T *) malloc(numst * sizeof(real_T));\n    if (!td->clockTick) {\n        return(malloc_error);\n    }\n\n    td->taskTick = (int_T *) malloc(numst * sizeof(int_T));\n    if (!td->taskTick) {\n        return(malloc_error);\n    }\n\n    td->nTaskTicks = (int_T *) malloc(numst * sizeof(int_T));\n    if (!td->nTaskTicks) {\n        return(malloc_error);\n    }\n    if (rtmTStart != 0.0) {\n        return(\"Start time must be zero for real-time systems.  For non-zero start times you must use the Simulink solver module\");\n    }\n\n#else /* must be !RT_MALLOC */\n\n    /* In the statically allocated case, we point to the static structure */\n    TimingData *td;\n    td = &td_struct;\n\n    /* Also, we use the constant NUMST instead of what was passed in */\n    rtmNumSampTimes = NUMST; \n\n#endif /* !RT_MALLOC */\n\n    if (rtmTStart != 0.0) {\n        return(\"Start time must be zero for real-time systems.  For non-zero start times you must use the Simulink solver module\");\n    }\n\n    *rtmSimTimeStepPtr = MAJOR_TIME_STEP;\n\n    *rtmTimingDataPtr = (void*)&td;\n\n    for (i = 0; i < rtmNumSampTimes; i++) {\n        tsMap[i]         = i;\n        td->period[i]     = period[i];\n        td->offset[i]     = offset[i];\n        td->nTaskTicks[i] = (int_T)floor(period[i]/stepSize + 0.5);\n        if (td->period[i] == CONTINUOUS_SAMPLE_TIME ||\n            td->offset[i] == 0.0) {\n            td->taskTick[i]  = 0;\n            td->clockTick[i] = 0.0;\n            sampleHit[i]    = 1;\n        } else {\n            td->taskTick[i]  = (int_T)floor((td->period[i]-td->offset[i]) /\n                                            stepSize+0.5);\n            td->clockTick[i] = -1.0;\n            sampleHit[i]    = 0;\n        }\n    }\n\n    /* Correct first sample time if continuous task */\n    td->period[0]     = stepSize;\n    td->nTaskTicks[0] = 1; \n\n    /* Set first discrete task index */\n    if (rtmNumSampTimes == 1)\n        td->firstDiscIdx = (int_T)(period[0] == CONTINUOUS_SAMPLE_TIME);\n    else\n        td->firstDiscIdx = ((int_T)(period[0] == CONTINUOUS_SAMPLE_TIME) + \n                          (int_T)(period[1] == CONTINUOUS_SAMPLE_TIME));\n\n    return(NULL); /* success */\n\n#endif /* ! USE_RTMODEL case */\n\n} /* end rt_SimInitTimingEngine */\n\n/* In the statically-allocated case, rt_SimDestroyTimingEngine is not needed. */\n#ifdef RT_MALLOC\n\n/* Dynamically allocated data */\n/* Function: rt_SimDestroyTimingEngine ===========================================\n * Abstract:\n *      This function frees the timing engine data.\n */\nvoid rt_SimDestroyTimingEngine(void *rtmTimingData)\n{\n#ifdef USE_RTMODEL\n    UNUSED_PARAMETER(rtmTimingData);\n#else /* must be !USE_RTMODEL */\n    TimingData *td;\n    td = (TimingData *)rtmTimingData;\n\n    if (td) {\n        if (td->period) {\n            free(td->period);\n        }\n        \n        if (td->offset) {\n            free(td->offset);\n        }\n        \n        if (td->clockTick) {\n            free(td->clockTick);\n        }\n        \n        if (td->taskTick) {\n            free(td->taskTick);\n        }\n        \n        if (td->nTaskTicks) {\n            free(td->nTaskTicks);\n        }\n        free(td);\n    }\n#endif /* !USE_RTMODEL */\n} /* end rt_SimDestroyTimingEngine */\n\n#endif /* RT_MALLOC */\n\n#if !defined(MULTITASKING)\n\n/*###########################################################################*/\n/*########################### SINGLE TASKING ################################*/\n/*###########################################################################*/\n\n/* Function: rt_SimGetNextSampleHit ============================================\n * Abstract:\n *      For a single tasking real-time system, return time of next sample hit.\n */\n/* This function has a different signature in the RT_MALLOC case */\n#ifdef RT_MALLOC\ntime_T rt_SimGetNextSampleHit(void   *rtmTimingData,\n                              int_T   rtmNumSampTimes)\n#else\ntime_T rt_SimGetNextSampleHit(void)\n#endif\n{\n#ifdef USE_RTMODEL\n\n    /* The USE_RTMODEL version of this function does nothing */\n\n#ifdef RT_MALLOC\n    UNUSED_PARAMETER(rtmTimingData);\n    UNUSED_PARAMETER(rtmNumSampTimes);\n#endif\n    return -1;\n\n#else /* must be !USE_RTMODEL */\n\n    time_T timeOfNextHit;\n#ifdef RT_MALLOC\n    TimingData *td;\n    td = (TimingData *)rtmTimingData;\n#else\n    TimingData *td;\n    int_T rtmNumSampTimes;\n    td = &td_struct;\n    rtmNumSampTimes = NUMST; /* it's not passed in, in this case */\n#endif\n    td->clockTick[0] += 1;\n    timeOfNextHit = td->clockTick[0] * td->period[0];\n\n    if(rtmNumSampTimes > 1) {\n        int i;\n        for (i = 1; i < rtmNumSampTimes; i++) {\n            if (++td->taskTick[i] == td->nTaskTicks[i]) {\n                td->taskTick[i] = 0;\n                td->clockTick[i]++;\n            }\n        }\n    }\n\n    return(timeOfNextHit);\n\n#endif /* !USE_RTMODEL */\n} /* end rt_SimGetNextSampleHit */\n\n\n\n/* Function: rt_SimUpdateDiscreteTaskSampleHits ================================\n * Abstract:\n *      This function is for use with single tasking real-time systems.  \n *      \n *      If the number of sample times is greater than one, then we need to \n *      update the discrete task sample hits for the next time step. Note, \n *      task 0 always has a hit since it's sample time is the fundamental \n *      sample time.\n */\nvoid rt_SimUpdateDiscreteTaskSampleHits(int_T  rtmNumSampTimes,\n                                        void   *rtmTimingData,\n                                        int_T  *rtmSampleHitPtr,\n                                        real_T *rtmTPtr)\n{\n#ifdef USE_RTMODEL\n\n    /* The USE_RTMODEL version of this function does nothing */\n    UNUSED_PARAMETER(rtmNumSampTimes);\n    UNUSED_PARAMETER(rtmTimingData);\n    UNUSED_PARAMETER(rtmSampleHitPtr);\n    UNUSED_PARAMETER(rtmTPtr);\n    return;\n\n#else /* must be !USE_RTMODEL */\n\n    int   i;\n    int_T *sampleHit;\n\n#ifdef RT_MALLOC\n    TimingData *td;\n    td = (TimingData *)rtmTimingData;\n#else\n    TimingData *td;\n    UNUSED_PARAMETER(rtmTimingData);\n    td = &td_struct;\n    rtmNumSampTimes = NUMST;\n#endif\n\n    sampleHit = rtmSampleHitPtr;\n\n    for (i = td->firstDiscIdx; i < rtmNumSampTimes; i++) {\n        int_T hit = (td->taskTick[i] == 0);\n        if (hit) {\n            rttiSetTaskTime(rtmTPtr, i,\n                            td->clockTick[i]*td->period[i] + td->offset[i]);\n        }\n        sampleHit[i] = hit;\n    }\n#endif /* !USE_RTMODEL */\n} /* rt_SimUpdateDiscreteTaskSampleHits */\n\n\n\n#else /* defined(MULTITASKING) */\n\n/*###########################################################################*/\n/*############################## MULTITASKING ###############################*/\n/*###########################################################################*/\n\n\n#ifndef USE_RTMODEL\n/* This function is not defined here if USE_RTMODEL is set */\n\n/* Function: rt_SimUpdateDiscreteEvents ========================================\n * Abstract:\n *      This function is for use with multitasking real-time systems. \n *\n *      This function updates the status of the RT_MODEL sampleHits\n *      flags and the perTaskSampleHits matrix which is used to determine \n *      when special sample hits occur.\n *\n *      The RT_MODEL contains a matrix, called perTaskSampleHits. \n *      This matrix is used by the ssIsSpecialSampleHit macro. The row and \n *      column indices are both task id's (equivalent to the root RT_MODEL \n *      sample time indices). This is a upper triangle matrix. This routine \n *      only updates the slower task hits (kept in column j) for row\n *      i if we have a sample hit in row i.\n *\n *                       column j\n *           tid   0   1   2   3   4   5  \n *               -------------------------\n *             0 |   | X | X | X | X | X |\n *         r     -------------------------\n *         o   1 |   |   | X | X | X | X |      This matrix(i,j) answers:\n *         w     -------------------------      If we are in task i, does\n *             2 |   |   |   | X | X | X |      slower task j have a hit now?\n *         i     -------------------------\n *             3 |   |   |   |   | X | X |\n *               -------------------------\n *             4 |   |   |   |   |   | X |      X = 0 or 1\n *               -------------------------\n *             5 |   |   |   |   |   |   |\n *               -------------------------\n *\n *      How macros index this matrix:\n *\n *          ssSetSampleHitInTask(S, j, i, X)   => matrix(i,j) = X\n *\n *          ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid) => \n *              (tid_for(promoted_sti) == tid && !minor_time_step &&\n *               matrix(tid,tid_for(my_sti)) \n *              )\n *\n *            my_sti       = My (the block's) original sample time index.\n *            promoted_sti = The block's promoted sample time index resulting\n *                           from a transition via a ZOH from a fast to a \n *                           slow block or a transition via a unit delay from \n *                           a slow to a fast block.\n *\n *      The perTaskSampleHits array, of dimension n*n, is accessed using \n *      perTaskSampleHits[j + i*n] where n is the total number of sample\n *      times, 0 <= i < n, and 0 <= j < n.  The C language stores arrays in \n *      row-major order, that is, row 0 followed by row 1, etc.\n * \n */\ntime_T rt_SimUpdateDiscreteEvents(int_T  rtmNumSampTimes,\n                                  void   *rtmTimingData,\n                                  int_T  *rtmSampleHitPtr,\n                                  int_T  *rtmPerTaskSampleHits)\n{\n    int   i, j;\n    int_T *sampleHit;\n#ifdef RT_MALLOC\n    TimingData *td;\n    td = (TimingData *)rtmTimingData;\n    rtmNumSampTimes = NUMST;\n#else    \n    TimingData *td;\n    UNUSED_PARAMETER(rtmTimingData);\n    td = &td_struct;\n#endif\n    sampleHit = rtmSampleHitPtr;\n    \n    /*\n     * Run this loop in reverse so that we do lower priority events first.\n     */\n    i = rtmNumSampTimes;\n    while (--i >= 0) {\n        if (td->taskTick[i] == 0) {\n            /* \n             * Got a sample hit, reset the counter, and update the clock\n             * tick counter.\n             */\n            sampleHit[i] = 1;\n            td->clockTick[i]++;\n\n            /*\n             * Record the state of all \"slower\" events \n             */\n            for (j = i + 1; j < rtmNumSampTimes; j++) {\n                rttiSetSampleHitInTask(rtmPerTaskSampleHits, rtmNumSampTimes,\n                                       j, i, sampleHit[j]);\n            }\n        } else {\n            /*\n             * no sample hit, increment the counter \n             */\n            sampleHit[i] = 0;\n        }\n\n        if (++td->taskTick[i] == td->nTaskTicks[i]) { /* update for next time */\n            td->taskTick[i] = 0;\n        }\n    }\n\n    return(td->clockTick[0]*td->period[0]);\n    \n} /* rt_SimUpdateDiscreteEvents */\n\n#endif /* !USE_RTMODEL */\n\n/* Function: rt_SimUpdateDiscreteTaskTime ======================================\n * Abstract:\n *      This function is for use with multitasking systems. \n *\n *      After a discrete task output and update has been performed, this \n *      function must be called to update the discrete task time for next \n *      time around.\n */\nvoid rt_SimUpdateDiscreteTaskTime(real_T *rtmTPtr,\n                                  void   *rtmTimingData,\n                                  int    tid)\n{\n#ifdef USE_RTMODEL\n    /* This function is a no-op in USE_RTMODEL */\n    UNUSED_PARAMETER(rtmTPtr);\n    UNUSED_PARAMETER(rtmTimingData);\n    UNUSED_PARAMETER(tid);\n    return;\n\n#else /* must be !USE_RTMODEL */\n\n#ifdef RT_MALLOC\n    TimingData *td;\n    td = (TimingData *)rtmTimingData;\n#else\n    TimingData *td;\n    UNUSED_PARAMETER(rtmTimingData);\n    td = &td_struct;\n#endif\n    rttiSetTaskTime(rtmTPtr, tid,\n                    td->clockTick[tid]*td->period[tid] + td->offset[tid]);\n\n#endif /* !USE_RTMODEL */\n}\n\n#endif /* MULTITASKING */\n\n/*\n *******************************************************************************\n * FUNCTIONS MAINTAINED FOR BACKWARDS COMPATIBILITY WITH THE SimStruct\n *******************************************************************************\n */\n#ifndef USE_RTMODEL\nconst char *rt_InitTimingEngine(SimStruct *S)\n{\n    const char_T *retVal = rt_SimInitTimingEngine(\n        ssGetNumSampleTimes(S),\n        ssGetStepSize(S),\n        ssGetSampleTimePtr(S),\n        ssGetOffsetTimePtr(S),\n        ssGetSampleHitPtr(S),\n        ssGetSampleTimeTaskIDPtr(S),\n        ssGetTStart(S),\n        &ssGetSimTimeStep(S),\n        &ssGetTimingData(S));\n    return(retVal);\n}\n\n# if !defined(MULTITASKING)\nvoid rt_UpdateDiscreteTaskSampleHits(SimStruct *S)\n{\n    rt_SimUpdateDiscreteTaskSampleHits(\n        ssGetNumSampleTimes(S),\n        ssGetTimingData(S),\n        ssGetSampleHitPtr(S),\n        ssGetTPtr(S));\n}\n\n#ifdef RT_MALLOC\ntime_T rt_GetNextSampleHit(SimStruct *S)\n{\n    return(rt_SimGetNextSampleHit(\n        ssGetTimingData(S),\n        ssGetNumSampleTimes(S)));\n}\n#else\ntime_T rt_GetNextSampleHit(void)\n{\n    return(rt_SimGetNextSampleHit());\n}\n#endif\n\n# else /* MULTITASKING */\n\ntime_T rt_UpdateDiscreteEvents(SimStruct *S)\n{\n    return(rt_SimUpdateDiscreteEvents(\n               ssGetNumSampleTimes(S),\n               ssGetTimingData(S),\n               ssGetSampleHitPtr(S),\n               ssGetPerTaskSampleHitsPtr(S)));\n}\n\nvoid rt_UpdateDiscreteTaskTime(SimStruct *S, int tid)\n{\n    rt_SimUpdateDiscreteTaskTime(ssGetTPtr(S), ssGetTimingData(S), tid);\n}\n\n#endif /* MULTITASKING */\n#endif /* USE_RTMODEL */\n\n/* EOF: rt_sim.c */\n"},{"name":"rtw_capi_examples.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2004-2008 The MathWorks, Inc.\n *\n * File: rtw_capi_examples.c     \n *\n * Abstract:\n *   Provides utility functions to traverse and access RTW generated C-API\n *   structures. The C-API structure types are provided in following 2 files.\n *\n *       matlabroot/rtw/c/src/rtw_capi.h & rtw_modelmap.h\n *\n *   The actual data structures arrays are generated by code generator in \n *   <MODEL>_capi.c, where <MODEL> is the name of the model.\n * \n *   The functions provided in this file are\n *       capi_PrintModelParameter - Prints a model parameter value to STDOUT\n */\n\n#include \"rtw_capi_examples.h\"\n#include <stddef.h>\n\n/* Function capi_PrintModelParameter ======================================= */\n/* Abstract:\n *   This function takes in ModelMappingInfo structure prints the value of \n *   ModelParameter - rtModelParameters[paramIdx] to STDOUT\n *     capiMap  - Pointer to the ModelMappingInfo structure in Real-Time model.\n *                Map of all C-API arrays and structures. \n *     paramIdx - Index of the Parameter in the rtModelParameters array \n *                generated by RTW in <MODEL>_capi.c\n */\nvoid capi_PrintModelParameter(rtwCAPI_ModelMappingInfo* capiMap,\n                              uint_T                    paramIdx) {\n    \n    const rtwCAPI_ModelParameters* modelParams;\n    const rtwCAPI_DataTypeMap*     dataTypeMap;\n    const rtwCAPI_DimensionMap*    dimMap;\n    const rtwCAPI_FixPtMap*        fxpMap;\n    const uint_T*                  dimArray;\n    void**                         dataAddrMap;\n\n    const char_T* paramName;\n    uint_T        addrIdx;\n    uint16_T      dataTypeIdx;\n    uint16_T      dimIndex;\n    uint16_T      fxpMapIdx;\n    uint8_T       slDataID;\n\n    void*                paramAddress;\n    const char_T*        cDataName;\n    unsigned short       isComplex;\n    uint8_T              numDims;\n    uint_T               dimArrayIdx;\n    rtwCAPI_Orientation  orientation;\n    uint_T*              actualDimensions;\n\n    int    idx;\n    real_T slope = 1.0;\n    real_T bias  = 0.0;\n    unsigned short modParamFlag = 0; \n\n    /* Assert the parameter index is less than total number of parameters */\n    assert(paramIdx < rtwCAPI_GetNumModelParameters(capiMap));\n\n    /* Get modelParams, an array of rtwCAPI_ModelParameters structure  */\n    modelParams = rtwCAPI_GetModelParameters(capiMap);\n    if (modelParams == NULL) return;\n    \n    /* Get Parameter Name */\n    paramName   = rtwCAPI_GetModelParameterName(modelParams, paramIdx); \n\n    /* Get Data Type attributes of the Model Parameter                       */\n    /* Accessing the data type information from capiMap is a 3 step process  *\n     * 1) Get the dataTypeMap Array from capiMap.                            *\n     * 2) Get the index into the above array, dataTypeIdx, from ModelParameter*\n     *    structure. The index will point to a rtwCAPI_DataTypeMap structure.*\n     * 3) From the structure, get the member values of the structure, namely *\n     *       o Simulink Data ID, can be one of the enumerated value          *\n     *           SS_DOUBLE, SS_SINGLE, SS_INT8, SS_UINT8, SS_INT16, SS_UINT16*\n     *            , SS_INT32, SS_UINT32, SS_BOOLEAN                          *\n     *       o Complexity                                                    *\n     *       o Data Size                                                     *\n     *    For complete structure see matlabroot/rtw/c/src/rtw_capi.h         */\n\n    dataTypeMap = rtwCAPI_GetDataTypeMap(capiMap);\n    if (dataTypeMap == NULL) return;\n    \n    dataTypeIdx = rtwCAPI_GetModelParameterDataTypeIdx(modelParams, paramIdx);\n    slDataID    = rtwCAPI_GetDataTypeSLId(dataTypeMap, dataTypeIdx);\n    cDataName   = rtwCAPI_GetDataTypeCName(dataTypeMap,dataTypeIdx);\n    isComplex   = rtwCAPI_GetDataIsComplex(dataTypeMap,dataTypeIdx);\n\n    /* Get Dimensions of the Model Parameter                                 */\n    /* Accessing the dimension from capiMap is a 4 step process              *\n     * 1) Get the dimMap array, an array of CAPI_DimensionMap struct         *\n     * 2) Get the dimArray array, an array of all the dimensions in the Map  *\n     * 3) Get the index into the dimMap array (dimIdx) from ModelParameter   *\n     *    structure. the index will point to rtwCAPI_Dimension structure     *\n     * 4) From the rtwCAPI_Dimension structure, get the following information*\n     *       o orientation (scalar | vector | matrix)                        *\n     *       o Number of dimensions (numDims)                                *\n     *       o index into the dimArray (dimArrayIdx)                         *\n     * 5) Using numDims and the dimArrayIdx, get the actual dimensions from  *\n     *    the dimArray                                                       *\n     *       uint_T ActualDims[numDims] = {dimArray[dimArrayIdx],            *\n     *                                     dimArray[dimArrayIdx+1],          *\n     *\t\t\t\t       ...                                   *\n     *\t\t\t\t       dimArray[dimArrayIdx+(numDims-1)]}    *\n     *    For e.g, scalar and 2-D parameters will have numDims = 2, So       *\n     *       uint_T ActualDims[2] = {dimArray[dimArrayIdx],                  *\n     *                               dimArray[dimArrayIdx +1]}               */\n    \n    dimMap   = rtwCAPI_GetDimensionMap(capiMap);\n    dimArray = rtwCAPI_GetDimensionArray(capiMap);\n\n    if ((dimMap == NULL) || (dimArray == NULL)) return;\n\n    dimIndex    = rtwCAPI_GetModelParameterDimensionIdx(modelParams, paramIdx);\n    numDims     = rtwCAPI_GetNumDims(dimMap, dimIndex); \n    dimArrayIdx = rtwCAPI_GetDimArrayIndex(dimMap, dimIndex);\n    orientation = rtwCAPI_GetOrientation(dimMap, dimIndex);\n\n    actualDimensions = (uint_T *) malloc(numDims*sizeof(uint_T));\n    for(idx=0; idx < numDims; idx++) {\n        actualDimensions[idx] = dimArray[dimArrayIdx + idx];\n    }\n    \n    /* Get fixed-point information of the parameter */\n    fxpMap = rtwCAPI_GetFixPtMap(capiMap);\n    if (fxpMap == NULL) return;\n    \n    fxpMapIdx = rtwCAPI_GetModelParameterFixPtIdx(modelParams, paramIdx);\n    if(fxpMapIdx > 0) {\n        /* Only Fixed-point parameters have fxpMapIdx > 0 */\n        real_T fracslope = rtwCAPI_GetFxpFracSlope(fxpMap,fxpMapIdx);\n        int8_T expt      = rtwCAPI_GetFxpExponent(fxpMap,fxpMapIdx);\n        \n        /* slope = fractional slope * 2^exponent \n         * fractional slope is also called Slope Adjustment Factor. \n         * Type \"help fixdt\" in MATLAB command window for more information\n         * on fixed point data types  \n         */\n        \n        slope = fracslope*pow(2.0,expt);\n        bias  = rtwCAPI_GetFxpBias(fxpMap,fxpMapIdx);\n    }\n\n    /* Get the address to this parameter                                     */\n    dataAddrMap = rtwCAPI_GetDataAddressMap(capiMap);\n    addrIdx     = rtwCAPI_GetModelParameterAddrIdx(modelParams,paramIdx);\n    paramAddress= (void *) rtwCAPI_GetDataAddress(dataAddrMap,addrIdx); \n\n    if (paramAddress == NULL) return;\n    \n    /* Print the parameter value */\n    capi_PrintParameter(paramName, paramAddress, slDataID, isComplex,\n                        actualDimensions, numDims, slope, bias);\n\n    /* Modify parameter with itself */\n    /* modParamflag is used as a flag to indicate whether you want to modify\n     * the parameter after you print the value. Set flag to 1 to modify    */\n    \n    if(modParamFlag &&\n       capi_ModifyParameter(paramAddress, paramAddress, orientation,\n                            actualDimensions, numDims, slDataID, isComplex)) {\n                                printf(\"Parameter modified with itself\\n\");\n                            }\n    free(actualDimensions);\n    return;\n}\n\n/* Function capi_PrintParameter ============================================\n * Abstract: \n *   Prints the name and value of the parameter.\n *   Scalar, Vector and matrix parameters are supported. \n *   N-Dimensional paramaters, where N > 2, are not supported.\n *\n * Note: The printing format assumes that the parameter is COLUMN-MAJOR  \n *       indexing.\n */\nvoid capi_PrintParameter(const char_T*  paramName,\n                         void*          paramAddress,\n                         uint8_T        slDataID,\n                         unsigned short isComplex,\n                         uint_T*        actualDims,\n                         uint_T         numDims,\n                         real_T         slope,\n                         real_T         bias) {\n\n    uint_T numRows  = actualDims[0];\n    uint_T numCols  = actualDims[1];\n    uint_T numPages = 0;\n    int rowIdx;\n    int colIdx;\n    int pageIdx;\n    if (numDims == 3) numPages = actualDims[2];\n\n        \n    printf(\"%s = \\n\", paramName);\n    switch(slDataID) {\n      case SS_DOUBLE :\n        if (isComplex) {\n            /* If is Complex and SS_DOUBLE, the data is of type creal_T */\n            creal_T* paramVal = (creal_T *) paramAddress;\n            for(rowIdx = 0; rowIdx < numRows; rowIdx++) {\n                for(colIdx = 0; colIdx < numCols; colIdx++) {\n                    printf(\"\\t%.4g + %.4g*i\", \n                           paramVal[colIdx*numRows + rowIdx].re,\n                           paramVal[colIdx*numRows + rowIdx].im);\n                }\n                putchar('\\n');\n            }\n        } else {\n            real_T* paramVal = (real_T *) paramAddress;\n            if (numDims == 3) {\n                for (pageIdx = 0; pageIdx < numPages; pageIdx++) {\n                    printf(\"ans(:,:,%d) =\\n\", pageIdx+1); \n                    for (rowIdx = 0; rowIdx < numRows; rowIdx++) {\n                        for (colIdx = 0; colIdx < numCols; colIdx++) {\n                            uint_T idx = rowIdx + numRows * colIdx +\n                                numRows * numCols * pageIdx;\n                            printf(\"\\t%.4g\", paramVal[idx]);\n                        }\n                        putchar('\\n');\n                    }\n                    putchar('\\n');\n                }\n            } else {\n                for(rowIdx = 0; rowIdx < numRows; rowIdx++) {\n                    for(colIdx = 0; colIdx < numCols; colIdx++) {\n                        printf(\"\\t%.4g\", paramVal[colIdx*numRows + rowIdx]);\n                    }\n                    putchar('\\n');\n                }\n            }\n        }\n        break;\n      case SS_INT32 :\n        if (isComplex) {\n            cint32_T* paramVal = (cint32_T *) paramAddress;\n            for(rowIdx = 0; rowIdx < numRows; rowIdx++) {\n                for(colIdx = 0; colIdx < numCols; colIdx++) {\n                    printf(\"\\t%d + %d*i\", \n                           paramVal[colIdx*numRows + rowIdx].re,\n                           paramVal[colIdx*numRows + rowIdx].im);\n                }\t\t\t\t\t\t\n                putchar('\\n');\n            }\n        } else {\n            int32_T* paramVal = (int32_T *) paramAddress;\n            for(rowIdx = 0; rowIdx < numRows; rowIdx++) {\n                for(colIdx = 0; colIdx < numCols; colIdx++) {\n                    int32_T intVal  = paramVal[colIdx*numRows + rowIdx];\n                    /* Real world value = (slope * stored integer) + bias */\n                    real_T  realVal = slope*(intVal) + bias;\n                    printf(\"\\t%.4g\", realVal);\n                }\n                putchar('\\n');\n            }\n        }\n        break;\n      default :\n        /* You can extend the switch-case to other Simulink DataIds\n         * case SS_SINGLE:\n         * case SS_UINT32:\n         * case SS_INT16:\n         * case SS_UINT16:\n         * case SS_INT8:\n         * case SS_UINT8:\n         * case SS_BOOLEAN\n         *\n         * This function skips other data types. */\n        printf(\"Unhandled Data Type: %s is skipped\\n\", paramName);\n        break;\n    }\n    return;\n}\n\n\n/* Function capi_ModifyModelParameter ====================================== */\n/* Abstract:\n *   This function takes in ModelMappingInfo structure modifies the value of \n *   ModelParameter - rtModelParameters[paramIdx] with the newValue.\n *     capiMap  - Pointer to the ModelMappingInfo structure in Real-Time model.\n *                Map of all C-API arrays and structures. \n *     paramIdx - Index of the Parameter in the rtModelParameters array \n *                generated by RTW in <MODEL>_capi.c\n *     newParam - Pointer tot he new value of the parameter\n */\nint_T capi_ModifyModelParameter(rtwCAPI_ModelMappingInfo* capiMap,\n                                uint_T                    paramIdx,\n                                void*                     newParam) {\n\n    const rtwCAPI_ModelParameters* modelParams;\n    const rtwCAPI_DataTypeMap*     dataTypeMap;\n    const rtwCAPI_DimensionMap*    dimMap;\n    const uint_T*                  dimArray;\n    void**                         dataAddrMap;\n\n    uint_T        addrIdx;\n    uint16_T      dataTypeIdx;\n    uint16_T      dimIndex;\n    uint8_T       slDataID;\n\n    void*                paramAddress;\n    unsigned short       isComplex;\n    uint8_T              numDims;\n    uint_T               dimArrayIdx;\n    rtwCAPI_Orientation  orientation;\n    uint_T*              actualDimensions;\n\n    int    idx;\n    int_T  retVal = 0; \n    \n    /* Get modelParams, an array of rtwCAPI_ModelParameters structure  */\n    modelParams = rtwCAPI_GetModelParameters(capiMap);\n    if (modelParams == NULL) return 0;\n\n    /* Assert the parameter index is less than total number of parameters */\n    assert(paramIdx < rtwCAPI_GetNumModelParameters(capiMap));\n\n    /* Accessing the data type information from capiMap                   */\n    dataTypeMap = rtwCAPI_GetDataTypeMap(capiMap);\n    if (dataTypeMap == NULL) return 0;\n    \n    dataTypeIdx = rtwCAPI_GetModelParameterDataTypeIdx(modelParams, paramIdx);\n    slDataID    = rtwCAPI_GetDataTypeSLId(dataTypeMap, dataTypeIdx);\n    isComplex   = rtwCAPI_GetDataIsComplex(dataTypeMap, dataTypeIdx);\n\n    /* Get Dimensions of the Model Parameter */\n    dimMap = rtwCAPI_GetDimensionMap(capiMap);\n    dimArray = rtwCAPI_GetDimensionArray(capiMap);\n    if ((dimMap == NULL) || (dimArray == NULL)) return 0;\n\n    dimIndex    = rtwCAPI_GetModelParameterDimensionIdx(modelParams, paramIdx);\n    orientation = rtwCAPI_GetOrientation(dimMap, dimIndex);\n    numDims     = rtwCAPI_GetNumDims(dimMap, dimIndex); \n    dimArrayIdx = rtwCAPI_GetDimArrayIndex(dimMap, dimIndex);\n\n    actualDimensions = (uint_T *) malloc(numDims*sizeof(uint_T));\n    for(idx=0; idx < numDims; idx++) {\n        actualDimensions[idx] = dimArray[dimArrayIdx + idx];\n    }\n\n    /* Get the address to this parameter */\n    dataAddrMap  = rtwCAPI_GetDataAddressMap(capiMap);\n    addrIdx      = rtwCAPI_GetModelParameterAddrIdx(modelParams, paramIdx);\n    paramAddress = (void *) rtwCAPI_GetDataAddress(dataAddrMap,addrIdx); \n    if (paramAddress == NULL) return 0;\n    \n    \n    retVal = capi_ModifyParameter(paramAddress, newParam,\n                                  orientation, actualDimensions, numDims,\n                                  slDataID, isComplex);\n    free(actualDimensions);\n    return retVal;\n}\n\n/* ============================================================================\n * Function: capi_ModifyParameter\n *\n * Abstract:\n *   This function modifies a parameter.\n *       _param      : Parameter address that needs to be modified\n *       _newParam   : Address of the new parameter value\n *       orientation : orientation of the parameter (scalar|vector|matrix)\n *       dims        : the dimensions vector (Num Rows    = dims[0],\n *                                            Num Columns = dims[1], \n *                                            Num Pages   = dims[2] ...)\n *       nDims       : the number of dimesnions (for scalar, vector and \n *                     2-D matrix, nDims=2. For n-D params nDims > 2)\n *       slDatatype  : the data type ID define in simstruc.h. can be one of \n *                     the enumerated value\n *                     SS_DOUBLE, SS_SINGLE, SS_INT8, SS_UINT8, SS_INT16, \n *                     SS_UINT16, SS_INT32, SS_UINT32, SS_BOOLEAN\n *       isComplex   : if the parameter is complex (isComplex = 1, if complex)\n */\n \nint_T capi_ModifyParameter(void                 *_param,\n                           void                 *_newParam,\n                           rtwCAPI_Orientation  orientation,\n                           uint_T               *dims,\n                           uint8_T              nDims,\n                           uint8_T              slDataType,\n                           unsigned short       isComplex) {\n    uint_T rowIdx;\n    uint_T colIdx;\n    uint_T pageIdx;\n\n    /* Switch over the slDataType to assess data type of the parameter */\n    switch (slDataType) {\n      case SS_DOUBLE: {\n          if(isComplex == 0) {\n              /* Type cast address to real_T: Non-Complex and Double */\n              real_T *param     = (real_T *) (_param);\n              real_T *newParam  = (real_T *) (_newParam); \n\n              /* Based on the orientation, assign new value to the parameter */\n              switch( orientation ) {\n                case rtwCAPI_SCALAR:\n                  *param = *newParam;\n                  break;\n                  \n                case rtwCAPI_VECTOR:\n                  /* Vector: NumRows = dims[0], NumColumns = 1 */\n                  /* Loop through rows to assign new values    */\n                  for(rowIdx = 0; rowIdx < dims[0]*dims[1]; rowIdx++) {\n                      param[rowIdx] = newParam[rowIdx];\n                  }\n                  break;\n                  \n                case rtwCAPI_MATRIX_COL_MAJOR:\n                  /* Matrix: NumRows = dims[0], NumColumns = dims[1]       *\n                   * Loop through rows and columns to assign new values.   *\n                   * Note: RTW declares a matrix data as column-major      *\n                   * A column-major matrix is one in which indexing        *\n                   * is column-wise instead of row-wise. For e.g           *\n                   * A = | 1  |   2    3 |\n                         |    |          |  \n                         | 4  |   5    6 |\n                         |    |          |\n                         | 7 \\|/  8    9 |     \n                   \n                     A[0]=1; A[1]=4; A[2]=7; A[3]=2; A[4]=5; and so on  \n                  */\n                  for(rowIdx = 0; rowIdx < dims[0]; rowIdx++) {\n                      for(colIdx = 0; colIdx < dims[1]; colIdx++) {\n                          param[colIdx*dims[0] + rowIdx] = \n                              newParam[colIdx*dims[0] + rowIdx];\n                      }\n                  }\n                  break;\n                  \n                case rtwCAPI_MATRIX_ROW_MAJOR:\n                  /* Matrix: NumRows = dims[0], NumColumns = dims[1]       *\n                   * Loop through rows and columns to assign new values    *\n                   * Note: RTW does not declare a matrix data as row       *\n                   * major.                                                *\n                   * A = | 1     2    3 |\n                         |------------> |\n                         | 4     5    6 |\n                         |              |\n                         | 7     8    9 |     \n                    \n                     A[0]=1; A[1]=2; A[2]=3; A[3]=4; A[4]=5; and so on  \n                  */\n                  for(rowIdx = 0; rowIdx < dims[0]; rowIdx++) {\n                      for(colIdx = 0; colIdx < dims[1]; colIdx++) {\n                          param[rowIdx*dims[1] + colIdx] =\n                              newParam[rowIdx*dims[1] + colIdx];\n                      }\n                  }\n                  break;\n                  \n                case rtwCAPI_MATRIX_COL_MAJOR_ND:\n                  /* N-Dimensional Parameters                             *\n                   * RTW always declares N-D Parameters as column-indexed */\n                  if (nDims == 3) {\n                      /* only handle 3-D parameters */\n                      for (pageIdx = 0; pageIdx < dims[2]; pageIdx++) {\n                          for (rowIdx = 0; rowIdx < dims[0]; rowIdx++) {\n                              for (colIdx = 0; colIdx < dims[1]; colIdx++) {\n                                  uint_T idx = rowIdx + dims[0] * colIdx +\n                                    dims[0] * dims[1] * pageIdx;\n                                  param[idx] = newParam[idx];\n                              }\n                          }\n                      }\n                  }\n                  break;\n                  \n                default:\n                  return(0);\n              } /* end switch(orientation) */\n          } /* end if(isComplex == 0) */\n          else {\n              /* Type cast address to creal_T: Complex and Double */\n              creal_T *param    = (creal_T *) (_param);\n              creal_T *newParam = (creal_T *) (_newParam);\n              \n              /* Based on the orientation, assign new value to the parameter */\n              switch( orientation ) {\n                case rtwCAPI_SCALAR:\n                  /* Assign real and complex values */\n                  param->re = newParam->re;\n                  param->im = newParam->im;\n                  break;\n                  \n                case rtwCAPI_VECTOR:\n                  /* Vector: NumRows = dims[0], NumColumns = 1 */\n                  /* Loop through rows to assign new values    */\n                  for(rowIdx = 0; rowIdx < dims[0]*dims[1]; rowIdx++) {\n                      param[rowIdx].re = newParam[rowIdx].re;\n                      param[rowIdx].im = newParam[rowIdx].im;\n                  }\n                  break;\n                  \n                case rtwCAPI_MATRIX_COL_MAJOR:\n                  /* Matrix: NumRows = dims[0], NumColumns = dims[1]       *\n                   * Loop through rows and columns to assign new values.   *\n                   * Note: MATLAB declares a matrix data as column-major   *\n                   * major. A column-major matrix is one in which indexing *\n                   * is column-wise instead of row-wise. For e.g           *\n                   * A = | 1  |   2    3 |\n                         |    |          |  \n                         | 4  |   5    6 |\n                         |    |          |\n                         | 7 \\|/  8    9 |     \n                    \n                     A[0]=1; A[1]=4; A[2]=7; A[3]=2; A[4]=5; and so on  \n                  */\n                  for(rowIdx = 0; rowIdx < dims[0]; rowIdx++) {\n                      for(colIdx = 0; colIdx < dims[1]; colIdx++) {\n                        param[colIdx*dims[0] + rowIdx].re = \\\n                            newParam[colIdx*dims[0] + rowIdx].re;\n                        param[colIdx*dims[0] + rowIdx].im = \\\n                            newParam[colIdx*dims[0] + rowIdx].im;\n                      }\n                  }\n                  break;\n                  \n                case rtwCAPI_MATRIX_ROW_MAJOR:\n                  /* Matrix: NumRows = dims[0], NumColumns = dims[1]       *\n                   * Loop through rows and columns to assign new values    *\n                   * Note: MATLAB does not declare a matrix data as row    *\n                   * major.                                                *\n                   * A = | 1     2    3 |\n                         |------------> |\n                         | 4     5    6 |\n                         |              |\n                         | 7     8    9 |     \n                    \n                     A[0]=1; A[1]=2; A[2]=3; A[3]=4; A[4]=5; and so on\n                  */\n                  \n                  for(rowIdx = 0; rowIdx < dims[0]; rowIdx++) {\n                      for(colIdx = 0; colIdx < dims[1]; colIdx++) {\n                          param[rowIdx*dims[1] + colIdx].re = \\\n                              newParam[rowIdx*dims[1] + colIdx].re;\n                          param[rowIdx*dims[1] + colIdx].im = \\\n                              newParam[rowIdx*dims[1] + colIdx].im;\n                      }\n                  }\n                  break;\n\n                case rtwCAPI_MATRIX_COL_MAJOR_ND:\n                  /* N-Dimensional Parameters                             *\n                   * RTW always declares N-D Parameters as column-indexed */\n                  if (nDims == 3) {\n                      /* only handle 3-D parameters */\n                      for (pageIdx = 0; pageIdx < dims[2]; pageIdx++) {\n                          for (rowIdx = 0; rowIdx < dims[0]; rowIdx++) {\n                              for (colIdx = 0; colIdx < dims[1]; colIdx++) {\n                                  uint_T idx = rowIdx + dims[0] * colIdx +\n                                      dims[0] * dims[1] * pageIdx;\n                                  param[idx].re = newParam[idx].re;\n                                  param[idx].im = newParam[idx].im;\n                              }\n                          }\n                      }\n                  }\n                  break;\n                  \n                default:\n                  return(0);\n              } /* end switch(orientation) */\n          } /* end else */\n      } /* end case SS_DOUBLE*/\n        break;\n\n      case SS_INT32:  {\n          /* Type cast address to int32_T: signed 32 bit integer     */\n          /* Note: You could check for complexity here by using      *\n           * isComplex == 1 (as done for case SS_DOUBLE).            */\n\n          int32_T *param    = (int32_T *) (_param);\n          int32_T *newParam = (int32_T *) (_newParam); /* param's new value */\n          \n          switch( orientation ) {\n            case rtwCAPI_SCALAR:\n              *param = *newParam;\n              break;\n              \n            case rtwCAPI_VECTOR:\n              for(rowIdx = 0; rowIdx < dims[0]*dims[1]; rowIdx++) {\n                  param[rowIdx] = newParam[rowIdx];\n              }\n              break;\n              \n            case rtwCAPI_MATRIX_ROW_MAJOR:\n              for(rowIdx = 0; rowIdx < dims[0]; rowIdx++) {\n                  for(colIdx = 0; colIdx < dims[1]; colIdx++) {\n                      param[rowIdx*dims[1] + colIdx] = \\\n                          newParam[rowIdx*dims[1] + colIdx];\n                  }\n              }\n              break;\n              \n            case rtwCAPI_MATRIX_COL_MAJOR:\n              for(rowIdx = 0; rowIdx < dims[0]; rowIdx++) {\n                  for(colIdx = 0; colIdx < dims[1]; colIdx++) {\n                      param[colIdx*dims[0] + rowIdx] = \\\n                          newParam[colIdx*dims[0] + rowIdx];\n                  }\n              }\n              break;\n              \n            default:\n              return(0);\n          } /* end switch(orientation) */\n      } /* end case SS_INT32 */\n        break;\n        \n      default:\n        /* You can extend the switch-case to other Simulink DataIds\n         * case SS_SINGLE:\n         * case SS_UINT32:\n         * case SS_INT16:\n         * case SS_UINT16:\n         * case SS_INT8:\n         * case SS_UINT8:\n         * case SS_BOOLEAN\n         *\n         * This function skips other data types. */\n        printf(\"Cannot handle parameter data type. \\n\");\n        return(0);\n    }\n    return(1);\n}\n\n/* EOF - rtw_capi_examples.c */\n"},{"name":"rtw_linux.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* Copyright 2011-2019 The MathWorks, Inc. */\n#include <pthread.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <semaphore.h>\n#include \"rtw_linux.h\"\n\n#ifndef __USE_UNIX98\n#define __USE_UNIX98\n#endif\n\nextern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);\nextern int pthread_mutexattr_settype(pthread_mutexattr_t *, int);\n\nvoid rtw_pthread_mutex_init( void** mutexDW )\n{\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_setprotocol(&attr, 1); /* PTHREAD_PRIO_INHERIT */\n    #if defined(VXWORKS) || defined(__QNX__)\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    #else\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE_NP);\n    #endif\n    *mutexDW = malloc(sizeof(pthread_mutex_t));\n    pthread_mutex_init((pthread_mutex_t *)(*mutexDW), &attr);\n}\n\ntypedef struct {\n    void      (*func)(void);\n    sem_t     semaphore;\n    sem_t     doneSema;\n    pthread_t thread;\n    int       isPrioritySet;\n} pthread_task_T;\n\nvoid* rtw_worker_task(void *arg_) {\n    pthread_task_T *arg = arg_;\n    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,NULL);\n    while (1) {\n        sem_wait(&(arg->semaphore));\n        arg->func(); /* execute the task body */\n        sem_post(&(arg->doneSema));\n    }\n}\n\nvoid* rtw_register_task(void(*f)(void)){\n  pthread_task_T *arg = (pthread_task_T*)malloc(sizeof(pthread_task_T));\n  sem_init(&(arg->semaphore), 0, 0);\n  sem_init(&(arg->doneSema), 0, 0);\n  arg->func = f;\n  arg->isPrioritySet = 0;\n  pthread_create(&(arg->thread), NULL, rtw_worker_task, arg);\n  return arg;\n}\n\nvoid rtw_trigger_task(void *arg_){\n  pthread_task_T *arg= (pthread_task_T*) arg_;\n  int schedPolicy;\n  struct sched_param schedParam;\n  /* Adjust thread priority if different than the calling thread's priority */\n  if (arg->isPrioritySet == 0) {\n    pthread_getschedparam(pthread_self(), &schedPolicy, &schedParam);\n    pthread_setschedparam(arg->thread, schedPolicy, &schedParam);\n    arg->isPrioritySet = 1;\n  }\n  sem_post(&arg->semaphore);\n}\n\nvoid rtw_waitfor_task(void *arg){\n  sem_wait(&(((pthread_task_T *)arg)->doneSema));\n}\n\nvoid rtw_deregister_task(void *arg_){\n  int s;\n  pthread_task_T *arg = arg_;\n  pthread_cancel(arg->thread);\n  s = pthread_join(arg->thread, NULL);\n  if( s != 0){\n    fprintf(stderr, \"pthread_join returned error %d\\n\", s);\n  }\n  sem_destroy(&(arg->semaphore));\n  sem_destroy(&(arg->doneSema));\n  free(arg);\n}\n/* LocalWords:  PTHREAD PRIO pthread\n */\n"},{"name":"rtw_linux_mac.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* Copyright 2011-2016 The MathWorks, Inc. */\n#include <pthread.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <semaphore.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"rtw_linux_mac.h\"\n\n#ifndef __USE_UNIX98\n#define __USE_UNIX98\n#endif\n\nextern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);\n\nextern int pthread_mutexattr_settype(pthread_mutexattr_t *, int);\n\nvoid rtw_pthread_mutex_init_mac( void** mutexDW )\n{\n    pthread_mutexattr_t attr;       \n    pthread_mutexattr_setprotocol(&attr, 1);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    *(mutexDW) = malloc(sizeof(pthread_mutex_t));\n    pthread_mutex_init((pthread_mutex_t *)(*(mutexDW)), &attr);\n}\n\nvoid rtw_pthread_sem_create_mac( void** semaphoreDW1, void** semaphoreDW2, long initVal )\n{\n    static int semcount = 0;\n    char* semName = malloc(sizeof(char)*32);\n    sprintf(semName, \"sem_sync_%x%x\", semcount++, getpid());\n    \n    *semaphoreDW1 = sem_open(semName, O_CREAT | O_EXCL, 0777, (int)initVal);\n    *semaphoreDW2 = (void*)semName;\n}\n\ntypedef struct {\n    void      (*func)(void);\n    sem_t*     semaphore;\n    char*      semaphoreName;\n    sem_t*     doneSemaphore;\n    char*      doneSemaphoreName;\n    pthread_t thread;\n} pthread_task_T;\n\nvoid* rtw_worker_task(void *_arg) {\n    pthread_task_T *arg = _arg;\n    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,NULL);\n    while (1) {\n        sem_wait(arg->semaphore);\n        arg->func(); /* execute the task body */\n        sem_post(arg->doneSemaphore);\n    }\n}\n\nvoid* rtw_register_task(void(*f)(void)){\n  static int semcount = 0;\n  pthread_task_T *arg = (pthread_task_T*)malloc(sizeof(pthread_task_T));\n  arg->semaphoreName = malloc(sizeof(char)*32);\n  arg->doneSemaphoreName = malloc(sizeof(char)*32);\n  sprintf(arg->semaphoreName, \"Semaphore_%x\", semcount);\n  sprintf(arg->doneSemaphoreName, \"doneSemaphore_%x\", semcount++);\n  arg->semaphore = sem_open(arg->semaphoreName, O_CREAT | O_EXCL, 0777, 0);\n  arg->doneSemaphore = sem_open(arg->doneSemaphoreName, O_CREAT | O_EXCL, 0777, 0);\n  arg->func = f;\n  pthread_create(&(arg->thread), NULL, rtw_worker_task, arg);\n  return arg;\n}\n\nvoid rtw_trigger_task(void *arg){\n  sem_post(((pthread_task_T *)arg)->semaphore);\n}\n\nvoid rtw_waitfor_task(void *arg){\n  sem_wait(((pthread_task_T *)arg)->doneSemaphore);\n}\n\nvoid rtw_deregister_task(void *_arg){\n  int s;\n  pthread_task_T *arg = _arg;\n  pthread_cancel(arg->thread);\n  s = pthread_join(arg->thread, NULL);\n  if(s != 0){\n    fprintf(stderr, \"pthread_join returned error %d\\n\", s);\n  }\n  sem_close(arg->semaphore);\n  sem_close(arg->doneSemaphore);\n  sem_unlink(arg->semaphoreName);\n  sem_unlink(arg->doneSemaphoreName);\n  free(arg->semaphoreName);\n  free(arg->doneSemaphoreName);\n  free(arg);\n}\n/* LocalWords:  PTHREAD PRIO DW\n */\n"},{"name":"rtw_modelmap_utils.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* Copyright 2003-2020 The MathWorks, Inc. */\n\n/**\n * Utility functions to traverse and access information from ModelMappingInfo\n *\n */\n\n#ifdef SL_INTERNAL\n\n# include \"version.h\"\n# include \"util/memmgr/memalloc.hpp\"\n# include \"util/utassert.hpp\"\n# include \"simstruct/simstruc_types.h\"\n# include \"simulinkcoder_capi/rtw_modelmap.h\"\n\n#else\n\n# include <stdlib.h>\n# include <assert.h>\n\n# define  utFree(arg)    if (arg) free(arg)\n# define  utMalloc(arg)  malloc(arg)\n# define  utAssert(exp)  assert(exp)\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n# if defined(__LCC__)\n#   define UNUSED_PARAMETER(x)  /* do nothing */\n# else\n/*\n * This is the semi-ANSI standard way of indicating that a\n * unused function parameter is required.\n */\n#   define UNUSED_PARAMETER(x) (void) (x)\n# endif\n#endif\n\n# include \"builtin_typeid_types.h\"\n# include \"rtwtypes.h\"\n# include \"rtw_modelmap.h\"\n\n#endif\n\n#include <string.h>\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nstatic const char_T* rtwCAPI_mallocError = \"Memory Allocation Error\";\n\n/** Function: rtwCAPI_EncodePath ===============================================\n *  Abstract:\n *     Escape all '|' characters in bpath. For examples 'aaa|b' will become\n *     'aaa~|b'. The caller is responsible for freeing the returned string\n *\n *\n * NOTE: returned string can be NULL in two cases:\n *     (1) string passed in was NULL\n *     (2) a memory allocation error occurred\n * In the second case, the caller need to report the error\n */\nchar* rtwCAPI_EncodePath(const char* path)\n{\n    char* encodedPath     = NULL;\n    size_t pathLen        = (path==NULL) ? 0:strlen(path) + 1;\n    size_t encodedPathLen = pathLen;\n    unsigned i;\n    unsigned j = 0;\n\n    if (path == NULL) return NULL;\n\n    for (i = 0; i < pathLen; ++i) {\n        if (path[i] == '|' || path[i] == '~') ++encodedPathLen;\n    }\n\n    encodedPath = (char_T*)utMalloc(encodedPathLen*sizeof(char_T));\n    if (encodedPath == NULL) return encodedPath;\n\n    for (i = 0; i < pathLen; ++i) {\n        char ch = path[i];\n        if (ch == '~' || ch == '|') encodedPath[j++] = '~';\n        encodedPath[j++] = ch;\n    }\n    utAssert(j == encodedPathLen);\n    utAssert(encodedPath[j-1] == '\\0');\n\n    return encodedPath;\n\n} /* rtwCAPI_EncodePath */\n\n/** Function: rtwCAPI_GetSigAddrFromMap ========================================\n *\n */\nvoid rtwCAPI_GetSigAddrFromMap(uint8_T      isPointer,\n                               int_T*       sigComplexity,\n                               int_T*       sigDataType,\n                               void**       sigDataAddr,\n                               int_T*       sigIdx,\n                               uint_T       mapIdx,\n                               void**       dataAddrMap)\n{\n    if (isPointer) {\n        /* Dereference pointer and cache the address */\n\n        /* Imported Pointers cannot be complex - Assert */\n        utAssert(sigComplexity[*sigIdx] != 1);\n        UNUSED_PARAMETER(sigComplexity);\n\n        /* Check for data type and dereference accordingly */\n        switch (sigDataType[*sigIdx]) {\n          case SS_DOUBLE:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((real_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_SINGLE:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((real32_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_UINT32:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((uint32_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_INT32:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((int32_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_UINT16:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((uint16_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_INT16:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((int16_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_UINT8:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((uint8_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_INT8:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((int8_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_BOOLEAN:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((boolean_T **) dataAddrMap[mapIdx]);\n            break;\n          default:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((real_T **) dataAddrMap[mapIdx]);\n            break;\n        }  /* end switch */\n    } else {\n        /* if Data is not a pointer store the address directly */\n        sigDataAddr[*sigIdx] = dataAddrMap[mapIdx];\n    }\n\n} /* rtwCAPI_GetSigAddrFromMap */\n\n\n/** Function: rtwCAPI_HasStates ================================================\n *\n */\nboolean_T rtwCAPI_HasStates(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nCMMI;\n\n    if (mmi == NULL) return(0U);\n\n    if (rtwCAPI_GetNumStates(mmi) > 0) return(1U);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        if (rtwCAPI_HasStates(rtwCAPI_GetChildMMI(mmi,i))) return(1U);\n    }\n    return(0U);\n\n} /* rtwCAPI_HasStates */\n\n\n\n/** Function: rtwCAPI_GetNumStateRecords =======================================\n *\n */\nint_T rtwCAPI_GetNumStateRecords(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs;\n    int_T nCMMI;\n\n    if (mmi == NULL) return(0);\n\n    nRecs = rtwCAPI_GetNumStates(mmi);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumStateRecords(cMMI);\n    }\n    return(nRecs);\n\n} /* rtwCAPI_GetNumStateRecords */\n\n\n/** Function: rtwCAPI_GetNumStateRecordsForRTWLogging ==========================\n *\n */\nint_T rtwCAPI_GetNumStateRecordsForRTWLogging(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs = 0;\n    int_T nStates;\n    int_T nCMMI;\n    const rtwCAPI_States *states;\n    const rtwCAPI_DataTypeMap* dataTypeMap;\n\n    if (mmi == NULL) return(0);\n\n    nStates = rtwCAPI_GetNumStates(mmi);\n    states = rtwCAPI_GetStates(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n\n    for (i = 0; i < nStates; ++i) {\n        if (rtwCAPI_CanLogStateToMATFile(dataTypeMap, states, i)) {\n            ++nRecs;\n        }\n    }\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumStateRecordsForRTWLogging(cMMI);\n    }\n\n    return(nRecs);\n\n} /* rtwCAPI_GetNumStateRecordsForRTWLogging */\n\n\n/** Function: rtwCAPI_GetNumContStateRecords ===================================\n *\n */\nint_T rtwCAPI_GetNumContStateRecords(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs;\n    int_T nCMMI;\n    int_T nCStateRecs;\n    const rtwCAPI_States* states;\n    const rtwCAPI_DataTypeMap* dataTypeMap;\n\n    if (mmi == NULL) return 0;\n\n    nCStateRecs = 0;\n    states      = rtwCAPI_GetStates(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n\n    nRecs = rtwCAPI_GetNumStates(mmi);\n    for (i = 0; i < nRecs; i++) {\n        if (rtwCAPI_IsAContinuousState(states,i)) {\n            ++nCStateRecs;\n\n            /* All continuous states should be able to be logged to MAT-File\n             * so we do not need to skip any states here. */\n            utAssert(rtwCAPI_CanLogStateToMATFile(dataTypeMap, states, i));\n        }\n    }\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nCStateRecs += rtwCAPI_GetNumContStateRecords(cMMI);\n    }\n    return nCStateRecs;\n\n} /* rtwCAPI_GetNumContStateRecords */\n\n\n/** Function: rtwCAPI_FreeFullPaths ============================================\n *\n */\nvoid rtwCAPI_FreeFullPaths(rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T   i;\n    int_T   nCMMI;\n    char_T* fullPath;\n\n    if (mmi == NULL) return;\n\n    fullPath = rtwCAPI_GetFullPath(mmi);\n    utAssert(fullPath != NULL);\n    utFree(fullPath);\n    rtwCAPI_SetFullPath(*mmi, NULL);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        rtwCAPI_FreeFullPaths(cMMI);\n    }\n\n} /* rtwCAPI_FreeFullPaths */\n\n\n/** Function: rtwCAPI_UpdateFullPaths =========================================*\n *\n */\nconst char_T* rtwCAPI_UpdateFullPaths(rtwCAPI_ModelMappingInfo* mmi,\n                                      const char_T* path,\n                                      boolean_T isCalledFromTopModel)\n{\n    int_T         i;\n    int_T         nCMMI;\n    size_t        pathLen;\n    char_T*       mmiPath;\n    size_t        mmiPathLen;\n    char_T*       relMMIPath;\n    size_t        relMMIPathLen;\n\n    if (mmi == NULL) return NULL;\n\n    utAssert(path != NULL);\n    utAssert( rtwCAPI_GetFullPath(mmi) == NULL );\n\n    pathLen = strlen(path)+1;\n\n    if (isCalledFromTopModel) {\n        /* If called from top model - FullPath is same as path */\n        mmiPath = (char_T*)utMalloc(pathLen*sizeof(char_T));\n        (void)memcpy(mmiPath, path, pathLen*sizeof(char_T));\n    }\n    else {        \n        relMMIPath = rtwCAPI_EncodePath(rtwCAPI_GetPath(mmi));\n        if ( (relMMIPath== NULL) && (rtwCAPI_GetPath(mmi) != NULL)) {\n            return rtwCAPI_mallocError;\n        }\n        relMMIPathLen = relMMIPath ? (strlen(relMMIPath) + 1) : 0;\n        \n        mmiPathLen = pathLen + relMMIPathLen;\n        \n        mmiPath = (char_T*)utMalloc(mmiPathLen*sizeof(char_T));\n        if (mmiPath == NULL) return rtwCAPI_mallocError;\n        (void)memcpy(mmiPath, path, pathLen*sizeof(char_T));\n        utAssert(mmiPath[pathLen-1] == '\\0');\n        \n        if (relMMIPath) {\n            /* mmiPath = path + | + relMMIPath + '\\0' */\n            mmiPath[pathLen-1] = '|';\n            (void)memcpy(&(mmiPath[pathLen]),\n                         relMMIPath, relMMIPathLen*sizeof(char_T));\n            utAssert(mmiPath[mmiPathLen-1] == '\\0');\n            utFree(relMMIPath);\n        }\n    }\n    rtwCAPI_SetFullPath(*mmi, mmiPath);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        const char_T* errstr = rtwCAPI_UpdateFullPaths(cMMI, mmiPath, 0);\n        if (errstr != NULL) return errstr;\n    }\n    return NULL;\n\n} /* rtwCAPI_UpdateFullPaths */\n\n\n/** Function: rtwCAPI_GetFullStateBlockPath ===================================\n *\n */\nchar* rtwCAPI_GetFullStateBlockPath(const char* stateBlockPath,\n                                           const char* mmiPath,\n                                           size_t      mmiPathLen,\n                                           boolean_T   crossingModel)\n{\n    char_T* blockPath          = NULL;\n    char_T* fullStateBlockPath = NULL;\n    size_t     fullStateBlockPathLen;\n\n    if (stateBlockPath == NULL) goto EXIT_POINT;\n\n    /* fullStateBlockPath = mmiPath + | + blockPath + '\\0' */\n    /* If crossing a model boundary encode, otherwise do not */\n\n    if (crossingModel) {\n        blockPath = rtwCAPI_EncodePath(stateBlockPath);\n        if (blockPath == NULL) goto EXIT_POINT;\n    } else {\n        size_t len = strlen(stateBlockPath)+1;\n        blockPath = (char*)utMalloc(len*sizeof(char));\n        if (blockPath == NULL) goto EXIT_POINT;\n        (void)strcpy(blockPath,stateBlockPath);\n    }\n    utAssert(blockPath != NULL);\n    fullStateBlockPathLen = ( (mmiPath==NULL) ?\n                              strlen(blockPath) + 1 :\n                              mmiPathLen + strlen(blockPath) + 2 );\n    fullStateBlockPath    = (char*)utMalloc(fullStateBlockPathLen*sizeof(char));\n    if (fullStateBlockPath == NULL) goto EXIT_POINT;\n\n    if (mmiPath != NULL) {\n        (void)strcpy(fullStateBlockPath, mmiPath);\n        fullStateBlockPath[mmiPathLen]   = '|';\n        fullStateBlockPath[mmiPathLen+1] =  '\\0';\n        (void)strcat(fullStateBlockPath, blockPath);\n    } else {\n        (void)strcpy(fullStateBlockPath, blockPath);\n        fullStateBlockPath[fullStateBlockPathLen-1] =  '\\0';\n    }\n    utAssert(fullStateBlockPath[fullStateBlockPathLen-1] == '\\0');\n\n  EXIT_POINT:\n    utFree(blockPath);\n    return fullStateBlockPath; /* caller is responsible for free */\n}\n\nuint_T rtwCAPI_GetStateWidth(const rtwCAPI_DimensionMap* dimMap,\n                             const uint_T*               dimArray,\n                             const rtwCAPI_States*       states,\n                             uint_T                      iState)\n{\n    uint_T mapIdx = rtwCAPI_GetStateDimensionIdx(states, iState);\n    uint_T numDims = rtwCAPI_GetNumDims(dimMap,mapIdx);\n    uint_T width = 1;\n    uint_T i = 0;\n    utAssert( numDims > 0 );\n    mapIdx = rtwCAPI_GetDimArrayIndex(dimMap, mapIdx);\n    for (i = 0; i < numDims; i++) {\n        width *= dimArray[mapIdx+i];\n    }\n    return width;\n}\n\n\n\n/** Function: rtwCAPI_GetStateRecordInfo =======================================\n *\n */\nconst char_T* rtwCAPI_GetStateRecordInfo(const rtwCAPI_ModelMappingInfo* mmi,\n                                         const char_T**    sigBlockName,\n                                         const char_T**    sigLabel,\n                                         const char_T**    sigName,\n                                         int_T*            sigWidth,\n                                         int_T*            sigDataType,\n                                         int_T*            logDataType,\n                                         int_T*            sigComplexity,\n                                         void**            sigDataAddr,\n                                         RTWLoggingFcnPtr* RTWLoggingPtrs,\n                                         boolean_T*        sigCrossMdlRef,\n                                         boolean_T*        sigInProtectedMdl,\n                                         const char_T**    sigPathAlias,\n                                         real_T*           sigSampleTime,\n                                         int_T*            sigHierInfoIdx,\n                                         uint_T*           sigFlatElemIdx,                                         \n                                         const rtwCAPI_ModelMappingInfo** sigMMI,\n                                         int_T*            sigIdx,\n                                         boolean_T         crossingModel,\n                                         boolean_T         isInProtectedMdl,\n                                         real_T*           contStateDeriv,\n                                         boolean_T         rtwLogging)\n{\n    int_T               i;\n    int_T               nCMMI;\n    int_T               nStates;\n    const char_T*       mmiPath;\n    size_t              mmiPathLen;\n    const rtwCAPI_States*  states;\n    const rtwCAPI_DimensionMap* dimMap;\n    const uint_T*       dimArray;\n    const rtwCAPI_DataTypeMap*  dataTypeMap;\n    void**              dataAddrMap;\n    RTWLoggingFcnPtr* RTWLoggingPtrsMap;\n    const char_T*       errstr = NULL;\n    uint8_T             isPointer = 0;\n\n    if (mmi == NULL) goto EXIT_POINT;\n    isInProtectedMdl = isInProtectedMdl || rtwCAPI_IsProtectedModel(mmi);\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        real_T* childContStateDeriv = NULL;\n\n        if (cMMI == NULL) continue;\n\n        if (contStateDeriv) {\n            int idx;\n\n            idx = rtwCAPI_MMIGetContStateStartIndex(cMMI);\n            if(idx == -1) continue;\n            \n            childContStateDeriv = &contStateDeriv[idx];\n        }\n        errstr = rtwCAPI_GetStateRecordInfo(cMMI,\n                                            sigBlockName,\n                                            sigLabel,\n                                            sigName,\n                                            sigWidth,\n                                            sigDataType,\n                                            logDataType,\n                                            sigComplexity,\n                                            sigDataAddr,\n                                            RTWLoggingPtrs,\n                                            sigCrossMdlRef,\n                                            sigInProtectedMdl,\n                                            sigPathAlias,\n                                            sigSampleTime,\n                                            sigHierInfoIdx,\n                                            sigFlatElemIdx,\n                                            sigMMI,\n                                            sigIdx,\n                                            0x1, /* true, */\n                                            isInProtectedMdl,\n                                            childContStateDeriv,\n                                            rtwLogging);\n        if (errstr != NULL) goto EXIT_POINT;\n    }\n\n    nStates = rtwCAPI_GetNumStates(mmi);\n    if (nStates < 1) goto EXIT_POINT;\n\n    mmiPath     = rtwCAPI_GetFullPath(mmi);\n    mmiPathLen  = (mmiPath==NULL)? 0 : strlen(mmiPath);\n    states      = rtwCAPI_GetStates(mmi);\n    dimMap      = rtwCAPI_GetDimensionMap(mmi);\n    dimArray    = rtwCAPI_GetDimensionArray(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n    dataAddrMap = rtwCAPI_GetDataAddressMap(mmi);\n    RTWLoggingPtrsMap = rtwCAPI_GetRTWLoggingPtrsMap(mmi);\n\n    for (i = 0; i < nStates; ++i) {\n        uint_T      mapIdx;\n\n        /* If collecting continuous states, skip non-continuous states */\n        if (contStateDeriv && !rtwCAPI_IsAContinuousState(states,i)) continue;\n\n        /* For RTW logging, skip states that cannot be logged to MAT-File. */\n        if ((rtwLogging) &&\n            (rtwCAPI_CanLogStateToMATFile(dataTypeMap, states, i) == false)) continue;\n\n        /* BlockPath (caller is responsible for free) */\n        sigBlockName[*sigIdx] =\n            rtwCAPI_GetFullStateBlockPath(rtwCAPI_GetStateBlockPath(states,i),\n                                          mmiPath, mmiPathLen, crossingModel);\n        if (sigBlockName[*sigIdx] == NULL) {\n            errstr = rtwCAPI_mallocError;\n            goto EXIT_POINT;\n        }\n\n        /* Label */\n        if (rtwCAPI_IsAContinuousState(states,i)){\n            sigLabel[*sigIdx] = \"CSTATE\";\n        } else {\n            sigLabel[*sigIdx] = \"DSTATE\";\n        }\n        sigName[*sigIdx] = rtwCAPI_GetStateName(states, i);\n\n        /* Width */\n        sigWidth[*sigIdx] = rtwCAPI_GetStateWidth(dimMap, dimArray, states, i);\n\n        /* DataType and logDataType */\n        mapIdx = rtwCAPI_GetStateDataTypeIdx(states, i);\n        sigDataType[*sigIdx] = rtwCAPI_GetDataTypeSLId(dataTypeMap, mapIdx);\n        /* this mimics code in simulink.dll:DtGetDataTypeLoggingId() */\n        if (logDataType) {\n            switch (sigDataType[*sigIdx]) {\n              case SS_DOUBLE:\n              case SS_SINGLE:\n              case SS_INT8:\n              case SS_UINT8:\n              case SS_INT16:\n              case SS_UINT16:\n              case SS_INT32:\n              case SS_UINT32:\n              case SS_BOOLEAN:\n                logDataType[*sigIdx] = sigDataType[*sigIdx];\n                break;\n              case SS_ENUM_TYPE:\n                logDataType[*sigIdx] = SS_INT32;\n                break;\n              default:\n                logDataType[*sigIdx] = SS_DOUBLE;\n                break;\n            }\n        }\n\n        /* Complexity */\n        sigComplexity[*sigIdx] = rtwCAPI_GetDataIsComplex(dataTypeMap, mapIdx);\n\n        /* Data Access - Pointer or Direct*/\n        isPointer = ((uint8_T)rtwCAPI_GetDataIsPointer(dataTypeMap, mapIdx));\n\n        /* Address */\n        if (contStateDeriv) {\n            int_T csvIdx = rtwCAPI_GetContStateStartIndex(states,i);\n            utAssert(csvIdx >= 0);\n            sigDataAddr[*sigIdx] = &contStateDeriv[csvIdx];\n        } else {\n            mapIdx = rtwCAPI_GetStateAddrIdx(states,i);\n            rtwCAPI_GetSigAddrFromMap(isPointer, sigComplexity, sigDataType,\n                                      sigDataAddr, sigIdx, mapIdx, dataAddrMap);\n        }\n\n        /* Logging function pointer */\n        if (RTWLoggingPtrs) {\n            if (contStateDeriv || !RTWLoggingPtrsMap) {\n                RTWLoggingPtrs[*sigIdx] = NULL;\n            }\n            else {\n                mapIdx = rtwCAPI_GetStateAddrIdx(states, i);\n                RTWLoggingPtrs[*sigIdx] = RTWLoggingPtrsMap[mapIdx];\n            }\n        }\n\n        /* CrossingModelBoundary */\n        sigCrossMdlRef[*sigIdx] = crossingModel;\n\n        if (sigInProtectedMdl)\n        {\n            sigInProtectedMdl[*sigIdx] = isInProtectedMdl;\n        }\n\n        if (sigPathAlias && \n            rtwCAPI_GetStatePathAlias(states,i) != NULL && \n            rtwCAPI_GetStatePathAlias(states,i)[0] != '\\0') {\n            sigPathAlias[*sigIdx] =  \n                rtwCAPI_GetFullStateBlockPath(rtwCAPI_GetStatePathAlias(states,i),\n                                              mmiPath, mmiPathLen, crossingModel);\n        }\n        \n        /* Sample Time */\n        if (sigSampleTime) {\n            const rtwCAPI_SampleTimeMap* tsMap = rtwCAPI_GetSampleTimeMap(mmi);\n            int_T TID;\n            mapIdx = rtwCAPI_GetStateSampleTimeIdx(states, i);\n            TID = rtwCAPI_GetSampleTimeTID(tsMap, mapIdx);\n            if (TID >= 0) {\n                sigSampleTime[2*(*sigIdx)] =\n                    *((const real_T*)rtwCAPI_GetSamplePeriodPtr(tsMap,mapIdx));\n                sigSampleTime[2*(*sigIdx)+1] =\n                    *((const real_T*)rtwCAPI_GetSampleOffsetPtr(tsMap,mapIdx));\n            } else { /* triggered */\n                utAssert(TID==-1); \n                sigSampleTime[2*(*sigIdx)]   = -1.0;\n                sigSampleTime[2*(*sigIdx)+1] = -1.0;\n            }\n        }\n\n        /* HierInfoIdx and FlatElemIdx */\n        if (sigHierInfoIdx && sigFlatElemIdx)\n        {\n            sigHierInfoIdx[*sigIdx] = rtwCAPI_GetStateHierInfoIdx(states, i);\n            sigFlatElemIdx[*sigIdx] = rtwCAPI_GetStateFlatElemIdx(states, i);\n        }      \n\n        /* MMI for each state */\n        if (sigMMI)\n        {\n            sigMMI[*sigIdx] = mmi;\n        }  \n\n        ++(*sigIdx);\n    }\n\n  EXIT_POINT:\n    return(errstr);\n\n} /* rtwCAPI_GetStateRecordInfo */\n\n/* Signal Logging functions */\n\n/** Function: rtwCAPI_GetNumSigLogRecords ======================================\n *\n */\nint_T rtwCAPI_GetNumSigLogRecords(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs;\n    int_T nCMMI;\n\n    if (mmi == NULL) return(0);\n\n    nRecs = rtwCAPI_GetNumSignals(mmi);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumSigLogRecords(cMMI);\n    }\n    return(nRecs);\n\n} /* rtwCAPI_GetNumSigLogRecords */\n\n\n/** Function: rtwCAPI_GetNumSigLogRecordsForRTWLogging =========================\n *\n */\nint_T rtwCAPI_GetNumSigLogRecordsForRTWLogging(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs = 0;\n    int_T nSignals = 0;\n    int_T nCMMI;\n    const rtwCAPI_Signals *signals = NULL;\n    const rtwCAPI_DataTypeMap* dataTypeMap;\n\n    if (mmi == NULL) return(0);\n\n    nSignals = rtwCAPI_GetNumSignals(mmi);\n    signals = rtwCAPI_GetSignals(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n\n    for (i = 0; i < nSignals; ++i) {\n        if (rtwCAPI_CanLogSignalToMATFile(dataTypeMap, signals, i)) {\n            ++nRecs;\n        }\n    }\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumSigLogRecordsForRTWLogging(cMMI);\n    }\n\n    return(nRecs);\n\n} /* rtwCAPI_GetNumSigLogRecords */\n\n\n/** Function: rtwCAPI_GetSigLogRecordInfo ======================================\n *\n */\nconst char_T* rtwCAPI_GetSigLogRecordInfo(const rtwCAPI_ModelMappingInfo* mmi,\n                                          const char_T**    sigBlockName,\n                                          const char_T**    sigLabel,\n                                          int_T*            sigWidth,\n                                          int_T*            sigDataType,\n                                          int_T*            logDataType,\n                                          int_T*            sigComplexity,\n                                          void**            sigDataAddr,\n                                          boolean_T*        sigCrossMdlRef,\n                                          int_T*            sigIdx,\n                                          boolean_T         crossingModel,\n                                          boolean_T         rtwLogging)\n{\n    int_T               i;\n    int_T               nCMMI;\n    int_T               nSignals;\n    const char_T*       mmiPath;\n    size_t              mmiPathLen;\n    const rtwCAPI_Signals*  signals;\n    const rtwCAPI_DimensionMap* dimMap;\n    const uint_T*       dimArray;\n    const rtwCAPI_DataTypeMap*  dataTypeMap;\n    void**              dataAddrMap;\n    const char_T*       errstr = NULL;\n    uint8_T             isPointer = 0;\n    char*               blockPath = NULL;\n\n    if (mmi == NULL) goto EXIT_POINT;\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n\n        errstr = rtwCAPI_GetSigLogRecordInfo(cMMI,\n                                             sigBlockName,\n                                             sigLabel,\n                                             sigWidth,\n                                             sigDataType,\n                                             logDataType,\n                                             sigComplexity,\n                                             sigDataAddr,\n                                             sigCrossMdlRef,\n                                             sigIdx,\n                                             true,\n                                             rtwLogging);\n        if (errstr != NULL) goto EXIT_POINT;\n    }\n\n    nSignals = rtwCAPI_GetNumSignals(mmi);\n    if (nSignals < 1) goto EXIT_POINT;\n\n    mmiPath     = rtwCAPI_GetFullPath(mmi);\n    mmiPathLen  = (mmiPath==NULL)? 0 : strlen(mmiPath);\n    signals     = rtwCAPI_GetSignals(mmi);\n    dimMap      = rtwCAPI_GetDimensionMap(mmi);\n    dimArray    = rtwCAPI_GetDimensionArray(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n    dataAddrMap = rtwCAPI_GetDataAddressMap(mmi);\n\n    for (i = 0; i < nSignals; ++i) {\n        uint_T mapIdx;\n        size_t sigPathLen;\n        char*  sigPath;\n\n        /* For RTW logging, skip states that cannot be logged to MAT-File. */\n        if ((rtwLogging) &&\n            (rtwCAPI_CanLogSignalToMATFile(dataTypeMap, signals, i) == false)) continue;\n\n        /* sigBlockPath = mmiPath + | + BlockPath + '\\0' */\n        /* If crossing a model boundary encode, otherwise do not */\n\n        if (crossingModel) {\n            blockPath = rtwCAPI_EncodePath(rtwCAPI_GetSignalBlockPath(signals, i));\n            if ( (blockPath == NULL) &&\n                 (rtwCAPI_GetSignalBlockPath(signals, i) != NULL)) {\n                errstr = rtwCAPI_mallocError;\n                goto EXIT_POINT;\n            }\n        } else {\n            const char* constBlockPath = rtwCAPI_GetSignalBlockPath(signals, i);\n            blockPath = (char*)utMalloc((strlen(constBlockPath)+1)*sizeof(char));\n            (void)strcpy(blockPath, constBlockPath);\n        }\n        utAssert(blockPath != NULL);\n        sigPathLen = ( (mmiPath==NULL) ?\n                                   strlen(blockPath) + 1 :\n                                   mmiPathLen + strlen(blockPath) + 2 );\n        sigPath    = (char*)utMalloc(sigPathLen*sizeof(char));\n        if (sigPath == NULL) {\n            errstr = rtwCAPI_mallocError;\n            goto EXIT_POINT;\n        }\n        if (mmiPath != NULL) {\n            (void)strcpy(sigPath, mmiPath);\n            sigPath[mmiPathLen]   = '|';\n            sigPath[mmiPathLen+1] =  '\\0';\n            (void)strcat(sigPath, blockPath);\n        } else {\n            (void)strcpy(sigPath, blockPath);\n            sigPath[sigPathLen-1] =  '\\0';\n        }\n       /* need to free for every iteration of the loop, but also have\n        * the free below EXIT_POINT in case of error */\n        utFree(blockPath);\n        blockPath = NULL;\n        utAssert(sigPath[sigPathLen-1] == '\\0');\n        sigBlockName[*sigIdx] = sigPath; /* caller is responsible for free */\n\n        /* Label */\n        sigLabel[*sigIdx] = rtwCAPI_GetSignalName(signals, i);\n\n        /* Width */\n        mapIdx = rtwCAPI_GetSignalDimensionIdx(signals, i);\n        utAssert( rtwCAPI_GetNumDims(dimMap,mapIdx) == 2 );\n        mapIdx = rtwCAPI_GetDimArrayIndex(dimMap, mapIdx);\n        sigWidth[*sigIdx] = dimArray[mapIdx] * dimArray[mapIdx+1];\n\n        /* DataType and logDataType */\n        mapIdx = rtwCAPI_GetSignalDataTypeIdx(signals, i);\n        sigDataType[*sigIdx] = rtwCAPI_GetDataTypeSLId(dataTypeMap, mapIdx);\n        /* this mimics code in simulink.dll:mapSigDataTypeToLogDataType */\n        switch (sigDataType[*sigIdx]) {\n          case SS_DOUBLE:\n          case SS_SINGLE:\n          case SS_INT8:\n          case SS_UINT8:\n          case SS_INT16:\n          case SS_UINT16:\n          case SS_INT32:\n          case SS_UINT32:\n          case SS_BOOLEAN:\n            logDataType[*sigIdx] = sigDataType[*sigIdx];\n            break;\n          case SS_ENUM_TYPE:\n            logDataType[*sigIdx] = SS_INT32;\n            break;\n          default:\n            logDataType[*sigIdx] = SS_DOUBLE;\n            break;\n        }\n\n        /* Complexity */\n        sigComplexity[*sigIdx] = rtwCAPI_GetDataIsComplex(dataTypeMap, mapIdx);\n\n        /* Data Access - Pointer or Direct*/\n        isPointer = ((uint8_T)rtwCAPI_GetDataIsPointer(dataTypeMap, mapIdx));\n\n        /* Address */\n        mapIdx = rtwCAPI_GetSignalAddrIdx(signals, i);\n\n        rtwCAPI_GetSigAddrFromMap(isPointer, sigComplexity, sigDataType,\n                                  sigDataAddr, sigIdx, mapIdx, dataAddrMap);\n\n        /* CrossingModelBoundary */\n        sigCrossMdlRef[*sigIdx] = crossingModel;\n\n        ++(*sigIdx);\n    }\n\n  EXIT_POINT:\n    utFree(blockPath);\n    return(errstr);\n\n} /* rtwCAPI_GetSigLogRecordInfo */\n\n\n/** Function: rtwCAPI_CountSysRan ==============================================\n *   Recursive function that counts the number of non-NULL pointers in the array\n *   of system ran dwork pointers, for the given MMI and below\n */\nvoid rtwCAPI_CountSysRan(const rtwCAPI_ModelMappingInfo *mmi,\n\t\t\t int                            *count)\n{\n    sysRanDType **sysRan;\n    int numSys;\n    int nCMMI;\n    int numSysRan = 0;\n    int i;\n\n    if (mmi == NULL) return;\n\n    sysRan = rtwCAPI_GetSystemRan(mmi);\n    numSys    = rtwCAPI_GetNumSystems(mmi);\n    nCMMI     = rtwCAPI_GetChildMMIArrayLen(mmi);\n\n    /* Recurse over children */\n    for (i = 0; i < nCMMI; i++) {\n        rtwCAPI_CountSysRan(rtwCAPI_GetChildMMI(mmi,i), &numSysRan);\n    }\n\n    /* Count number of dworks in this MMI - skip root */\n    for (i = 1; i< numSys; i++) {\n        if (sysRan[i] != NULL) numSysRan++;\n    }\n\n    *count += numSysRan;\n\n} /* end rtwCAPI_CountSysRan */\n\n\n/** Function: rtwCAPI_FillSysRan ===============================================\n *   Recursive function that fills in the system ran dwork pointers and their\n *   corresponding tids in the given array, for the given MMI and below.  The\n *   array to be filled in must be allocated outside\n */\nvoid rtwCAPI_FillSysRan(const rtwCAPI_ModelMappingInfo *mmi,\n\t\t\tsysRanDType                    **sysRan,\n\t\t\tint                            *sysTid,\n                        int                            *fillIdx)\n{\n    int       numSys;\n    sysRanDType **mmiSysRan;\n    int       nCMMI;\n    int       *mmiSysTid;\n    int       idx         = *fillIdx;\n    const int *mmiConSys;\n    int i;\n\n    if (mmi == NULL) return;\n\n    numSys      = rtwCAPI_GetNumSystems(mmi);\n    mmiSysRan = rtwCAPI_GetSystemRan(mmi);\n    nCMMI       = rtwCAPI_GetChildMMIArrayLen(mmi);\n    mmiSysTid  = rtwCAPI_GetSystemTid(mmi);\n    mmiConSys  = rtwCAPI_GetContextSystems(mmi);\n\n    /* Recurse over children */\n    for (i = 0; i < nCMMI; i++) {\n        rtwCAPI_FillSysRan(rtwCAPI_GetChildMMI(mmi,i), sysRan, sysTid, &idx);\n    }\n\n    /* Populate arrays with dwork pointers and tid - skip root */\n    for (i = 1; i< numSys; i++) {\n        if (mmiSysRan[i] != NULL) {\n            idx++;\n            sysRan[idx] = mmiSysRan[i];\n            sysTid[idx] = mmiSysTid[mmiConSys[i]];\n        }\n    }\n\n    *fillIdx = idx;\n\n} /* end rtwCAPI_FillSysRan */\n\n/* LocalWords:  CAPI bpath aaa Addr mmi CSTATE DSTATE Hier tids\n */\n"},{"name":"rtw_modelmap_utils_simtarget.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* Copyright 2003-2020 The MathWorks, Inc. */\n\n/**\n * Utility functions to traverse and access information from ModelMappingInfo\n *\n */\n\n#ifdef SL_INTERNAL\n\n# include \"version.h\"\n# include \"util.h\"\n# include \"simstruct/simstruc_types.h\"\n# include \"simulinkcoder_capi/rtw_modelmap.h\"\n\n#else\n\n# include <stdlib.h>\n# include <assert.h>\n\n# define  utFree(arg)    if (arg) free(arg)\n# define  utMalloc(arg)  malloc(arg)\n# define  utAssert(exp)  assert(exp)\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n# if defined(__LCC__)\n#   define UNUSED_PARAMETER(x)  /* do nothing */\n# else\n/*\n * This is the semi-ANSI standard way of indicating that a\n * unused function parameter is required.\n */\n#   define UNUSED_PARAMETER(x) (void) (x)\n# endif\n#endif\n\n# include \"builtin_typeid_types.h\"\n# include \"rtwtypes.h\"\n# include \"rtw_modelmap_simtarget.h\"\n\n#endif\n\n#include <string.h>\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nstatic const char_T* rtwCAPI_mallocError = \"Memory Allocation Error\";\n\n/** Function: rtwCAPI_EncodePath ===============================================\n *  Abstract:\n *     Escape all '|' characters in bpath. For examples 'aaa|b' will become\n *     'aaa~|b'. The caller is responsible for freeing the returned string\n *\n *\n * NOTE: returned string can be NULL in two cases:\n *     (1) string passed in was NULL\n *     (2) a memory allocation error occurred\n * In the second case, the caller need to report the error\n */\nchar* rtwCAPI_EncodePath(const char* path)\n{\n    char* encodedPath     = NULL;\n    size_t pathLen        = (path==NULL) ? 0:strlen(path) + 1;\n    size_t encodedPathLen = pathLen;\n    unsigned i;\n    unsigned j = 0;\n\n    if (path == NULL) return NULL;\n\n    for (i = 0; i < pathLen; ++i) {\n        if (path[i] == '|' || path[i] == '~') ++encodedPathLen;\n    }\n\n    encodedPath = (char_T*)utMalloc(encodedPathLen*sizeof(char_T));\n    if (encodedPath == NULL) return encodedPath;\n\n    for (i = 0; i < pathLen; ++i) {\n        char ch = path[i];\n        if (ch == '~' || ch == '|') encodedPath[j++] = '~';\n        encodedPath[j++] = ch;\n    }\n    utAssert(j == encodedPathLen);\n    utAssert(encodedPath[j-1] == '\\0');\n\n    return encodedPath;\n\n} /* rtwCAPI_EncodePath */\n\n/** Function: rtwCAPI_GetSigAddrFromMap ========================================\n *\n */\nvoid rtwCAPI_GetSigAddrFromMap(uint8_T      isPointer,\n                               int_T*       sigComplexity,\n                               int_T*       sigDataType,\n                               void**       sigDataAddr,\n                               int_T*       sigIdx,\n                               uint_T       mapIdx,\n                               void**       dataAddrMap)\n{\n    if (isPointer) {\n        /* Dereference pointer and cache the address */\n\n        /* Imported Pointers cannot be complex - Assert */\n        utAssert(sigComplexity[*sigIdx] != 1);\n        UNUSED_PARAMETER(sigComplexity);\n\n        /* Check for data type and dereference accordingly */\n        switch (sigDataType[*sigIdx]) {\n          case SS_DOUBLE:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((real_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_SINGLE:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((real32_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_UINT32:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((uint32_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_INT32:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((int32_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_UINT16:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((uint16_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_INT16:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((int16_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_UINT8:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((uint8_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_INT8:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((int8_T **) dataAddrMap[mapIdx]);\n            break;\n          case SS_BOOLEAN:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((boolean_T **) dataAddrMap[mapIdx]);\n            break;\n          default:\n            sigDataAddr[*sigIdx] = \\\n                (void*) *((real_T **) dataAddrMap[mapIdx]);\n            break;\n        }  /* end switch */\n    } else {\n        /* if Data is not a pointer store the address directly */\n        sigDataAddr[*sigIdx] = dataAddrMap[mapIdx];\n    }\n\n} /* rtwCAPI_GetSigAddrFromMap */\n\n\n/** Function: rtwCAPI_HasStates ================================================\n *\n */\nboolean_T rtwCAPI_HasStates(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nCMMI;\n\n    if (mmi == NULL) return(0U);\n\n    if (rtwCAPI_GetNumStates(mmi) > 0) return(1U);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        if (rtwCAPI_HasStates(rtwCAPI_GetChildMMI(mmi,i))) return(1U);\n    }\n    return(0U);\n\n} /* rtwCAPI_HasStates */\n\n\n\n/** Function: rtwCAPI_GetNumStateRecords =======================================\n *\n */\nint_T rtwCAPI_GetNumStateRecords(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs;\n    int_T nCMMI;\n\n    if (mmi == NULL) return(0);\n\n    nRecs = rtwCAPI_GetNumStates(mmi);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumStateRecords(cMMI);\n    }\n    return(nRecs);\n\n} /* rtwCAPI_GetNumStateRecords */\n\n\n/** Function: rtwCAPI_GetNumStateRecordsForRTWLogging ==========================\n *\n */\nint_T rtwCAPI_GetNumStateRecordsForRTWLogging(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs = 0;\n    int_T nStates;\n    int_T nCMMI;\n    const rtwCAPI_States *states;\n    const rtwCAPI_DataTypeMap* dataTypeMap;\n\n    if (mmi == NULL) return(0);\n\n    nStates = rtwCAPI_GetNumStates(mmi);\n    states = rtwCAPI_GetStates(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n\n    for (i = 0; i < nStates; ++i) {\n        if (rtwCAPI_CanLogStateToMATFile(dataTypeMap, states, i)) {\n            ++nRecs;\n        }\n    }\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumStateRecordsForRTWLogging(cMMI);\n    }\n\n    return(nRecs);\n\n} /* rtwCAPI_GetNumStateRecordsForRTWLogging */\n\n\n/** Function: rtwCAPI_GetNumContStateRecords ===================================\n *\n */\nint_T rtwCAPI_GetNumContStateRecords(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs;\n    int_T nCMMI;\n    int_T nCStateRecs;\n    const rtwCAPI_States* states;\n    const rtwCAPI_DataTypeMap* dataTypeMap;\n\n    if (mmi == NULL) return 0;\n\n    nCStateRecs = 0;\n    states      = rtwCAPI_GetStates(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n\n    nRecs = rtwCAPI_GetNumStates(mmi);\n    for (i = 0; i < nRecs; i++) {\n        if (rtwCAPI_IsAContinuousState(states,i)) {\n            ++nCStateRecs;\n\n            /* All continuous states should be able to be logged to MAT-File\n             * so we do not need to skip any states here. */\n            utAssert(rtwCAPI_CanLogStateToMATFile(dataTypeMap, states, i));\n        }\n    }\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nCStateRecs += rtwCAPI_GetNumContStateRecords(cMMI);\n    }\n    return nCStateRecs;\n\n} /* rtwCAPI_GetNumContStateRecords */\n\n\n/** Function: rtwCAPI_FreeFullPaths ============================================\n *\n */\nvoid rtwCAPI_FreeFullPaths(rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T   i;\n    int_T   nCMMI;\n    char_T* fullPath;\n\n    if (mmi == NULL) return;\n\n    fullPath = rtwCAPI_GetFullPath(mmi);\n    utAssert(fullPath != NULL);\n    utFree(fullPath);\n    rtwCAPI_SetFullPath(*mmi, NULL);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        rtwCAPI_FreeFullPaths(cMMI);\n    }\n\n} /* rtwCAPI_FreeFullPaths */\n\n\n/** Function: rtwCAPI_UpdateFullPaths =========================================*\n *\n */\nconst char_T* rtwCAPI_UpdateFullPaths(rtwCAPI_ModelMappingInfo* mmi,\n                                      const char_T* path,\n                                      boolean_T isCalledFromTopModel)\n{\n    int_T         i;\n    int_T         nCMMI;\n    size_t        pathLen;\n    char_T*       mmiPath;\n    size_t        mmiPathLen;\n    char_T*       relMMIPath;\n    size_t        relMMIPathLen;\n\n    if (mmi == NULL) return NULL;\n\n    utAssert(path != NULL);\n    utAssert( rtwCAPI_GetFullPath(mmi) == NULL );\n\n    pathLen = strlen(path)+1;\n\n    if (isCalledFromTopModel) {\n        /* If called from top model - FullPath is same as path */\n        mmiPath = (char_T*)utMalloc(pathLen*sizeof(char_T));\n        (void)memcpy(mmiPath, path, pathLen*sizeof(char_T));\n    }\n    else {        \n        relMMIPath = rtwCAPI_EncodePath(rtwCAPI_GetPath(mmi));\n        if ( (relMMIPath== NULL) && (rtwCAPI_GetPath(mmi) != NULL)) {\n            return rtwCAPI_mallocError;\n        }\n        relMMIPathLen = relMMIPath ? (strlen(relMMIPath) + 1) : 0;\n        \n        mmiPathLen = pathLen + relMMIPathLen;\n        \n        mmiPath = (char_T*)utMalloc(mmiPathLen*sizeof(char_T));\n        if (mmiPath == NULL) return rtwCAPI_mallocError;\n        (void)memcpy(mmiPath, path, pathLen*sizeof(char_T));\n        utAssert(mmiPath[pathLen-1] == '\\0');\n        \n        if (relMMIPath) {\n            /* mmiPath = path + | + relMMIPath + '\\0' */\n            mmiPath[pathLen-1] = '|';\n            (void)memcpy(&(mmiPath[pathLen]),\n                         relMMIPath, relMMIPathLen*sizeof(char_T));\n            utAssert(mmiPath[mmiPathLen-1] == '\\0');\n            utFree(relMMIPath);\n        }\n    }\n    rtwCAPI_SetFullPath(*mmi, mmiPath);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        const char_T* errstr = rtwCAPI_UpdateFullPaths(cMMI, mmiPath, 0);\n        if (errstr != NULL) return errstr;\n    }\n    return NULL;\n\n} /* rtwCAPI_UpdateFullPaths */\n\n\n/** Function: rtwCAPI_GetFullStateBlockPath ===================================\n *\n */\nchar* rtwCAPI_GetFullStateBlockPath(const char* stateBlockPath,\n                                           const char* mmiPath,\n                                           size_t      mmiPathLen,\n                                           boolean_T   crossingModel)\n{\n    char_T* blockPath          = NULL;\n    char_T* fullStateBlockPath = NULL;\n    size_t     fullStateBlockPathLen;\n\n    if (stateBlockPath == NULL) goto EXIT_POINT;\n\n    /* fullStateBlockPath = mmiPath + | + blockPath + '\\0' */\n    /* If crossing a model boundary encode, otherwise do not */\n\n    if (crossingModel) {\n        blockPath = rtwCAPI_EncodePath(stateBlockPath);\n        if (blockPath == NULL) goto EXIT_POINT;\n    } else {\n        size_t len = strlen(stateBlockPath)+1;\n        blockPath = (char*)utMalloc(len*sizeof(char));\n        if (blockPath == NULL) goto EXIT_POINT;\n        (void)strcpy(blockPath,stateBlockPath);\n    }\n    utAssert(blockPath != NULL);\n    fullStateBlockPathLen = ( (mmiPath==NULL) ?\n                              strlen(blockPath) + 1 :\n                              mmiPathLen + strlen(blockPath) + 2 );\n    fullStateBlockPath    = (char*)utMalloc(fullStateBlockPathLen*sizeof(char));\n    if (fullStateBlockPath == NULL) goto EXIT_POINT;\n\n    if (mmiPath != NULL) {\n        (void)strcpy(fullStateBlockPath, mmiPath);\n        fullStateBlockPath[mmiPathLen]   = '|';\n        fullStateBlockPath[mmiPathLen+1] =  '\\0';\n        (void)strcat(fullStateBlockPath, blockPath);\n    } else {\n        (void)strcpy(fullStateBlockPath, blockPath);\n        fullStateBlockPath[fullStateBlockPathLen-1] =  '\\0';\n    }\n    utAssert(fullStateBlockPath[fullStateBlockPathLen-1] == '\\0');\n\n  EXIT_POINT:\n    utFree(blockPath);\n    return fullStateBlockPath; /* caller is responsible for free */\n}\n\nuint_T rtwCAPI_GetStateWidth(const rtwCAPI_DimensionMap* dimMap,\n                             const uint_T*               dimArray,\n                             const rtwCAPI_States*       states,\n                             uint_T                      iState)\n{\n    uint_T mapIdx = rtwCAPI_GetStateDimensionIdx(states, iState);\n    uint_T numDims = rtwCAPI_GetNumDims(dimMap,mapIdx);\n    uint_T width = 1;\n    uint_T i = 0;\n    utAssert( numDims > 0 );\n    mapIdx = rtwCAPI_GetDimArrayIndex(dimMap, mapIdx);\n    for (i = 0; i < numDims; i++) {\n        width *= dimArray[mapIdx+i];\n    }\n    return width;\n}\n\n\n\n/** Function: rtwCAPI_GetStateRecordInfo =======================================\n *\n */\nconst char_T* rtwCAPI_GetStateRecordInfo(const rtwCAPI_ModelMappingInfo* mmi,\n                                         const char_T**    sigBlockName,\n                                         const char_T**    sigLabel,\n                                         const char_T**    sigName,\n                                         int_T*            sigWidth,\n                                         int_T*            sigDataType,\n                                         int_T*            logDataType,\n                                         int_T*            sigComplexity,\n                                         void**            sigDataAddr,\n                                         RTWLoggingFcnPtr* RTWLoggingPtrs,\n                                         boolean_T*        sigCrossMdlRef,\n                                         boolean_T*        sigInProtectedMdl,\n                                         const char_T**    sigPathAlias,\n                                         real_T*           sigSampleTime,\n                                         int_T*            sigHierInfoIdx,\n                                         uint_T*           sigFlatElemIdx,                                         \n                                         const rtwCAPI_ModelMappingInfo** sigMMI,\n                                         int_T*            sigIdx,\n                                         boolean_T         crossingModel,\n                                         boolean_T         isInProtectedMdl,\n                                         real_T*           contStateDeriv,\n                                         boolean_T         rtwLogging,\n                                         int_T*            stateIdxList)\n{\n    int_T               i;\n    int_T               nCMMI;\n    int_T               nStates;\n    const char_T*       mmiPath;\n    size_t              mmiPathLen;\n    const rtwCAPI_States*  states;\n    const rtwCAPI_DimensionMap* dimMap;\n    const uint_T*       dimArray;\n    const rtwCAPI_DataTypeMap*  dataTypeMap;\n    void**              dataAddrMap;\n    RTWLoggingFcnPtr* RTWLoggingPtrsMap;\n    const char_T*       errstr = NULL;\n    uint8_T             isPointer = 0;\n    int_T* stateIdxListForCurrentModel = NULL;\n\n\n    if (mmi == NULL) goto EXIT_POINT;\n    isInProtectedMdl = isInProtectedMdl || rtwCAPI_IsProtectedModel(mmi);\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        real_T* childContStateDeriv = NULL;\n\n        if (cMMI == NULL) continue;\n\n        if (contStateDeriv) {\n            int idx;\n\n            idx = rtwCAPI_MMIGetContStateStartIndex(cMMI);\n            if(idx == -1) continue;\n            \n            childContStateDeriv = &contStateDeriv[idx];\n        }\n        errstr = rtwCAPI_GetStateRecordInfo(cMMI,\n                                            sigBlockName,\n                                            sigLabel,\n                                            sigName,\n                                            sigWidth,\n                                            sigDataType,\n                                            logDataType,\n                                            sigComplexity,\n                                            sigDataAddr,\n                                            RTWLoggingPtrs,\n                                            sigCrossMdlRef,\n                                            sigInProtectedMdl,\n                                            sigPathAlias,\n                                            sigSampleTime,\n                                            sigHierInfoIdx,\n                                            sigFlatElemIdx,\n                                            sigMMI,\n                                            sigIdx,\n                                            0x1, /* true, */\n                                            isInProtectedMdl,\n                                            childContStateDeriv,\n                                            rtwLogging,\n                                            stateIdxList);\n        if (errstr != NULL) goto EXIT_POINT;\n    }\n\n    nStates = rtwCAPI_GetNumStates(mmi);\n    if (nStates < 1) goto EXIT_POINT;\n\n    mmiPath     = rtwCAPI_GetFullPath(mmi);\n    mmiPathLen  = (mmiPath==NULL)? 0 : strlen(mmiPath);\n    states      = rtwCAPI_GetStates(mmi);\n    dimMap      = rtwCAPI_GetDimensionMap(mmi);\n    dimArray    = rtwCAPI_GetDimensionArray(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n    dataAddrMap = rtwCAPI_GetDataAddressMap(mmi);\n    RTWLoggingPtrsMap = rtwCAPI_GetRTWLoggingPtrsMap(mmi);\n\n    if(nStates > 0)\n        stateIdxListForCurrentModel = rtwCAPI_GetStateIdxList(mmi);\n\n    for (i = 0; i < nStates; ++i) {\n        uint_T      mapIdx;\n\n        /* If collecting continuous states, skip non-continuous states */\n        if (contStateDeriv && !rtwCAPI_IsAContinuousState(states,i)) continue;\n\n        /* For RTW logging, skip states that cannot be logged to MAT-File. */\n        if ((rtwLogging) &&\n            (rtwCAPI_CanLogStateToMATFile(dataTypeMap, states, i) == false)) continue;\n\n        /* BlockPath (caller is responsible for free) */\n        sigBlockName[*sigIdx] =\n            rtwCAPI_GetFullStateBlockPath(rtwCAPI_GetStateBlockPath(states,i),\n                                          mmiPath, mmiPathLen, crossingModel);\n        if (sigBlockName[*sigIdx] == NULL) {\n            errstr = rtwCAPI_mallocError;\n            goto EXIT_POINT;\n        }\n\n        /* Label */\n        if (rtwCAPI_IsAContinuousState(states,i)){\n            sigLabel[*sigIdx] = \"CSTATE\";\n        } else {\n            sigLabel[*sigIdx] = \"DSTATE\";\n        }\n        sigName[*sigIdx] = rtwCAPI_GetStateName(states, i);\n\n        /* Width */\n        sigWidth[*sigIdx] = rtwCAPI_GetStateWidth(dimMap, dimArray, states, i);\n\n        /* DataType and logDataType */\n        mapIdx = rtwCAPI_GetStateDataTypeIdx(states, i);\n        sigDataType[*sigIdx] = rtwCAPI_GetDataTypeSLId(dataTypeMap, mapIdx);\n        /* this mimics code in simulink.dll:DtGetDataTypeLoggingId() */\n        if (logDataType) {\n            switch (sigDataType[*sigIdx]) {\n              case SS_DOUBLE:\n              case SS_SINGLE:\n              case SS_INT8:\n              case SS_UINT8:\n              case SS_INT16:\n              case SS_UINT16:\n              case SS_INT32:\n              case SS_UINT32:\n              case SS_BOOLEAN:\n                logDataType[*sigIdx] = sigDataType[*sigIdx];\n                break;\n              case SS_ENUM_TYPE:\n                logDataType[*sigIdx] = SS_INT32;\n                break;\n              default:\n                logDataType[*sigIdx] = SS_DOUBLE;\n                break;\n            }\n        }\n\n        /* Complexity */\n        sigComplexity[*sigIdx] = rtwCAPI_GetDataIsComplex(dataTypeMap, mapIdx);\n\n        /* Data Access - Pointer or Direct*/\n        isPointer = ((uint8_T)rtwCAPI_GetDataIsPointer(dataTypeMap, mapIdx));\n\n        /* Address */\n        if (contStateDeriv) {\n            int_T csvIdx = rtwCAPI_GetContStateStartIndex(states,i);\n            utAssert(csvIdx >= 0);\n            sigDataAddr[*sigIdx] = &contStateDeriv[csvIdx];\n        } else {\n            mapIdx = rtwCAPI_GetStateAddrIdx(states,i);\n            rtwCAPI_GetSigAddrFromMap(isPointer, sigComplexity, sigDataType,\n                                      sigDataAddr, sigIdx, mapIdx, dataAddrMap);\n        }\n\n        /* Logging function pointer */\n        if (RTWLoggingPtrs) {\n            if (contStateDeriv || !RTWLoggingPtrsMap) {\n                RTWLoggingPtrs[*sigIdx] = NULL;\n            }\n            else {\n                mapIdx = rtwCAPI_GetStateAddrIdx(states, i);\n                RTWLoggingPtrs[*sigIdx] = RTWLoggingPtrsMap[mapIdx];\n            }\n        }\n\n        /* CrossingModelBoundary */\n        sigCrossMdlRef[*sigIdx] = crossingModel;\n\n        if (sigInProtectedMdl)\n        {\n            sigInProtectedMdl[*sigIdx] = isInProtectedMdl;\n        }\n\n        if (sigPathAlias && \n            rtwCAPI_GetStatePathAlias(states,i) != NULL && \n            rtwCAPI_GetStatePathAlias(states,i)[0] != '\\0') {\n            sigPathAlias[*sigIdx] =  \n                rtwCAPI_GetFullStateBlockPath(rtwCAPI_GetStatePathAlias(states,i),\n                                              mmiPath, mmiPathLen, crossingModel);\n        }\n        \n        /* Sample Time */\n        if (sigSampleTime) {\n            const rtwCAPI_SampleTimeMap* tsMap = rtwCAPI_GetSampleTimeMap(mmi);\n            int_T TID;\n            mapIdx = rtwCAPI_GetStateSampleTimeIdx(states, i);\n            TID = rtwCAPI_GetSampleTimeTID(tsMap, mapIdx);\n            if (TID >= 0) {\n                sigSampleTime[2*(*sigIdx)] =\n                    *((const real_T*)rtwCAPI_GetSamplePeriodPtr(tsMap,mapIdx));\n                sigSampleTime[2*(*sigIdx)+1] =\n                    *((const real_T*)rtwCAPI_GetSampleOffsetPtr(tsMap,mapIdx));\n            } else { /* triggered */\n                utAssert(TID==-1); \n                sigSampleTime[2*(*sigIdx)]   = -1.0;\n                sigSampleTime[2*(*sigIdx)+1] = -1.0;\n            }\n        }\n\n        /* HierInfoIdx and FlatElemIdx */\n        if (sigHierInfoIdx && sigFlatElemIdx)\n        {\n            sigHierInfoIdx[*sigIdx] = rtwCAPI_GetStateHierInfoIdx(states, i);\n            sigFlatElemIdx[*sigIdx] = rtwCAPI_GetStateFlatElemIdx(states, i);\n        }      \n\n        /* MMI for each state */\n        if (sigMMI)\n        {\n            sigMMI[*sigIdx] = mmi;\n        }  \n\n        /* Record index of states of a block \n         * stateIdxList can be NULL when the field is not needed by the caller.\n         * stateIdxListForCurrentModel can be NULL when saveformat is not dataset\n         * or model does not have any states to be saved*/\n        if(stateIdxList && stateIdxListForCurrentModel)\n        {\n            stateIdxList[*sigIdx] = stateIdxListForCurrentModel[i];\n        }\n        ++(*sigIdx);\n    }\n\n  EXIT_POINT:\n    return(errstr);\n\n} /* rtwCAPI_GetStateRecordInfo */\n\n/* Signal Logging functions */\n\n/** Function: rtwCAPI_GetNumSigLogRecords ======================================\n *\n */\nint_T rtwCAPI_GetNumSigLogRecords(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs;\n    int_T nCMMI;\n\n    if (mmi == NULL) return(0);\n\n    nRecs = rtwCAPI_GetNumSignals(mmi);\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumSigLogRecords(cMMI);\n    }\n    return(nRecs);\n\n} /* rtwCAPI_GetNumSigLogRecords */\n\n\n/** Function: rtwCAPI_GetNumSigLogRecordsForRTWLogging =========================\n *\n */\nint_T rtwCAPI_GetNumSigLogRecordsForRTWLogging(const rtwCAPI_ModelMappingInfo* mmi)\n{\n    int_T i;\n    int_T nRecs = 0;\n    int_T nSignals = 0;\n    int_T nCMMI;\n    const rtwCAPI_Signals *signals = NULL;\n    const rtwCAPI_DataTypeMap* dataTypeMap;\n\n    if (mmi == NULL) return(0);\n\n    nSignals = rtwCAPI_GetNumSignals(mmi);\n    signals = rtwCAPI_GetSignals(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n\n    for (i = 0; i < nSignals; ++i) {\n        if (rtwCAPI_CanLogSignalToMATFile(dataTypeMap, signals, i)) {\n            ++nRecs;\n        }\n    }\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        const rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n        nRecs += rtwCAPI_GetNumSigLogRecordsForRTWLogging(cMMI);\n    }\n\n    return(nRecs);\n\n} /* rtwCAPI_GetNumSigLogRecords */\n\n\n/** Function: rtwCAPI_GetSigLogRecordInfo ======================================\n *\n */\nconst char_T* rtwCAPI_GetSigLogRecordInfo(const rtwCAPI_ModelMappingInfo* mmi,\n                                          const char_T**    sigBlockName,\n                                          const char_T**    sigLabel,\n                                          int_T*            sigWidth,\n                                          int_T*            sigDataType,\n                                          int_T*            logDataType,\n                                          int_T*            sigComplexity,\n                                          void**            sigDataAddr,\n                                          boolean_T*        sigCrossMdlRef,\n                                          int_T*            sigIdx,\n                                          boolean_T         crossingModel,\n                                          boolean_T         rtwLogging)\n{\n    int_T               i;\n    int_T               nCMMI;\n    int_T               nSignals;\n    const char_T*       mmiPath;\n    size_t              mmiPathLen;\n    const rtwCAPI_Signals*  signals;\n    const rtwCAPI_DimensionMap* dimMap;\n    const uint_T*       dimArray;\n    const rtwCAPI_DataTypeMap*  dataTypeMap;\n    void**              dataAddrMap;\n    const char_T*       errstr = NULL;\n    uint8_T             isPointer = 0;\n    char*               blockPath = NULL;\n\n    if (mmi == NULL) goto EXIT_POINT;\n\n    nCMMI = rtwCAPI_GetChildMMIArrayLen(mmi);\n    for (i = 0; i < nCMMI; ++i) {\n        rtwCAPI_ModelMappingInfo* cMMI = rtwCAPI_GetChildMMI(mmi,i);\n\n        errstr = rtwCAPI_GetSigLogRecordInfo(cMMI,\n                                             sigBlockName,\n                                             sigLabel,\n                                             sigWidth,\n                                             sigDataType,\n                                             logDataType,\n                                             sigComplexity,\n                                             sigDataAddr,\n                                             sigCrossMdlRef,\n                                             sigIdx,\n                                             true,\n                                             rtwLogging);\n        if (errstr != NULL) goto EXIT_POINT;\n    }\n\n    nSignals = rtwCAPI_GetNumSignals(mmi);\n    if (nSignals < 1) goto EXIT_POINT;\n\n    mmiPath     = rtwCAPI_GetFullPath(mmi);\n    mmiPathLen  = (mmiPath==NULL)? 0 : strlen(mmiPath);\n    signals     = rtwCAPI_GetSignals(mmi);\n    dimMap      = rtwCAPI_GetDimensionMap(mmi);\n    dimArray    = rtwCAPI_GetDimensionArray(mmi);\n    dataTypeMap = rtwCAPI_GetDataTypeMap(mmi);\n    dataAddrMap = rtwCAPI_GetDataAddressMap(mmi);\n\n    for (i = 0; i < nSignals; ++i) {\n        uint_T mapIdx;\n        size_t sigPathLen;\n        char*  sigPath;\n\n        /* For RTW logging, skip states that cannot be logged to MAT-File. */\n        if ((rtwLogging) &&\n            (rtwCAPI_CanLogSignalToMATFile(dataTypeMap, signals, i) == false)) continue;\n\n        /* sigBlockPath = mmiPath + | + BlockPath + '\\0' */\n        /* If crossing a model boundary encode, otherwise do not */\n\n        if (crossingModel) {\n            blockPath = rtwCAPI_EncodePath(rtwCAPI_GetSignalBlockPath(signals, i));\n            if ( (blockPath == NULL) &&\n                 (rtwCAPI_GetSignalBlockPath(signals, i) != NULL)) {\n                errstr = rtwCAPI_mallocError;\n                goto EXIT_POINT;\n            }\n        } else {\n            const char* constBlockPath = rtwCAPI_GetSignalBlockPath(signals, i);\n            blockPath = (char*)utMalloc((strlen(constBlockPath)+1)*sizeof(char));\n            (void)strcpy(blockPath, constBlockPath);\n        }\n        utAssert(blockPath != NULL);\n        sigPathLen = ( (mmiPath==NULL) ?\n                                   strlen(blockPath) + 1 :\n                                   mmiPathLen + strlen(blockPath) + 2 );\n        sigPath    = (char*)utMalloc(sigPathLen*sizeof(char));\n        if (sigPath == NULL) {\n            errstr = rtwCAPI_mallocError;\n            goto EXIT_POINT;\n        }\n        if (mmiPath != NULL) {\n            (void)strcpy(sigPath, mmiPath);\n            sigPath[mmiPathLen]   = '|';\n            sigPath[mmiPathLen+1] =  '\\0';\n            (void)strcat(sigPath, blockPath);\n        } else {\n            (void)strcpy(sigPath, blockPath);\n            sigPath[sigPathLen-1] =  '\\0';\n        }\n       /* need to free for every iteration of the loop, but also have\n        * the free below EXIT_POINT in case of error */\n        utFree(blockPath);\n        blockPath = NULL;\n        utAssert(sigPath[sigPathLen-1] == '\\0');\n        sigBlockName[*sigIdx] = sigPath; /* caller is responsible for free */\n\n        /* Label */\n        sigLabel[*sigIdx] = rtwCAPI_GetSignalName(signals, i);\n\n        /* Width */\n        mapIdx = rtwCAPI_GetSignalDimensionIdx(signals, i);\n        utAssert( rtwCAPI_GetNumDims(dimMap,mapIdx) == 2 );\n        mapIdx = rtwCAPI_GetDimArrayIndex(dimMap, mapIdx);\n        sigWidth[*sigIdx] = dimArray[mapIdx] * dimArray[mapIdx+1];\n\n        /* DataType and logDataType */\n        mapIdx = rtwCAPI_GetSignalDataTypeIdx(signals, i);\n        sigDataType[*sigIdx] = rtwCAPI_GetDataTypeSLId(dataTypeMap, mapIdx);\n        /* this mimics code in simulink.dll:mapSigDataTypeToLogDataType */\n        switch (sigDataType[*sigIdx]) {\n          case SS_DOUBLE:\n          case SS_SINGLE:\n          case SS_INT8:\n          case SS_UINT8:\n          case SS_INT16:\n          case SS_UINT16:\n          case SS_INT32:\n          case SS_UINT32:\n          case SS_BOOLEAN:\n            logDataType[*sigIdx] = sigDataType[*sigIdx];\n            break;\n          case SS_ENUM_TYPE:\n            logDataType[*sigIdx] = SS_INT32;\n            break;\n          default:\n            logDataType[*sigIdx] = SS_DOUBLE;\n            break;\n        }\n\n        /* Complexity */\n        sigComplexity[*sigIdx] = rtwCAPI_GetDataIsComplex(dataTypeMap, mapIdx);\n\n        /* Data Access - Pointer or Direct*/\n        isPointer = ((uint8_T)rtwCAPI_GetDataIsPointer(dataTypeMap, mapIdx));\n\n        /* Address */\n        mapIdx = rtwCAPI_GetSignalAddrIdx(signals, i);\n\n        rtwCAPI_GetSigAddrFromMap(isPointer, sigComplexity, sigDataType,\n                                  sigDataAddr, sigIdx, mapIdx, dataAddrMap);\n\n        /* CrossingModelBoundary */\n        sigCrossMdlRef[*sigIdx] = crossingModel;\n\n        ++(*sigIdx);\n    }\n\n  EXIT_POINT:\n    utFree(blockPath);\n    return(errstr);\n\n} /* rtwCAPI_GetSigLogRecordInfo */\n\n\n/** Function: rtwCAPI_CountSysRan ==============================================\n *   Recursive function that counts the number of non-NULL pointers in the array\n *   of system ran dwork pointers, for the given MMI and below\n */\nvoid rtwCAPI_CountSysRan(const rtwCAPI_ModelMappingInfo *mmi,\n\t\t\t int                            *count)\n{\n    sysRanDType **sysRan;\n    int numSys;\n    int nCMMI;\n    int numSysRan = 0;\n    int i;\n\n    if (mmi == NULL) return;\n\n    sysRan = rtwCAPI_GetSystemRan(mmi);\n    numSys    = rtwCAPI_GetNumSystems(mmi);\n    nCMMI     = rtwCAPI_GetChildMMIArrayLen(mmi);\n\n    /* Recurse over children */\n    for (i = 0; i < nCMMI; i++) {\n        rtwCAPI_CountSysRan(rtwCAPI_GetChildMMI(mmi,i), &numSysRan);\n    }\n\n    /* Count number of dworks in this MMI - skip root */\n    for (i = 1; i< numSys; i++) {\n        if (sysRan[i] != NULL) numSysRan++;\n    }\n\n    *count += numSysRan;\n\n} /* end rtwCAPI_CountSysRan */\n\n\n/** Function: rtwCAPI_FillSysRan ===============================================\n *   Recursive function that fills in the system ran dwork pointers and their\n *   corresponding tids in the given array, for the given MMI and below.  The\n *   array to be filled in must be allocated outside\n */\nvoid rtwCAPI_FillSysRan(const rtwCAPI_ModelMappingInfo *mmi,\n\t\t\tsysRanDType                    **sysRan,\n\t\t\tint                            *sysTid,\n                        int                            *fillIdx)\n{\n    int       numSys;\n    sysRanDType **mmiSysRan;\n    int       nCMMI;\n    int       *mmiSysTid;\n    int       idx         = *fillIdx;\n    const int *mmiConSys;\n    int i;\n\n    if (mmi == NULL) return;\n\n    numSys      = rtwCAPI_GetNumSystems(mmi);\n    mmiSysRan = rtwCAPI_GetSystemRan(mmi);\n    nCMMI       = rtwCAPI_GetChildMMIArrayLen(mmi);\n    mmiSysTid  = rtwCAPI_GetSystemTid(mmi);\n    mmiConSys  = rtwCAPI_GetContextSystems(mmi);\n\n    /* Recurse over children */\n    for (i = 0; i < nCMMI; i++) {\n        rtwCAPI_FillSysRan(rtwCAPI_GetChildMMI(mmi,i), sysRan, sysTid, &idx);\n    }\n\n    /* Populate arrays with dwork pointers and tid - skip root */\n    for (i = 1; i< numSys; i++) {\n        if (mmiSysRan[i] != NULL) {\n            idx++;\n            sysRan[idx] = mmiSysRan[i];\n            sysTid[idx] = mmiSysTid[mmiConSys[i]];\n        }\n    }\n\n    *fillIdx = idx;\n\n} /* end rtwCAPI_FillSysRan */\n\n/* LocalWords:  CAPI bpath aaa Addr mmi CSTATE DSTATE Hier tids\n */\n"},{"name":"rtwlog.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2002 The MathWorks, Inc.\n *\n * File: rtwlog.c\n *\n * Abstract:\n *   Obsolete RTW logging file.\n */\nvoid Obsolete_File_Remove_From_Make_Files_(void)\n{\n    /* \n     * This file is provided for targets that were created before\n     * the release of Simulink 5.0. \n     * \n     * See release notes for for more information on how to update your \n     * targets to work with the new environment.\n     */\n}\n"},{"name":"sbpowdi.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*-\n * Function: powdi\n * Abstract:\n *\n *    Optimized version of pow when exponent is an integer number.\n *\n * Initial coding by A S Bozin\n * Copyright 1990-2013 The MathWorks, Inc.\n */\n#include \"tmwtypes.h\"\n#include <math.h>\n\nreal_T powdi(real_T x, int_T n)\n{\n    real_T powAns;\n    uint_T u;\n\n    /*\n     * First executable statement\n     */\n    powAns = 1;\n    if (n != 0) {\n        if (n < 0) {\n            n = -n;\n            x = 1 / x;\n        }\n        for (u = n;;) {\n            if (u & 01)\n                powAns *= x;\n            if (u >>= 1)\n                x *= x;\n            else\n                break;\n        }\n    }\n    return (powAns);                       /* Last card of powdi */\n}\n"},{"name":"scd_gatherinfo.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* Copyright 2009-2013 The MathWorks, Inc. */\n#define S_FUNCTION_NAME  scd_gatherinfo\n#define S_FUNCTION_LEVEL 2\n\n#include \"simstruc.h\"\n\n/*====================*\n * S-function methods *\n *====================*/\n\n/* Function: mdlInitializeSizes =========================================*/\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n\n    ssSetNumSFcnParams(S, 0);  /* Number of expected parameters */\n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {\n        return;\n    }\n\n    /* Register the number and type of states the S-Function uses */\n    ssSetNumContStates(    S, 0);   /* number of continuous states           */\n    ssSetNumDiscStates(    S, 0);   /* number of discrete states             */\n    ssAllowSignalsWithMoreThan2D(S);\n\n    /*\n     * Configure the input ports. First set the number of input ports. \n     */\n    if (!ssSetNumInputPorts(S, 1)) return;    \n    if(!ssSetInputPortDimensionInfo(S, 0, DYNAMIC_DIMENSION)) return;\n    ssSetInputPortDataType(S, 0, DYNAMICALLY_TYPED);\n    ssSetInputPortDirectFeedThrough(S, 0, 1);\n\n    /*\n     * Configure the output ports. First set the number of output ports.\n     */\n    if (!ssSetNumOutputPorts(S, 1)) return;\n    if(!ssSetOutputPortDimensionInfo(S,0,DYNAMIC_DIMENSION)) return;\n    ssSetOutputPortDataType(S, 0, DYNAMICALLY_TYPED);\n\n    ssSetNumSampleTimes(S, PORT_BASED_SAMPLE_TIMES);\n    ssSetInputPortSampleTime(S, 0, INHERITED_SAMPLE_TIME);\n    ssSetOutputPortSampleTime(S, 0, INHERITED_SAMPLE_TIME);\n\n    /*\n     * Set size of the work vectors.\n     */\n    ssSetNumRWork(         S, 0);   /* number of real work vector elements   */\n    ssSetNumIWork(         S, 0);   /* number of integer work vector elements*/\n    ssSetNumPWork(         S, 0);   /* number of pointer work vector elements*/\n    ssSetNumModes(         S, 0);   /* number of mode work vector elements   */\n    ssSetNumNonsampledZCs( S, 0);   /* number of non-sampled zero crossings   */\n\n    ssSetOptions(S, 0);   /* general options (SS_OPTION_xx)        */\n\n} /* end mdlInitializeSizes */\n\n\n/*************************************************************************/\n/****************** SETTING PORT DIMENSIONS ******************************/\n/*************************************************************************/\n#if defined(MATLAB_MEX_FILE)\n\n#define MDL_SET_INPUT_PORT_DIMENSION_INFO\nvoid mdlSetInputPortDimensionInfo(SimStruct *S, int_T port, \n        const DimsInfo_T *dimsInfo)\n{\n    if (port == 0) {\n        /* Set the size for all dynamic ports using dimsInfo */\n        ssSetInputPortDimensionInfo(S, port,dimsInfo);\n        ssSetOutputPortDimensionInfo(S, port, dimsInfo);\n    } else {\n        return;\n    }\n} /*mdlSetInputPortDimensionInfo */\n\n#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO\nvoid mdlSetOutputPortDimensionInfo(SimStruct *S, int_T port,\n        const DimsInfo_T *dimsInfo)\n{\n    if (port == 0) {\n        ssSetOutputPortDimensionInfo(S, port,dimsInfo);\n        ssSetInputPortDimensionInfo(S, port,dimsInfo);\n    }   \n} /* end mdlSetOutputPortDimensionInfo */\n\n#define MDL_SET_DEFAULT_PORT_DIMENSION_INFO\nvoid mdlSetDefaultPortDimensionInfo(SimStruct *S)\n{\n    DECL_AND_INIT_DIMSINFO(dimsInfo);\n    /* Either 2nd input or 2nd output should be already known */\n    if (ssGetOutputPortWidth(S, 0) != DYNAMICALLY_SIZED) {\n        /* It is the output that is known, get the dimensions first */\n        dimsInfo.width   = ssGetOutputPortWidth(S, 0);\n        dimsInfo.numDims = ssGetOutputPortNumDimensions(S, 0);\n        dimsInfo.dims    = ssGetOutputPortDimensions(S, 0);\n        \n        /*set second input, first output if unknown */\n        if (ssGetInputPortWidth(S, 0) == DYNAMICALLY_SIZED) {\n            if(!ssSetInputPortDimensionInfo(S, 0, &dimsInfo)) return;\n        }\n        return;\n     }\n     else {\n         if (ssGetInputPortWidth(S, 0) != DYNAMICALLY_SIZED) {\n             /* It is the input that is known, get the dimensions */\n             dimsInfo.width   = ssGetInputPortWidth(S, 0);\n             dimsInfo.numDims = ssGetInputPortNumDimensions(S, 0);\n             dimsInfo.dims    = ssGetInputPortDimensions(S, 0);\n             \n             /*set first and second output if unknown */\n             if (ssGetOutputPortWidth(S, 0) == DYNAMICALLY_SIZED) {\n                 if(!ssSetOutputPortDimensionInfo(S, 0, &dimsInfo)) return;\n             }\n             return;\n         }\n         else\n         {\n             /* Default everything to a scalar signal */\n             ssSetOutputPortVectorDimension(S,  0, 1);\n             ssSetInputPortVectorDimension(S,  0, 1);\n             return;\n         }\n     }\n} /* end mdlSetDefaultPortDimensionInfo */\n\n#endif /* MATLAB_MEX_FILE */\n\n/*************************************************************************/\n/****************** SETTING PORT SAMPLE TIMES ****************************/\n/*************************************************************************/\n\n#define MDL_SET_INPUT_PORT_SAMPLE_TIME\n#if defined(MDL_SET_INPUT_PORT_SAMPLE_TIME) && defined(MATLAB_MEX_FILE)\n/* Function: mdlSetInputPortSampleTime ==================================*/\nvoid mdlSetInputPortSampleTime(SimStruct *S,\n                                      int_T     portIdx,\n                                      real_T    sampleTime,\n                                      real_T    offsetTime)\n{\n    if (portIdx == 0) {\n        ssSetInputPortSampleTime(S, portIdx, sampleTime);\n        ssSetInputPortOffsetTime(S, portIdx, offsetTime);\n\t\t/* Set the second outport port sample time temporarily to this,\n\t\t * it will eventually be set in mdlSetOutputPortSampleTime.\n\t\t * We have to do it temporarily here because there are cases \n\t\t * when mdlSetOutputPortSampleTime is not called at all,e.g.,\n\t\t * when the output of S-function is connected to a scope. */     \n        ssSetOutputPortSampleTime(S, 0, sampleTime);\n        ssSetOutputPortOffsetTime(S, 0, offsetTime);\n    } \n} /* end mdlSetInputPortSampleTime */\n#endif /* MDL_SET_INPUT_PORT_SAMPLE_TIME */\n\n#define MDL_SET_OUTPUT_PORT_SAMPLE_TIME\n#if defined(MDL_SET_OUTPUT_PORT_SAMPLE_TIME) && defined(MATLAB_MEX_FILE)\n/* Function: mdlSetOutputPortSampleTime =================================*/\nvoid mdlSetOutputPortSampleTime(SimStruct *S,\n                                      int_T     portIdx,\n                                      real_T    sampleTime,\n                                      real_T    offsetTime)\n{\n    /* Set input port sample time as well */\n    if (portIdx == 0) {\n        ssSetOutputPortSampleTime(S, portIdx, sampleTime);\n        ssSetOutputPortOffsetTime(S, portIdx, offsetTime);\n        ssSetInputPortSampleTime(S, 0, sampleTime);\n        ssSetInputPortOffsetTime(S, 0, offsetTime);\n    }\n} /* end mdlSetOutputPortSampleTime */\n#endif /* MDL_SET_OUTPUT_PORT_SAMPLE_TIME */\n\n/* Function: mdlInitializeSampleTimes ===================================*/\nvoid mdlInitializeSampleTimes(SimStruct *S)\n{\n} /*end mdlInitializeSampleTimes */\n\n/*************************************************************************/\n/****************** SETTING PORT DATA TYPES ******************************/\n/*************************************************************************/\n\n#define MDL_SET_INPUT_PORT_DATA_TYPE\n#if defined(MDL_SET_INPUT_PORT_DATA_TYPE) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetInputPortDataType ==================================*/\n  static void mdlSetInputPortDataType(SimStruct *S, int portIndex,DTypeId dType)\n  {\n    ssSetInputPortDataType(S,portIndex,dType);\n    ssSetOutputPortDataType(S,portIndex,dType);\n  } /* end mdlSetInputPortDataType */\n#endif /* MDL_SET_INPUT_PORT_DATA_TYPE */\n\n#define MDL_SET_OUTPUT_PORT_DATA_TYPE  \n#if defined(MDL_SET_OUTPUT_PORT_DATA_TYPE) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetOutputPortDataType =================================*/\n  static void mdlSetOutputPortDataType(SimStruct *S,int portIndex,DTypeId dType)\n  {\n    ssSetOutputPortDataType(S,portIndex,dType);\n    ssSetInputPortDataType(S,portIndex,dType);\n  } /* end mdlSetOutputPortDataType */\n#endif /* MDL_SET_OUTPUT_PORT_DATA_TYPE */\n\n/* Function: mdlOutputs =================================================*/\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n} /* end mdlOutputs */\n\n/* Function: mdlTerminate ===============================================*/\nstatic void mdlTerminate(SimStruct *S)\n{\n}\n\n/*=============================*\n * Required S-function trailer *\n *=============================*/\n\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n"},{"name":"scd_injection_input.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* Copyright 2009-2013 The MathWorks, Inc. */\n#define S_FUNCTION_NAME  scd_injection_input\n#define S_FUNCTION_LEVEL 2\n\n/*\n * Need to include simstruc.h for the definition of the SimStruct and\n * its associated macro definitions.\n */\n#include \"simstruc.h\"\n#include \"string.h\"\n\n/* Define the parameters */\nenum {INPUT_SIGNAL = 0,IS_VARIABLE_TS,SAMPLE_TIME};\n#define INPUT_SIGNAL_ARG(S)      (ssGetSFcnParam(S,INPUT_SIGNAL))\n#define IS_VARIABLE_TS_ARG(S)    (ssGetSFcnParam(S,IS_VARIABLE_TS))\n#define SAMPLE_TIME_ARG(S)       (ssGetSFcnParam(S,SAMPLE_TIME))\n        \n/*====================*\n * S-function methods *\n *====================*/\n\n/* Function: mdlInitializeSizes ===============================================*/\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n    /* This S-function has 3 parameters:\n     * InputWKSVariable - The name of the variable in workspace which holds the input\n     * as 1 or 2 column matrix in the form of [u] or [t u]. 2 column format is used \n     * when variable sample time option is set to 1 as we need timestamps.\n     * IsVariableTs - If 1, this S-function will be set to be variable sample time.\n     * if 0, it will have the discrete rate specified in the third parameter:\n     * InputSampleTime - sample time of input signal, ignored for variable sample time */\n    ssSetNumSFcnParams(S, 3);\n    \n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {\n        /* Return if number of expected != number of actual parameters */\n        return;\n    }\n\n    ssSetNumContStates(S, 0);\n    ssSetNumDiscStates(S, 0);\n    \n\n    if (!ssSetNumInputPorts(S, 0)) return;\n\n    if (!ssSetNumOutputPorts(S, 1)) return;\n    /* Output is always a scalar of type double */\n    ssSetOutputPortWidth(S, 0, 1);\n\tssSetOutputPortDataType(S, 0, SS_DOUBLE);\n    \n    ssSetNumSampleTimes(S, 1);\n    /* Initialize DWork to hold the current index of the time/input*/\n    ssSetNumDWork(S,1);\n    ssSetDWorkWidth(S,0,1);\n    ssSetDWorkDataType(S,0,7); /* SS_UINT32 */\n    \n    ssSetNumRWork(S, 0);\n    ssSetNumIWork(S, 0);\n    ssSetNumPWork(S, 0);\n    ssSetNumModes(S, 0);\n    ssSetNumNonsampledZCs(S, 0);\n    ssSetOptions(S, 0);\n    \n}\n/* Function: mdlInitializeSampleTimes =====================================\n */\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{\n    const real_T  *isVariableTs = mxGetPr(IS_VARIABLE_TS_ARG(S));\n    const real_T  *sampletime = mxGetPr(SAMPLE_TIME_ARG(S));\n    if (isVariableTs[0] == 1) { \n        ssSetSampleTime(S,0,VARIABLE_SAMPLE_TIME);\n    }\n    else {\n        ssSetSampleTime(S,0, (time_T) sampletime[0]);\n        ssSetOffsetTime(S,0, 0.0);\n    }\n}\n\n#define MDL_GET_TIME_OF_NEXT_VAR_HIT\nstatic void mdlGetTimeOfNextVarHit(SimStruct *S)\n{\n    time_T timeOfNextHit;\n    uint32_T *curindex = (uint32_T*) ssGetDWork(S,0);  \n    const real_T *inputsignal = mxGetPr(INPUT_SIGNAL_ARG(S));\n    /* Determine the next hit from time vector if we are not at the final time step.*/ \n    if (ssGetT(S) != ssGetTFinal(S)) {\n             \n        timeOfNextHit = inputsignal[curindex[0]+1]; \n    }\n    else {\n        /* If we are at the final step, set it to 1 second later since we will not hit it in any case.*/\n        timeOfNextHit = ssGetT(S)+1;\n    }\n    ssSetTNext(S, timeOfNextHit);\n}\n\n#define MDL_START  /* Change to #undef to remove function */\n#if defined(MDL_START) \n/* Function: mdlStart =====================================================\n */\nstatic void mdlStart(SimStruct *S)\n  {\n    uint32_T *curindex = (uint32_T*) ssGetDWork(S,0);\n    /* Initialize the index to zero */\n    curindex[0] = 0;\n  }\n#endif /*  MDL_START */\n\n/* Function: mdlOutputs ===================================================\n */\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n    /* Declare variables to read the data */\n    size_t          numRows = mxGetM(INPUT_SIGNAL_ARG(S));\n    real_T          *signalvalues = mxGetPr(INPUT_SIGNAL_ARG(S));\n    real_T          *y = ssGetOutputPortRealSignal(S,0);\n    /* Get the current index */\n    uint32_T    *curindex = (uint32_T*) ssGetDWork(S,0);\n    \n    /* If it is variable time step, the input signal is in the form of \n     * [t u], 2 column. If it is not variable sample time, it is only [u] with\n     * a single column. */\n    if (ssGetSampleTime(S,0) != VARIABLE_SAMPLE_TIME) {\n        /* The input is expected to be of a single column */\n        if (curindex[0]>= numRows)\n            /* Speak out the final value for later instances */\n            y[0] = signalvalues[numRows-1];\n        else\n            y[0] = signalvalues[curindex[0]];\n        /* Increment the index */\n        curindex[0]++;\n    }\n    else {\n        /* The input is expected to be of 2 columns */\n        if (curindex[0]>= numRows)\n            /* Speak out the final value for later instances, accountting \n             * for time column. */\n            y[0] = signalvalues[2*numRows-1];\n        else\n            y[0] = signalvalues[curindex[0]+numRows];\n        curindex[0]++;  \n    }   \n}\n\nstatic void mdlTerminate(SimStruct *S)\n{\n}\n\n\n/*=============================*\n * Required S-function trailer *\n *=============================*/\n\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n\n\n"},{"name":"scd_injection_main.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/* Copyright 2009-2013 The MathWorks, Inc. */\n#define S_FUNCTION_NAME  scd_injection_main\n#define S_FUNCTION_LEVEL 2\n\n/*\n * Need to include simstruc.h for the definition of the SimStruct and\n * its associated macro definitions.\n */\n#include \"simstruc.h\"\n#include \"string.h\"\n    \n\n/* Define different actions */\nenum {DIRECT_PASS_ACTION = 0, ADD_ACTION, REPLACE_ACTION, OPEN_ACTION};        \n        \n/* Define arguments */        \nenum {IOTYPE = 0, DATATYPE, DIMENSIONS, PORTDATASIZE, SAMPLETIME, SIGNALINDEX};\n#define IOTYPE_ARG(S)         (ssGetSFcnParam(S,IOTYPE))\n#define DATATYPE_ARG(S)       (ssGetSFcnParam(S,DATATYPE))\n#define DIMENSIONS_ARG(S)     (ssGetSFcnParam(S,DIMENSIONS))\n#define PORTDATASIZE_ARG(S)   (ssGetSFcnParam(S,PORTDATASIZE))\n#define SAMPLETIME_ARG(S)     (ssGetSFcnParam(S,SAMPLETIME))\n#define SIGNALINDEX_ARG(S)    (ssGetSFcnParam(S,SIGNALINDEX))\n\n/*====================*\n * S-function methods *\n *====================*/\n\n/* Function: mdlInitializeSizes ===============================================*/\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n    /* This S-function has 6 parameters:\n     * 1) IOType: It is a string that determines the type of action that will be taken\n     * by this S-function. It mainly depends on the type of linearization IO, \n     * and for input type IOs, depends on whether or not it is the active input that\n     * signal is going to be injected from.\n     * 2) DataType: The data type that the second input and output ports will have.\n     * 3) Dimensions: The dimensions that second input and output ports will have.\n     * 4) PortDataSize: The number of bytes that the second input port has. This will be\n     * used when the second input needs to be copied over to the output ports.\n     * 5) SampleTime: The sample time that the second input and output ports will share.\n     * 6) SignalIndex: The index at which element of the second input we will operate on,\n     * it will be used when the second input port is not a scalar. \"-1\" refers to \"all\".\n     */\n    /* Declare necessary variables */\n    real_T     *dataType;\n    real_T     *dimensions;\n    int_T      *intdimensions;\n    int_T      dimsCounter = 1;\n    DECL_AND_INIT_DIMSINFO(dimsInfo);\n    real_T     *sampleTime;\n    \n    \n    ssSetNumSFcnParams(S, 6);\n    \n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {\n        /* Return if number of expected != number of actual parameters */\n        return;\n    }\n    \n    ssSetNumContStates(S, 0);\n    ssSetNumDiscStates(S, 0);\n    ssAllowSignalsWithMoreThan2D(S);\n    if (!ssSetNumInputPorts(S, 2)) return;\n    if (!ssSetNumOutputPorts(S, 2)) return;\n    \n    /* First input is a scalar of type double, coming from the output of\n     * S-function \"injection_input\"*/\n    ssSetInputPortWidth(S, 0, 1);\n\tssSetInputPortDataType(S, 0, SS_DOUBLE);\n    \n    /* Both input are direct feed through and contiguous */\n    ssSetInputPortDirectFeedThrough(S, 0, 1);\n    ssSetInputPortDirectFeedThrough(S, 1, 1);\n    ssSetInputPortRequiredContiguous(S, 0, 1);\n    ssSetInputPortRequiredContiguous(S, 1, 1);\n    \n    /*********************************************************************/\n    /************************* DATA TYPE *********************************/\n    /*********************************************************************/\n    /* Read the data type from the second parameter and set it to second input\n     * port and both output ports. */ \n    dataType = mxGetPr(DATATYPE_ARG(S));\n    ssSetInputPortDataType(S, 1, (DTypeId) dataType[0]);\n    ssSetOutputPortDataType(S, 0, (DTypeId) dataType[0]);\n    ssSetOutputPortDataType(S, 1, (DTypeId) dataType[0]);\n    \n    /*********************************************************************/\n    /************************* DIMENSIONS ********************************/\n    /*********************************************************************/\n    /* Read the dimension info from the third parameter and set it to second \n     * input and both outputs. */\n    dimensions = mxGetPr(DIMENSIONS_ARG(S));\n    dimsInfo.numDims = (int_T) dimensions[0];\n    intdimensions = (int_T*) malloc(dimsInfo.numDims*sizeof(int_T));    \n    dimsInfo.width = 1;\n    for (dimsCounter = 0;dimsCounter<dimsInfo.numDims;dimsCounter++) {\n        intdimensions[dimsCounter] = (int_T) dimensions[dimsCounter+1];\n        dimsInfo.width *= (int_T) dimensions[dimsCounter+1];\n    }\n    dimsInfo.dims = (int_T*) intdimensions;\n    /* Store int dimensions in user data to be able to deallocate */\n    ssSetUserData(S,(void*)intdimensions);\n    ssSetInputPortDimensionInfo(S,1,&dimsInfo);\n    ssSetOutputPortDimensionInfo(S,0,&dimsInfo);\n    ssSetOutputPortDimensionInfo(S,1,&dimsInfo);\n    \n    /*********************************************************************/\n    /************************ SAMPLE TIME ********************************/\n    /*********************************************************************/\n    sampleTime = mxGetPr(SAMPLETIME_ARG(S));\n    ssSetNumSampleTimes(S, PORT_BASED_SAMPLE_TIMES);\n    ssSetInputPortSampleTime(S, 0, INHERITED_SAMPLE_TIME);\n    ssSetInputPortSampleTime(S, 1, sampleTime[0]);\n    ssSetOutputPortSampleTime(S, 0, sampleTime[0]);\n    ssSetOutputPortSampleTime(S, 1, sampleTime[0]);\n    ssSetInputPortOffsetTime(S, 1, sampleTime[1]);\n    ssSetOutputPortOffsetTime(S, 0, sampleTime[1]);\n    ssSetOutputPortOffsetTime(S, 1, sampleTime[1]);\n    \n    /* Initialize DWork to hold the values of:\n\t * 1. Operating point value - generic type\n\t * 2. The action that the S-function should take\n\t * 3. The logging location, whether input or output of the S-function */\n    \n    ssSetNumDWork(S,3);\n    /* Operating point value */\n    ssSetDWorkWidth(S,0,dimsInfo.width);\n    ssSetDWorkDataType(S,0,(DTypeId) dataType[0]);\n\t/* The action */\n\tssSetDWorkWidth(S,1,1);\n\tssSetDWorkDataType(S,1,SS_INT8);\n\t/* Logging whether input or output */\n\tssSetDWorkWidth(S,2,1);\n\tssSetDWorkDataType(S,2,SS_BOOLEAN);\n\n    ssSetNumRWork(S, 0);\n    ssSetNumIWork(S, 0);\n    ssSetNumPWork(S, 0);\n    ssSetNumModes(S, 0);\n    ssSetNumNonsampledZCs(S, 0);\n    ssSetOptions(S,SS_OPTION_CALL_TERMINATE_ON_EXIT);\n \n}\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{    \n}\n\n\n\n#define MDL_START\n#if defined(MDL_START) \n  /* Function: mdlStart =======================================================\n   */\nstatic void mdlStart(SimStruct *S) \n{\n    /* In this function, we will populate permanent settings in work vector\n     * such as action type, so that we do not do such things multiple times\n     * in mdlOutputs. */\n    \n    /* Declare variables and read parameters */\n    char      insertiontype[80];\n    int       portDataSize = (int) *mxGetPr(PORTDATASIZE_ARG(S));\n    /* Read DWork vectors */\n\tint8_T    *action = (int8_T*) ssGetDWork(S,1);\n\tboolean_T *logging = (boolean_T*) ssGetDWork(S,2);\n    \n    /* Variables to define possible actions */\n    boolean_T   isDirectPass;       /* Directly pass the input to outputs */\n    boolean_T   isAdd;              /* Add injection signal on the top of input */\n    boolean_T   isReplace;          /* Speak out injection signal ignoring input */\n    boolean_T   isOpen;             /* Open the loop, speak out op. value */\n    \n    mxGetString(IOTYPE_ARG(S),insertiontype,80);\n    \n\n\n\n     \n\t /* Determine the type of action and logging location so that\n\t  * we do not have to run these ifs at each time step */\n\t \n    /* Check where to log */\n    logging[0] = ((strcmp(insertiontype,\"InputOutput\") == 0) ||\n                   (strcmp(insertiontype,\"InputOutputInactive\") == 0) ||\n                   (strcmp(insertiontype,\"InputOutputOpen\") == 0) ||\n                   (strcmp(insertiontype,\"InputOutputInactiveOpen\") == 0));\n\t \n     /* Determine the action that needs to be taken */\n    isDirectPass = ((strcmp(insertiontype,\"None\") == 0) ||\n                    (strcmp(insertiontype,\"InputInactive\") == 0) ||\n                    (strcmp(insertiontype,\"Output\") == 0) ||\n                    (strcmp(insertiontype,\"InputOutputInactive\") == 0) ||\n                    (strcmp(insertiontype,\"OutputInputInactive\") == 0) );\n\tif (isDirectPass) {\n        action[0] = DIRECT_PASS_ACTION;\n        return;\n\t}\n    isAdd = ((strcmp(insertiontype,\"Input\") == 0) ||\n             (strcmp(insertiontype,\"InputOutput\") == 0) ||\n             (strcmp(insertiontype,\"OutputInput\") == 0));\n\tif (isAdd) {\n        action[0] = ADD_ACTION;\n\t\treturn;\n    }\n\n    isReplace = ((strcmp(insertiontype,\"InputOpen\") == 0) ||\n                 (strcmp(insertiontype,\"InputOutputOpen\") == 0) ||\n                 (strcmp(insertiontype,\"OutputInputOpen\") == 0));\n\tif (isReplace) {\n        action[0] = REPLACE_ACTION;\n\t\treturn;\n\t }\n\n    isOpen = ((strcmp(insertiontype,\"InputInactiveOpen\") == 0) ||\n              (strcmp(insertiontype,\"OutputOpen\") == 0) ||\n              (strcmp(insertiontype,\"InputOutputInactiveOpen\") == 0) ||\n              (strcmp(insertiontype,\"OutputInputInactiveOpen\") == 0) ||\n              (strcmp(insertiontype,\"Open\") == 0) );\n\tif (isOpen) {\n        action[0] = OPEN_ACTION;\n\t\treturn;\n    }    \n\n  }\n#endif /*  MDL_START */\n\n/* Function: mdlOutputs =======================================================\n */\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n    /* Declare variables and read parameters */\n    int     signalIndex = ((int) *mxGetPr(SIGNALINDEX_ARG(S)))-1; /* Adjust for zero-based indexing */\n    int     portDataSize = (int) *mxGetPr(PORTDATASIZE_ARG(S));\n    \n    /* Read the DWork variables */\n    void      *opvalue = ssGetDWork(S,0);\n    int8_T    *action = (int8_T*) ssGetDWork(S,1);\n    boolean_T *isLogOutput = (boolean_T*) ssGetDWork(S,2);\n    \n    /* Input & Output variables as VOID for copying with MEMCPY */\n    const void        *u = ssGetInputPortSignal(S,1);     /* 2nd input port */\n    void              *y = ssGetOutputPortSignal(S,1);       /* 2nd output port */\n    void              *y_log = ssGetOutputPortSignal(S,0);\n    \n    /* Now read input and output with data type double */\n    real_T        *opvalue_real = (real_T*) ssGetDWork(S,0);\n    const real_T  *u_real = ssGetInputPortRealSignal(S,1);\n    const real_T  *u_input_real = ssGetInputPortRealSignal(S,0);\n    real_T        *y_real = ssGetOutputPortRealSignal(S,1);\n    real_T        *ylog_real = ssGetOutputPortRealSignal(S,0);\n    \n    if (ssGetT(S) == ssGetTStart(S)) {\n        /* At t=0, initialize the op. point value to the initial value of second input port */\n        const void *u = ssGetInputPortSignal(S,1);\n        (void)memcpy(opvalue,u,portDataSize);\n    }\n    \n    /* Initially copy the second input to the both outputs */\n    (void)memcpy(y,u,portDataSize);\n    (void)memcpy(y_log,u,portDataSize);\n    /* If it is DirectPass, there is nothing else to be done: return */\n    if (action[0] == DIRECT_PASS_ACTION) {\n        if (isLogOutput[0])\n            /* Copy all elements of y to y_log */\n            (void)memcpy(y_log,y,portDataSize);\n        return;\n    }\n    if (action[0] == OPEN_ACTION) {\n        /* Speak out the operating point value */\n        (void)memcpy(y,opvalue,portDataSize); \n        /* Handle the logging if output is to be logged */\n        if (isLogOutput[0])\n            /* Copy all elements of y to y_log */\n            (void)memcpy(y_log,y,portDataSize);\n        return;\n    }\n     \n    /* Take the action */\n    if (action[0] == ADD_ACTION) {\n        /* Add the injection signal on the top of input */\n        y_real[signalIndex] = u_real[signalIndex]+u_input_real[0];\n        if (isLogOutput[0])\n            /* Copy all elements of y to y_log */\n            (void)memcpy(y_log,y,portDataSize);\n        return;\n    }\n    if (action[0] == REPLACE_ACTION) {\n        /* Speak out the operating point value */\n        (void)memcpy(y,opvalue,portDataSize);\n        /* Speak out the injection signal ignoring the input at the specified index */\n        y_real[signalIndex] = opvalue_real[signalIndex]+u_input_real[0];\n        /* Handle the logging and return */\n        if (isLogOutput[0])\n            /* Copy all elements of y to y_log */\n            (void)memcpy(y_log,y,portDataSize);\n        return;\n    }\n}\nstatic void mdlTerminate(SimStruct *S)\n{\n    /* Deallocate int dimensions stored in user data*/\n    int_T *intdimensions = ssGetUserData(S);\n    free(intdimensions); /*sbcheck::termok*/\n}\n\n\n/*=============================*\n * Required S-function trailer *\n *=============================*/\n\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n\n/* LocalWords:  IOs nd\n */\n"},{"name":"sfun_tstart.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * File : sfun_tstart.c\n * Abstract:\n *      S-function start time used by the repeating sequence and chirp\n *      blocks in Simulink.\n *\n * Copyright 1990-2013 The MathWorks, Inc.\n */\n\n\n#define S_FUNCTION_LEVEL 2\n#define S_FUNCTION_NAME  sfun_tstart\n\n\n#include \"simstruc.h\"\n\n\n/* Function: mdlInitializeSizes ===============================================\n * Abstract:\n *    The sizes information is used by Simulink to determine the S-function\n *    block's characteristics (number of inputs, outputs, states, etc.).\n */\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n\n    ssSetNumSFcnParams(S, 0);  /* Number of expected parameters */\n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {\n        /* Return if number of expected != number of actual parameters */\n        return;\n    }\n\n    if (!ssSetNumInputPorts(S, 0)) return;\n\n    if (!ssSetNumOutputPorts(S, 1)) return;\n    ssSetOutputPortWidth(S, 0, 1);\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);  /* same as clock block */\n    ssSetOutputPortConstOutputExprInRTW(S, 0, 1);\n\n    ssSetNumSampleTimes(S, 1);\n\n    /* specify the operating point save/restore compliance to be same as a built-in block */\n    ssSetOperatingPointCompliance(S, USE_DEFAULT_OPERATING_POINT);\n\n    ssSetOptions(S, \n                 SS_OPTION_WORKS_WITH_CODE_REUSE |\n                 SS_OPTION_USE_TLC_WITH_ACCELERATOR);\n    ssSetRTWCG(S, ssGetIsVmSimulationCompile(S));\n    ssSetSupportedForRowMajorCodeGen(S, true);\n    ssSetArrayLayoutForCodeGen(S, SS_ALL);\n}\n\n\n\n/* Function: mdlInitializeSampleTimes =========================================\n * Abstract:\n *    Set a constant sample time.\n */\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{\n    ssSetSampleTime(S, 0, CONTINUOUS_SAMPLE_TIME);\n    ssSetOffsetTime(S, 0, 0.0);\n    ssSetModelReferenceSampleTimeDefaultInheritance(S);\n}\n\n\n/* Function: mdlStart =========================================================\n * Abstract:\n *    Initialize output value to the start time.\n */\n#define MDL_START\nstatic void mdlStart(SimStruct *S)\n{\n    real_T *y = (real_T *)ssGetOutputPortSignal(S,0);\n    *y = ssGetTStart(S);\n}\n\n\n/* Function: mdlOutputs =======================================================\n * Abstract:\n *    The simulation start time was put into the output memory in \n *    mdlStart() so nothing else needs to be done here.\n */\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n    /* start time set in mdlStart, never changes */\n}\n\n\n\n/* Function: mdlTerminate =====================================================\n * Abstract:\n *    (not used)\n */\nstatic void mdlTerminate(SimStruct *S)\n{\n}\n\n#define MDL_RTWCG\nvoid mdlRTWCG(SimStruct* S, void* ptr) {\n}\n\n\n/*=============================*\n * Required S-function trailer *\n *=============================*/\n\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n"},{"name":"sfun_udt2.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*  File    : sfun_udt2.c\n *  Abstract:\n *\n *      A level 2 S-function to convert an floating point input to a\n *      user-defined structure type\n *\n *  Copyright 1990-2013 The MathWorks, Inc.\n */\n\n\n#define S_FUNCTION_NAME  sfun_udt2\n#define S_FUNCTION_LEVEL 2\n\n#include \"simstruc.h\"\n\n\n/* Define an enumerated type, as well as a struct that will be used in\n * simulation and code generation.  The structure encodes a floating\n * point value with a signed integer representation.  If the magnitude of\n * of the floating point value being encoded is less than or equal to 1.0,\n * then encode the value using high resolution; otherwise encode the value\n * using low resolution\n */\ntypedef enum { LO_RES, HI_RES } Resolution;\ntypedef struct { Resolution res; int8_T value; } Data;\n\n\nstatic Data zero = { HI_RES, 0 };\n\n/* Function: mdlInitializeSizes ===============================================\n * Abstract:\n *   Setup sizes of the various vectors.\n */\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n    slDataTypeAccess *dta = ssGetDataTypeAccess(S);\n    int              udtId;\n\n    ssSetNumSFcnParams(S, 0);  /* Number of expected parameters */\n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {\n        /* Return if number of expected != number of actual parameters */\n        return;\n    }\n\n    /* Obtain an integer datatype ID for the udt (user-defined type) \"Data\" */\n    udtId = ssRegisterDataType(S, \"Data\");\n    if ( udtId == INVALID_DTYPE_ID ) return;\n\n    /* Register the size of the udt */\n    if (!ssSetDataTypeSize(S, udtId, sizeof(Data))) return;\n\n    /* Register the zero of the udt */\n    if (!ssSetDataTypeZero(S, udtId, &zero)) return;\n\n    /* Set input-port properties */\n    if (!ssSetNumInputPorts(S, 1)) return;\n    ssSetInputPortWidth(S, 0, 1);\n    ssSetInputPortDataType(S, 0, SS_DOUBLE);\n    ssSetInputPortDirectFeedThrough(S, 0, 1);\n\n    /* Set output port properties */\n    if (!ssSetNumOutputPorts(S, 1)) return;\n    ssSetOutputPortDataType(S, 0, udtId);\n    ssSetOutputPortWidth(S, 0, 1);\n\n    /* Set miscellaneous properties */\n    ssSetNumContStates(S, 0);\n    ssSetNumDiscStates(S, 0);\n    ssSetNumSampleTimes(S, 1);\n    ssSetNumRWork(S, 0);\n    ssSetNumIWork(S, 0);\n    ssSetNumPWork(S, 0);\n    ssSetNumModes(S, 0);\n    ssSetNumNonsampledZCs(S, 0);\n\n    /* specify the sim state compliance to be same as a built-in block */\n    ssSetSimStateCompliance(S, USE_DEFAULT_SIM_STATE);\n\n    ssSetOptions(S,\n                 SS_OPTION_WORKS_WITH_CODE_REUSE);\n}\n\n/* Function: mdlInitializeSampleTimes =========================================\n * Abstract:\n *    This function is used to specify the sample time(s) for your\n *    S-function. You must register the same number of sample times as\n *    specified in ssSetNumSampleTimes.\n */\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{\n    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);\n    ssSetOffsetTime(S, 0, 0.0);\n    ssSetModelReferenceSampleTimeDefaultInheritance(S);\n}\n\n\n/* Function: mdlOutputs =======================================================\n * Abstract:\n */\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n    InputRealPtrsType u  = ssGetInputPortRealSignalPtrs(S,0);\n    Data              *y = ssGetOutputPortSignal(S,0);\n\n    if (*u[0] > 127 || mxIsInf(*u[0])) {\n        y->value = 127;\n        y->res = LO_RES;\n    } else if (*u[0] < 1.0 && *u[0] > -1.0) {\n        y->value = (int8_T) (127.0 * *u[0]);\n        y->res   = HI_RES;\n    } else {\n        y->value = (int8_T) *u[0];\n        y->res   = LO_RES;\n    }\n}\n\n\n/* Function: mdlTerminate =====================================================\n * Abstract:\n *    Noop\n */\nstatic void mdlTerminate(SimStruct *S)\n{\n}\n\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n\n"},{"name":"sfuntmpl_basic.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * sfuntmpl_basic.c: Basic 'C' template for a level 2 S-function.\n *\n * Copyright 1990-2018 The MathWorks, Inc.\n */\n\n\n/*\n * You must specify the S_FUNCTION_NAME as the name of your S-function\n * (i.e. replace sfuntmpl_basic with the name of your S-function).\n */\n\n#define S_FUNCTION_NAME  sfuntmpl_basic\n#define S_FUNCTION_LEVEL 2\n\n/*\n * Need to include simstruc.h for the definition of the SimStruct and\n * its associated macro definitions.\n */\n#include \"simstruc.h\"\n\n\n\n/* Error handling\n * --------------\n *\n * You should use the following technique to report errors encountered within\n * an S-function:\n *\n *       ssSetErrorStatus(S,\"Error encountered due to ...\");\n *       return;\n *\n * Note that the 2nd argument to ssSetErrorStatus must be persistent memory.\n * It cannot be a local variable. For example the following will cause\n * unpredictable errors:\n *\n *      mdlOutputs()\n *      {\n *         char msg[256];         {ILLEGAL: to fix use \"static char msg[256];\"}\n *         sprintf(msg,\"Error due to %s\", string);\n *         ssSetErrorStatus(S,msg);\n *         return;\n *      }\n *\n */\n\n/*====================*\n * S-function methods *\n *====================*/\n\n/* Function: mdlInitializeSizes ===============================================\n * Abstract:\n *    The sizes information is used by Simulink to determine the S-function\n *    block's characteristics (number of inputs, outputs, states, etc.).\n */\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n    ssSetNumSFcnParams(S, 0);  /* Number of expected parameters */\n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {\n        /* Return if number of expected != number of actual parameters */\n        return;\n    }\n\n    ssSetNumContStates(S, 0);\n    ssSetNumDiscStates(S, 0);\n\n    if (!ssSetNumInputPorts(S, 1)) return;\n    ssSetInputPortWidth(S, 0, 1);\n    ssSetInputPortRequiredContiguous(S, 0, true); /*direct input signal access*/\n    /*\n     * Set direct feedthrough flag (1=yes, 0=no).\n     * A port has direct feedthrough if the input is used in either\n     * the mdlOutputs or mdlGetTimeOfNextVarHit functions.\n     */\n    ssSetInputPortDirectFeedThrough(S, 0, 1);\n\n    if (!ssSetNumOutputPorts(S, 1)) return;\n    ssSetOutputPortWidth(S, 0, 1);\n\n    ssSetNumSampleTimes(S, 1);\n    ssSetNumRWork(S, 0);\n    ssSetNumIWork(S, 0);\n    ssSetNumPWork(S, 0);\n    ssSetNumModes(S, 0);\n    ssSetNumNonsampledZCs(S, 0);\n\n    /* Specify the operating point save/restore compliance to be same as a \n     * built-in block */\n    ssSetOperatingPointCompliance(S, USE_DEFAULT_OPERATING_POINT);\n\n    ssSetRuntimeThreadSafetyCompliance(S, RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE);\n    ssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE);\n}\n\n\n\n/* Function: mdlInitializeSampleTimes =========================================\n * Abstract:\n *    This function is used to specify the sample time(s) for your\n *    S-function. You must register the same number of sample times as\n *    specified in ssSetNumSampleTimes.\n */\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{\n    ssSetSampleTime(S, 0, CONTINUOUS_SAMPLE_TIME);\n    ssSetOffsetTime(S, 0, 0.0);\n\n}\n\n\n\n#define MDL_INITIALIZE_CONDITIONS   /* Change to #undef to remove function */\n#if defined(MDL_INITIALIZE_CONDITIONS)\n  /* Function: mdlInitializeConditions ========================================\n   * Abstract:\n   *    In this function, you should initialize the continuous and discrete\n   *    states for your S-function block.  The initial states are placed\n   *    in the state vector, ssGetContStates(S) or ssGetRealDiscStates(S).\n   *    You can also perform any other initialization activities that your\n   *    S-function may require. Note, this routine will be called at the\n   *    start of simulation and if it is present in an enabled subsystem\n   *    configured to reset states, it will be call when the enabled subsystem\n   *    restarts execution to reset the states.\n   */\n  static void mdlInitializeConditions(SimStruct *S)\n  {\n  }\n#endif /* MDL_INITIALIZE_CONDITIONS */\n\n\n\n#define MDL_START  /* Change to #undef to remove function */\n#if defined(MDL_START) \n  /* Function: mdlStart =======================================================\n   * Abstract:\n   *    This function is called once at start of model execution. If you\n   *    have states that should be initialized once, this is the place\n   *    to do it.\n   */\n  static void mdlStart(SimStruct *S)\n  {\n  }\n#endif /*  MDL_START */\n\n\n\n/* Function: mdlOutputs =======================================================\n * Abstract:\n *    In this function, you compute the outputs of your S-function\n *    block.\n */\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n    const real_T *u = (const real_T*) ssGetInputPortSignal(S,0);\n    real_T       *y = ssGetOutputPortSignal(S,0);\n    y[0] = u[0];\n}\n\n\n\n#define MDL_UPDATE  /* Change to #undef to remove function */\n#if defined(MDL_UPDATE)\n  /* Function: mdlUpdate ======================================================\n   * Abstract:\n   *    This function is called once for every major integration time step.\n   *    Discrete states are typically updated here, but this function is useful\n   *    for performing any tasks that should only take place once per\n   *    integration step.\n   */\n  static void mdlUpdate(SimStruct *S, int_T tid)\n  {\n  }\n#endif /* MDL_UPDATE */\n\n\n\n#define MDL_DERIVATIVES  /* Change to #undef to remove function */\n#if defined(MDL_DERIVATIVES)\n  /* Function: mdlDerivatives =================================================\n   * Abstract:\n   *    In this function, you compute the S-function block's derivatives.\n   *    The derivatives are placed in the derivative vector, ssGetdX(S).\n   */\n  static void mdlDerivatives(SimStruct *S)\n  {\n  }\n#endif /* MDL_DERIVATIVES */\n\n\n\n/* Function: mdlTerminate =====================================================\n * Abstract:\n *    In this function, you should perform any actions that are necessary\n *    at the termination of a simulation.  For example, if memory was\n *    allocated in mdlStart, this is the place to free it.\n */\nstatic void mdlTerminate(SimStruct *S)\n{\n}\n\n\n/*=============================*\n * Required S-function trailer *\n *=============================*/\n\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n"},{"name":"sfuntmpl_doc.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * File: sfuntmpl_doc.c\n * Abstract:\n *       A 'C' template for a level 2 S-function. \n *\n *       See sfuntmpl_basic.c\n *       for a basic C-MEX template file that uses the \n *       most common methods.\n *\n * Copyright 1990-2021 The MathWorks, Inc.\n */\n\n\n/*\n * You must specify the S_FUNCTION_NAME as the name of your S-function.\n */\n\n#define S_FUNCTION_NAME  your_sfunction_name_here\n#define S_FUNCTION_LEVEL 2\n\n/*\n * Need to include simstruc.h for the definition of the SimStruct and\n * its associated macro definitions.\n *\n * The following headers are included by matlabroot/simulink/include/simstruc.h\n * when compiling as a MEX file:\n *\n *   matlabroot/extern/include/tmwtypes.h    - General types, e.g. real_T\n *   matlabroot/extern/include/mex.h         - MATLAB MEX file API routines\n *   matlabroot/extern/include/matrix.h      - MATLAB MEX file API routines\n *\n * The following headers are included by matlabroot/simulink/include/simstruc.h\n * when compiling your S-function with RTW:\n *\n *   matlabroot/extern/include/tmwtypes.h    - General types, e.g. real_T\n *   matlabroot/rtw/c/libsrc/rt_matrx.h      - Macros for MATLAB API routines\n *\n */\n#include \"simstruc.h\"\n\n\n/* Error handling\n * --------------\n *\n * You should use the following technique to report errors encountered within\n * an S-function:\n *\n *       ssSetErrorStatus(S,\"error encountered due to ...\");\n *       return;\n *\n * Note that the 2nd argument to ssSetErrorStatus must be persistent memory.\n * It cannot be a local variable in your procedure. For example the following\n * will cause unpredictable errors:\n *\n *      mdlOutputs()\n *      {\n *         char msg[256];         {ILLEGAL: to fix use \"static char msg[256];\"}\n *         sprintf(msg,\"Error due to %s\", string);\n *         ssSetErrorStatus(S,msg);\n *         return;\n *      }\n *\n * The ssSetErrorStatus error handling approach is the suggested alternative\n * to using the mexErrMsgTxt function.  MexErrMsgTxt uses \"exception handling\"\n * to immediately terminate S-function execution and return control to\n * Simulink. In order to support exception handling inside of S-functions,\n * Simulink must setup exception handlers prior to each S-function invocation.\n * This introduces overhead into simulation.\n *\n * If you do not call mexErrMsgTxt or any other routines that cause exceptions,\n * then you should use SS_OPTION_EXCEPTION_FREE_CODE S-function option.  This\n * is done by issuing the following command in the mdlInitializeSizes function:\n *\n *      ssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE);\n *\n * Setting this option, will increase the performance of your S-function by\n * allowing Simulink to bypass the exception handling setup that is usually\n * performed prior to each S-function invocation.  Extreme care must be taken\n * to verify that your code is exception free when using the\n * SS_OPTION_EXCEPTION_FREE_CODE option.  If your S-function generates\n * an exception when this option is set, unpredictable results will occur.\n *\n * Exception free code refers to code which never \"long jumps\". Your S-function\n * is not exception free if it contains any routine which when called has\n * the potential of long jumping. For example mexErrMsgTxt throws an exception\n * (i.e. long jumps) when called, thus ending execution of your S-function.\n * Use of mxCalloc may cause unpredictable problems in the event of a memory\n * allocation error since mxCalloc will long jump. If memory allocation is\n * needed, you should use the stdlib.h calloc routine directly and perform\n * your own error handling.\n *\n * All mex* routines have the potential of long jumping (i.e. throwing an\n * exception). In addition several mx* routines have the potential of\n * long jumping. To avoid any difficulties, only the routines which get\n * a pointer or determine the size of parameters should be used. For example\n * the following will never throw an exception: mxGetPr, mxGetData,\n * mxGetNumberOfDimensions, mxGetM, mxGetN, mxGetNumberOfElements.\n *\n * If all of your \"run-time\" methods within your S-function are exception\n * free, then you can use the option:\n *      ssSetOptions(S, SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);\n * The other methods in your S-function need not be exception free. The\n * run-time methods include any of the following:\n *    mdlGetTimeOfNextVarHit, mdlOutputs, mdlUpdate, and mdlDerivatives\n *\n * Warnings & Printf's\n * -------------------\n *   You can use ssWarning(S,msg) to display a warning. \n *    - When the S-function is compiled via mex for use with Simulink,\n *      ssWarning equates to mexWarnMsgTxt.\n *    - When the S-function is used with Simulink Coder, \n *      ssWarning(S,msg) equates to \n *        printf(\"Warning: in block '%s', '%s'\\n\", ssGetPath(S),msg);\n *      if the target has stdio facilities, otherwise it becomes a comment and \n *      is disabled.\n *   \n *   You can use ssPrintf(fmt, ...) to print a message. \n *    - When the S-function is compiled via mex for use with Simulink,\n *      ssPrintf equates to mexPrintf.\n *    - When the S-function is used with Simulink Coder, \n *      ssPrintf equates to printf, if the target has stdio facilities, \n *      otherwise it becomes a call to a empty function (rtPrintfNoOp).\n *    - In the case of Simulink Coder which may or may not have stdio\n *      facilities, to generate the most efficient code use:\n *         #if defined(SS_STDIO_AVAILABLE)\n *            ssPrintf(\"my message ...\");\n *         #endif\n *    - You can also use this technique to do other standard I/O related items,\n *      such as:\n *         #if defined(SS_STDIO_AVAILABLE)\n *             if ((fp=fopen(file,\"w\")) == NULL) {\n *                ssSetErrorStatus(S,\"open failed\");\n *                return;\n *             }\n *             ...\n *         #endif\n */\n\n/*====================*\n * S-function methods *\n *====================*/\n\n/* \n * Level 2 S-function methods\n * --------------------------\n *    Notation:  \"=>\" indicates method is required.\n *                [method] indicates method is optional.\n *\n *    Note, many of the methods below are only available for use in level 2 \n *    C-MEX S-functions.\n *\n * Model Initialization in Simulink\n * --------------------------------\n *=> mdlInitializeSizes         -  Initialize SimStruct sizes array\n *\n *\n *       NOTE: An S-function cannot use mdlSetInput(Output)PortWidth and\n *       mdlSetInput(Output)PortDimensionInfo at the same time. It can use\n *       either a width or dimension method, but not both.\n * \n *   [mdlSetInputPortWidth]     -  Optional method. Check and set input and\n *                                 optionally other port widths. \n *   [mdlSetOutputPortWidth]    -  Optional method. Check and set output\n *                                 and optionally other port widths. \n *\n *   [mdlSetInputPortDimensionInfo]\n *                              -  Optional method. Check and set input and\n *                                 optionally other port dimensions. \n *   [mdlSetOutputPortDimensionInfo]    \n *                              -  Optional method. Check and set output\n *                                 and optionally other port dimensions. \n *   [mdlSetDefaultPortDimensionInfo]\n *                               - Optional method. Set dimensions of all \n *                                 input and output ports that have unknown \n *                                 dimensions. \n *\n *   [mdlSetInputPortSampleTime] - Optional method. Check and set input\n *                                 port sample time and optionally other port\n *                                 sample times.\n *   [mdlSetOutputPortSampleTime]- Optional method. Check and set output\n *                                 port sample time and optionally other port\n *                                 sample times.\n *=> mdlInitializeSampleTimes   -  Initialize sample times and optionally\n *                                 function-call connections. \n *\n *   [mdlSetInputPortDataType]    - Optional method. Check and set input port\n *                                  data type. See SS_DOUBLE to SS_BOOLEAN in\n *                                  simstruc_types.h for built-in data types.\n *   [mdlSetOutputPortDataType]   - Optional method. Check and set output port\n *                                  data type. See SS_DOUBLE to SS_BOOLEAN in\n *                                  simstruc_types.h for built-in data types.\n *   [mdlSetDefaultPortDataTypes] - Optional method. Set data types of all \n *                                  dynamically typed input and output ports.\n *\n *   [mdlInputPortComplexSignal]  - Optional method. Check and set input\n *                                  port complexity attribute (COMPLEX_YES,\n *                                  COMPLEX_NO).\n *   [mdlOutputPortComplexSignal] - Optional method. Check and set output\n *                                  port complexity attribute (COMPLEX_YES,\n *                                  COMPLEX_NO).\n *   [mdlSetDefaultPortComplexSignals]\n *                                - Optional method. Set complex signal flags\n *                                  of all input and output ports who\n *                                  have their complex signals set to\n *                                  COMPLEX_INHERITED (dynamic complexity).\n * \n *   [mdlSetWorkWidths]         -  Optional method. Set the state, iwork,\n *                                 rwork, pwork, dwork, etc sizes. \n *\n *   [mdlStart]                 -  Optional method. Perform actions such\n *                                 as allocating memory and attaching to pwork\n *                                 elements.  \n *\n *   [mdlInitializeConditions]  -  Initialize model parameters (usually\n *                                 states). Will not be called if your\n *                                 S-function does not have an initialize\n *                                 conditions method.\n *\n *   ['constant' mdlOutputs]    -  Execute blocks with constant sample\n *                                 times. These are only executed once\n *                                 here.\n *\n *   [mdlSetOperatingPoint]     -  Optional method. Load the operating point\n *                                 of this block. This function is called when\n *                                 starting the simulation from an initial\n *                                 simulation state, specified through a\n *                                 ModelOperatingPoint object, and this S-function set\n *                                 its operating point compliance (see ssSetOperatingPointCompliance)\n *                                 to USE_CUSTOM_OPERATING_POINT. See also mdlGetOperatingPoint.\n * \n * Model simulation loop in Simulink\n * ---------------------------------\n *   [mdlCheckParameters]       -  Optional method. Will be called at\n *                                 any time during the simulation loop when\n *                                 parameters change. \n *   SimulationLoop:\n *        [mdlProcessParameters]   -  Optional method. Called during\n *                                    simulation after parameters have been\n *                                    changed and verified to be okay by\n *                                    mdlCheckParameters. The processing is\n *                                    done at the \"top\" of the simulation loop\n *                                    when it is safe to process the changed\n *                                    parameters. \n *        [mdlGetTimeOfNextVarHit] -  Optional method. If your S-function\n *                                    has a variable step sample time, then\n *                                    this method will be called.\n *        [mdlInitializeConditions]-  Optional method. Only called if your\n *                                    S-function resides in an enabled\n *                                    subsystem configured to reset states,\n *                                    and the subsystem has just enabled.\n *     => mdlOutputs               -  Major output call (usually updates\n *                                    output signals).\n *        [mdlUpdate]              -  Update the discrete states, etc.\n *\n *        Integration (Minor time step)\n *          [mdlDerivatives]         -  Compute the derivatives.\n *          Do\n *            [mdlOutputs]\n *            [mdlDerivatives]\n *          EndDo - number of iterations depends on solver\n *          Do \n *            [mdlOutputs]\n *            [mdlZeroCrossings]\n *          EndDo - number of iterations depends on zero crossings signals\n *        EndIntegration\n *\n *   EndSimulationLoop\n *   \n *   [mdlGetOperatingPoint] -   Optional method. Called to save the operating point for this block\n *                              if the model is configured to save its final simulation state as an\n *                              operating point object and this S-Function sets its operating point\n *                              compliance (see ssSetOperatingPointCompliance) to\n *                              USE_CUSTOM_OPERATING_POINT. See also mdlSetOperatingPoint.\n *                              \n *\n *   => mdlTerminate   -  End of model housekeeping - free memory, etc.\n *\n * Model initialization for code generation (rtwgen)\n * -------------------------------------------------\n *   <Initialization. See \"Model Initialization in Simulink\" above>\n *\n *   [mdlRTW]                   -  Optional method.  Only called when\n *                                 generating code to add information to the\n *                                 model.rtw file which is used by the\n *                                 Simulink Coder.\n *\n *   mdlTerminate               -  End of model housekeeping - free memory,\n *                                 etc.\n *\n * Noninlined S-function execution in Simulink Coder\n * -----------------------------------------------------\n *   1) The results of most initialization methods are 'compiled' into\n *      the generated code and many methods are not called.\n *   2) Noninlined S-functions are limited in several ways, for example \n *      parameter must be real (non-complex) double vectors or strings. More \n *      capability is provided via the Target Language Compiler.  See the \n *      Target Language Compiler Reference Guide.\n *\n * => mdlInitializeSizes        -  Initialize SimStruct sizes array\n * => mdlInitializeSampleTimes  -  Initialize sample times and optionally\n *                                 function-call connections. \n *   [mdlInitializeConditions]  -  Initialize model parameters (usually\n *                                 states). Will not be called if your\n *                                 S-function does not have an initialize\n *                                 conditions method.\n *   [mdlStart]                 -  Optional method. Perform actions such\n *                                 as allocating memory and attaching to pwork\n *                                 elements.  \n *   ExecutionLoop:\n *     => mdlOutputs            -  Major output call (usually updates\n *                                 output signals).\n *        [mdlUpdate]           -  Update the discrete states, etc.\n *\n *        Integration (Minor time step)\n *          [mdlDerivatives]         -  Compute the derivatives.\n *          Do\n *            [mdlOutputs]\n *            [mdlDerivatives]\n *          EndDo - number of iterations depends on solver\n *          Do \n *            [mdlOutputs]\n *            [mdlZeroCrossings]\n *          EndDo - number of iterations depends on zero crossings signals\n *   EndExecutionLoop\n *   mdlTerminate               -  End of model housekeeping - free memory,\n *                                 etc.\n */\n\n\n/*====================================================================*\n * Parameter handling methods. These methods are not supported by RTW *\n *====================================================================*/\n\n#define MDL_CHECK_PARAMETERS   /* Change to #undef to remove function */\n#if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlCheckParameters =============================================\n   * Abstract:\n   *    mdlCheckParameters verifies new parameter settings whenever parameter\n   *    change or are re-evaluated during a simulation. When a simulation is\n   *    running, changes to S-function parameters can occur at any time during\n   *    the simulation loop.\n   *\n   *    This method can be called at any point after mdlInitializeSizes.\n   *    You should add a call to this method from mdlInitializeSizes\n   *    to check the parameters. After setting the number of parameters\n   *    you expect in your S-function via ssSetNumSFcnParams(S,n), you should:\n   *     #if defined(MATLAB_MEX_FILE)\n   *       if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\n   *           mdlCheckParameters(S);\n   *           if (ssGetErrorStatus(S) != NULL) return;\n   *       } else {\n   *           return;     Simulink will report a parameter mismatch error\n   *       }\n   *     #endif\n   *\n   *     When a Simulation is running, changes to S-function parameters can\n   *     occur either at the start of a simulation step, or during a\n   *     simulation step. When changes to S-function parameters occur during\n   *     a simulation step, this method is called twice, for the same\n   *     parameter changes. The first call during the simulation step is\n   *     used to verify that the parameters are correct. After verifying the\n   *     new parameters, the simulation continues using the original\n   *     parameter values until the next simulation step at which time the\n   *     new parameter values will be used. Redundant calls are needed to\n   *     maintain simulation consistency.  Note that you cannot access the\n   *     work, state, input, output, etc. vectors in this method. This\n   *     method should only be used to validate the parameters. Processing\n   *     of the parameters should be done in mdlProcessParameters.\n   *\n   *     See matlabroot/simulink/src/sfun_errhdl.c for an example. \n   */\n  static void mdlCheckParameters(SimStruct *S)\n  {\n  }\n#endif /* MDL_CHECK_PARAMETERS */\n\n\n#define MDL_PROCESS_PARAMETERS   /* Change to #undef to remove function */\n#if defined(MDL_PROCESS_PARAMETERS) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlProcessParameters ===========================================\n   * Abstract:\n   *    This method will be called after mdlCheckParameters, whenever\n   *    parameters change or get re-evaluated. The purpose of this method is\n   *    to process the newly changed parameters. For example \"caching\" the\n   *    parameter changes in the work vectors. Note this method is not\n   *    called when it is used with the Simulink Coder. Therefore,\n   *    if you use this method in an S-function which is being used with the\n   *    Simulink Coder, you must write your S-function such that it doesn't\n   *    rely on this method. This can be done by inlining your S-function\n   *    via the Target Language Compiler.\n   */\n  static void mdlProcessParameters(SimStruct *S)\n  {\n  }\n#endif /* MDL_PROCESS_PARAMETERS */\n\n\n\n/*=====================================*\n * Configuration and execution methods *\n *=====================================*/\n\n/* Function: mdlInitializeSizes ===============================================\n * Abstract:\n *    The sizes information is used by Simulink to determine the S-function\n *    block's characteristics (number of inputs, outputs, states, etc.).\n *\n *    Direct Feedthrough:\n *       The direct feedthrough flag can be either 1=yes or 0=no. It should be\n *       set to 1 if the input, \"u\", is used in the mdlOutput or\n *       mdlGetTimeOfNextVarHit() function. Setting this to 0 is akin to making\n *       a promise that \"u\" will not be used in the mdlOutput or\n *       mdlGetTimeOfNextVarHit() function. If you break the promise, then\n *       unpredictable results will occur.\n *\n *       It is very common for S-function authors to write incorrect S-functions\n *       when configuring the S-function direct feedthrough flag. We often find\n *       that S-function authors are confused about what the correct setting for\n *       the direct feedthrough flag should be. Part of the confusion is because\n *       the term direct feedthrough is misleading. To reduce the confusion, you\n *       can think of the direct feedthrough setting as a 'needs input'\n *       setting. Specifically, if the S-function access an input signal in\n *       either mdlOutputs() or mdlGetTimeOfNextVarHit(), then the direct\n *       feedthrough flag must be set to 1 (true).\n *    \n *       For example, if a level 2 C-MEX S-function uses:\n *          ssGetInputPortSignal(S,inputPortIndex)\n *       in its mdlOutputs() or mdlGetTimeOfNextVarHit() methods, then the \n *       S-function is required to set the direct feedthrough flag to true in \n *       its mdlInitializeSizes() method:\n *          ssSetInputPortDirectFeedThrough(S, inputPortIdx, 1);\n *    \n *       If your S-Function uses ssGetInputPortSignal() in mdlOutputs() or\n *       mdlGetTimeOfNextVarHit() and fails to specify\n *       the direct feedthrough, or specifies it wrongly using\n *         ssSetInputPortDirectFeedThrough(S, inputPortIdx, 0);\n *       then the S-Function is incorrectly written and Simulink will not\n *       operate correctly and may crash.\n *\n *       When you compile your S-function with debugging, e.g.,\n *         mex -g sfunction_name.c\n *       your S-function will be instrumented such that an incorrect access to\n *       an input signal will generate a diagnostic message.\n *\n *    The NumContStates, NumDiscStates, NumInputs, NumOutputs, NumRWork,\n *    NumIWork, NumPWork NumModes, and NumNonsampledZCs widths can be set to:\n *       DYNAMICALLY_SIZED    - In this case, they will be set to the actual\n *                              input width, unless you have a mdlSetWorkWidths\n *                              to set the widths.\n *       0 or positive number - This explicitly sets item to the specified\n *                              value.\n */\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n    int_T nInputPorts  = 1;  /* number of input ports  */\n    int_T nOutputPorts = 1;  /* number of output ports */\n    int_T needsInput   = 1;  /* direct feed through    */\n\n    int_T inputPortIdx  = 0;\n    int_T outputPortIdx = 0;\n\n\n    ssSetNumSFcnParams(S, 0);  /* Number of expected parameters */\n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {\n        /*\n         * If the number of expected input parameters is not equal\n         * to the number of parameters entered in the dialog box return.\n         * Simulink will generate an error indicating that there is a\n         * parameter mismatch.\n         */\n        return;\n    }\n\n    /* \n     * Configure tunability of parameters.  By default, all parameters are\n     * tunable (changeable) during simulation.  If there are parameters that \n     * cannot change during simulation, such as any parameters that would change \n     * the number of ports on the block, the sample time of the block, or the \n     * data type of a signal, mark these as non-tunable using a call like this:\n     * \n     *    ssSetSFcnParamTunable(S, 0, 0);\n     *\n     * which sets parameter 0 to be non-tunable (0).\n     *\n     */\n\n\n    /* Register the number and type of states the S-Function uses */\n\n    ssSetNumContStates(    S, 0);   /* number of continuous states           */\n    ssSetNumDiscStates(    S, 0);   /* number of discrete states             */\n\n\n    /*\n     * Configure the input ports. First set the number of input ports. \n     */\n    if (!ssSetNumInputPorts(S, nInputPorts)) return;    \n    /*\n     * Set input port dimensions for each input port index starting at 0.\n     * The following options summarize different ways for setting the input \n     * port dimensions. \n     *\n     * (1) If the input port dimensions are unknown, use\n     *     ssSetInputPortDimensionInfo(S, inputPortIdx, DYNAMIC_DIMENSION))\n     *\n     * (2) If the input signal is an unoriented vector, and the input port \n     *     width is w, use\n     *     ssSetInputPortVectorDimension(S, inputPortIdx, w)\n     *     w (or width) can be DYNAMICALLY_SIZED or greater than 0.\n     *     This is equivalent to ssSetInputPortWidth(S, inputPortIdx, w).\n     *\n     * (3) If the input signal is a matrix of dimension mxn, use \n     *     ssSetInputPortMatrixDimensions(S, inputPortIdx, m, n)\n     *     m and n can be DYNAMICALLY_SIZED or greater than zero.\n     *\n     * (4) Otherwise use:\n     *     ssSetInputPortDimensionInfo(S, inputPortIdx, dimsInfo)\n     *     This function can be used to fully or partially initialize the port \n     *     dimensions. dimsInfo is a structure containing width, number of \n     *     dimensions, and dimensions of the port.\n     */\n    if(!ssSetInputPortDimensionInfo(S, inputPortIdx, DYNAMIC_DIMENSION)) return;\n    /*\n     * Set direct feedthrough flag (1=yes, 0=no).\n     * A port has direct feedthrough if the input is used in either\n     * the mdlOutputs or mdlGetTimeOfNextVarHit functions.\n     * See sfuntmpl_directfeed.txt.\n     */\n    ssSetInputPortDirectFeedThrough(S, inputPortIdx, needsInput);\n\n    /*\n     * Configure the output ports. First set the number of output ports.\n     */\n    if (!ssSetNumOutputPorts(S, nOutputPorts)) return;\n\n    /*\n     * Set output port dimensions for each output port index starting at 0.\n     * See comments for setting input port dimensions.\n     */\n    if(!ssSetOutputPortDimensionInfo(S,outputPortIdx,DYNAMIC_DIMENSION)) return;\n\n    /*\n     * Set the number of sample times. This must be a positive, nonzero\n     * integer indicating the number of sample times or it can be\n     * PORT_BASED_SAMPLE_TIMES. For multi-rate S-functions, the\n     * suggested approach to setting sample times is via the port\n     * based sample times method. When you create a multirate\n     * S-function, care needs to be taking to verify that when\n     * slower tasks are preempted that your S-function correctly\n     * manages data as to avoid race conditions. When port based\n     * sample times are specified, the block cannot inherit a constant\n     * sample time at any port.\n     */\n    ssSetNumSampleTimes(   S, 1);   /* number of sample times                */\n\n    /*\n     * Set size of the work vectors.\n     */\n    ssSetNumRWork(         S, 0);   /* number of real work vector elements   */\n    ssSetNumIWork(         S, 0);   /* number of integer work vector elements*/\n    ssSetNumPWork(         S, 0);   /* number of pointer work vector elements*/\n    ssSetNumModes(         S, 0);   /* number of mode work vector elements   */\n    ssSetNumNonsampledZCs( S, 0);   /* number of non-sampled zero crossings   */\n\n    /* Specify the operating point save/restore compliance to be same as a built-in block */\n    /* see sfun_OperatingPoint.c for examples of other possible settings */\n    ssSetOperatingPointCompliance(S, USE_DEFAULT_OPERATING_POINT);\n\n    /*\n     * All options have the form SS_OPTION_<name> and are documented in\n     * matlabroot/simulink/include/simstruc.h. The options should be\n     * bitwise or'd together as in\n     *   ssSetOptions(S, (SS_OPTION_name1 | SS_OPTION_name2))\n     */\n\n    ssSetOptions(          S, 0);   /* general options (SS_OPTION_xx)        */\n\n} /* end mdlInitializeSizes */\n\n\n#define MDL_SET_INPUT_PORT_WIDTH   /* Change to #undef to remove function */\n#if defined(MDL_SET_INPUT_PORT_WIDTH) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetInputPortWidth ===========================================\n   * Abstract:\n   *    This method is called with the candidate width for a dynamically\n   *    sized port.  If the proposed width is acceptable, the method should\n   *    go ahead and set the actual port width using ssSetInputPortWidth.  If\n   *    the size is unacceptable an error should generated via\n   *    ssSetErrorStatus.  Note that any other dynamically sized input or\n   *    output ports whose widths are implicitly defined by virtue of knowing\n   *    the width of the given port can also have their widths set via calls\n   *    to ssSetInputPortWidth or ssSetOutputPortWidth.\n   */\n  static void mdlSetInputPortWidth(SimStruct *S, int portIndex, int width)\n  {\n  } /* end mdlSetInputPortWidth */\n#endif /* MDL_SET_INPUT_PORT_WIDTH */\n\n\n#define MDL_SET_OUTPUT_PORT_WIDTH   /* Change to #undef to remove function */\n#if defined(MDL_SET_OUTPUT_PORT_WIDTH) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetOutputPortWidth ==========================================\n   * Abstract:\n   *    This method is called with the candidate width for a dynamically\n   *    sized port.  If the proposed width is acceptable, the method should\n   *    go ahead and set the actual port width using ssSetOutputPortWidth.  If\n   *    the size is unacceptable an error should generated via\n   *    ssSetErrorStatus.  Note that any other dynamically sized input or\n   *    output ports whose widths are implicitly defined by virtue of knowing\n   *    the width of the given port can also have their widths set via calls\n   *    to ssSetInputPortWidth or ssSetOutputPortWidth.\n   */\n  static void mdlSetOutputPortWidth(SimStruct *S, int portIndex, int width)\n  {\n  } /* end mdlSetOutputPortWidth */\n#endif /* MDL_SET_OUTPUT_PORT_WIDTH */\n\n\n#undef MDL_SET_INPUT_PORT_DIMENSION_INFO /* Change to #define to add function */\n#if defined(MDL_SET_INPUT_PORT_DIMENSION_INFO) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetInputPortDimensionInfo ====================================\n   * Abstract:\n   *    This method is called with the candidate dimensions for an input port\n   *    with unknown dimensions. If the proposed dimensions are acceptable, the \n   *    method should go ahead and set the actual port dimensions.  \n   *    If they are unacceptable an error should be generated via \n   *    ssSetErrorStatus.  \n   *    Note that any other input or output ports whose dimensions are  \n   *    implicitly defined by virtue of knowing the dimensions of the given \n   *    port can also have their dimensions set.\n   *\n   *    See matlabroot/simulink/src/sfun_matadd.c for an example. \n   */\n  static void mdlSetInputPortDimensionInfo(SimStruct        *S,         \n                                           int_T            portIndex,\n                                           const DimsInfo_T *dimsInfo)\n  {\n  } /* mdlSetInputPortDimensionInfo */\n#endif /* MDL_SET_INPUT_PORT_DIMENSION_INFO */\n\n\n#undef MDL_SET_OUTPUT_PORT_DIMENSION_INFO /* Change to #define to add function*/\n#if defined(MDL_SET_OUTPUT_PORT_DIMENSION_INFO) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetOutputPortDimensionInfo ===================================\n   * Abstract:\n   *    This method is called with the candidate dimensions for an output port \n   *    with unknown dimensions. If the proposed dimensions are acceptable, the \n   *    method should go ahead and set the actual port dimensions.  \n   *    If they are unacceptable an error should be generated via \n   *    ssSetErrorStatus.  \n   *    Note that any other input or output ports whose dimensions are  \n   *    implicitly defined by virtue of knowing the dimensions of the given \n   *    port can also have their dimensions set.\n   *\n   *    See matlabroot/simulink/src/sfun_matadd.c for an example. \n   */\n  static void mdlSetOutputPortDimensionInfo(SimStruct        *S,        \n                                            int_T            portIndex,\n                                            const DimsInfo_T *dimsInfo)\n  {\n  } /* mdlSetOutputPortDimensionInfo */\n#endif /* MDL_SET_OUTPUT_PORT_DIMENSION_INFO */\n\n\n#undef MDL_SET_DEFAULT_PORT_DIMENSION_INFO /* Change to #define to add fcn */\n#if defined(MDL_SET_DEFAULT_PORT_DIMENSION_INFO) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetDefaultPortDimensionInfo ==================================\n   * Abstract:\n   *    This method is called when there is not enough information in your\n   *    model to uniquely determine the port dimensionality of signals\n   *    entering or leaving your block. When this occurs, Simulink's\n   *    dimension propagation engine calls this method to ask you to set\n   *    your S-functions default dimensions for any input and output ports\n   *    that are dynamically sized.\n   *\n   *    If you do not provide this method and you have dynamically sized ports\n   *    where Simulink does not have enough information to propagate the\n   *    dimensionality to your S-function, then Simulink will set these unknown\n   *    ports to the 'block width' which is determined by examining any known\n   *    ports. If there are no known ports, the width will be set to 1.\n   *\n   *    See matlabroot/simulink/src/sfun_matadd.c for an example. \n   */\n  static void mdlSetDefaultPortDimensionInfo(SimStruct *S)\n  {\n  } /* mdlSetDefaultPortDimensionInfo */\n#endif /* MDL_SET_DEFAULT_PORT_DIMENSION_INFO */\n\n\n#define MDL_SET_INPUT_PORT_SAMPLE_TIME\n#if defined(MDL_SET_INPUT_PORT_SAMPLE_TIME) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetInputPortSampleTime =======================================\n   * Abstract:\n   *    This method is called with the candidate sample time for an inherited\n   *    sample time input port. If the proposed sample time is acceptable, the\n   *    method should go ahead and set the actual port sample time using\n   *    ssSetInputPortSampleTime.  If the sample time is unacceptable an error\n   *    should generated via ssSetErrorStatus.  Note that any other inherited\n   *    input or output ports whose sample times are implicitly defined by\n   *    virtue of knowing the sample time of the given port can also have\n   *    their sample times set via calls to ssSetInputPortSampleTime or\n   *    ssSetOutputPortSampleTime.\n   *\n   *    When inherited port based sample times are specified, we are guaranteed\n   *    that the sample time will be one of the following:\n   *                    [sampleTime, offsetTime]\n   *       continuous   [0.0       , 0.0       ]\n   *       discrete     [period    , offset    ]  where 0.0 < period < inf\n   *                                                    0.0 <= offset < period\n   *    Constant, triggered, and variable step sample times will not be\n   *    propagated to S-functions with port based sample times.\n   *\n   *    Generally the mdlSetInputPortSampleTime or mdlSetOutputPortSampleTime\n   *    is called once with the input port sample time. However, there can be\n   *    cases where this function will be called more than once. This happens \n   *    when the simulation engine is converting continuous sample times to \n   *    continuous but fixed in minor steps sample times. When this occurs, the\n   *    original values of the sample times specified in mdlInitializeSizes \n   *    will be restored before calling this method again. \n   *\n   *    The final sample time specified at the port may be different (but\n   *    equivalent to) from what was specified in this method. This occurs\n   *    when:\n   *      o) Using a fixed step solver and the port has a continuous but fixed\n   *         in minor step sample time. In this case the sample time will\n   *         be converted to the fundamental sample time for the model.\n   *      o) We are adjusting sample times for numerical correctness. For \n   *         example [0.2499999999999, 0] is converted to [0.25, 0].\n   *    S-functions are not explicitly notified of \"converted\" sample times.\n   *    They can examine the final sample times in mdlInitializeSampleTimes.\n   */\n  static void mdlSetInputPortSampleTime(SimStruct *S,\n                                        int_T     portIdx,\n                                        real_T    sampleTime,\n                                        real_T    offsetTime)\n  {\n  } /* end mdlSetInputPortSampleTime */\n#endif /* MDL_SET_INPUT_PORT_SAMPLE_TIME */\n\n\n#define MDL_SET_OUTPUT_PORT_SAMPLE_TIME\n#if defined(MDL_SET_OUTPUT_PORT_SAMPLE_TIME) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetOutputPortSampleTime ======================================\n   * Abstract:\n   *    This method is called with the candidate sample time for an inherited\n   *    sample time output port. If the proposed sample time is acceptable, the\n   *    method should go ahead and set the actual port sample time using\n   *    ssSetOutputPortSampleTime.  If the sample time is unacceptable an error\n   *    should generated via ssSetErrorStatus.  Note that any other inherited\n   *    input or output ports whose sample times are implicitly defined by\n   *    virtue of knowing the sample time of the given port can also have\n   *    their sample times set via calls to ssSetInputPortSampleTime or\n   *    ssSetOutputPortSampleTime.\n   *\n   *    Normally, sample times are propagated forwards, however if sources\n   *    feeding this block have an inherited sample time, then Simulink\n   *    may choose to back propagate known sample times to this block.\n   *    When back propagating sample times, we call this method in succession\n   *    for all inherited output port signals.\n   *\n   *    See mdlSetInputPortSampleTimes for more information about when this\n   *    method is called.\n   */\n  static void mdlSetOutputPortSampleTime(SimStruct *S,\n                                         int_T     portIdx,\n                                         real_T    sampleTime,\n                                         real_T    offsetTime)\n  {\n  } /* end mdlSetOutputPortSampleTime */\n#endif /* MDL_SET_OUTPUT_PORT_SAMPLE_TIME */\n\n\n/* Function: mdlInitializeSampleTimes =========================================\n * Abstract:\n *\n *    This function is used to specify the sample time(s) for your S-function.\n *    You must register the same number of sample times as specified in\n *    ssSetNumSampleTimes. If you specify that you have no sample times, then\n *    the S-function is assumed to have one inherited sample time.\n *\n *    The sample times are specified as pairs \"[sample_time, offset_time]\"\n *    via the following macros:\n *      ssSetSampleTime(S, sampleTimePairIndex, sample_time)\n *      ssSetOffsetTime(S, offsetTimePairIndex, offset_time)\n *    Where sampleTimePairIndex starts at 0.\n *\n *    The valid sample time pairs are (upper case values are macros defined\n *    in simstruc.h):\n *\n *      [CONTINUOUS_SAMPLE_TIME,  0.0                       ]\n *      [CONTINUOUS_SAMPLE_TIME,  FIXED_IN_MINOR_STEP_OFFSET]\n *      [discrete_sample_period,  offset                    ]\n *      [VARIABLE_SAMPLE_TIME  ,  0.0                       ]\n *\n *    Alternatively, you can specify that the sample time is inherited from the\n *    driving block in which case the S-function can have only one sample time\n *    pair:\n *\n *      [INHERITED_SAMPLE_TIME,  0.0                       ]\n *    or\n *      [INHERITED_SAMPLE_TIME,  FIXED_IN_MINOR_STEP_OFFSET]\n *\n *    The following guidelines may help aid in specifying sample times:\n *\n *      o A continuous function that changes during minor integration steps\n *        should register the [CONTINUOUS_SAMPLE_TIME, 0.0] sample time.\n *      o A continuous function that does not change during minor integration\n *        steps should register the\n *              [CONTINUOUS_SAMPLE_TIME, FIXED_IN_MINOR_STEP_OFFSET]\n *        sample time.\n *      o A discrete function that changes at a specified rate should register\n *        the discrete sample time pair\n *              [discrete_sample_period, offset]\n *        where\n *              discrete_sample_period > 0.0 and\n *              0.0 <= offset < discrete_sample_period\n *      o A discrete function that changes at a variable rate should\n *        register the variable step discrete [VARIABLE_SAMPLE_TIME, 0.0]\n *        sample time. The mdlGetTimeOfNextVarHit function is called to get\n *        the time of the next sample hit for the variable step discrete task.\n *        Note, the VARIABLE_SAMPLE_TIME can be used with variable step\n *        solvers only.\n *      o Discrete blocks which can operate in triggered subsystems.  For your \n *        block to operate correctly in a triggered subsystem or a periodic \n *        system it must register [INHERITED_SAMPLE_TIME, 0.0]. In a triggered\n *        subsystem after sample times have been propagated throughout the\n *        block diagram, the assigned sample time to the block will be \n *        [INHERITED_SAMPLE_TIME, INHERITED_SAMPLE_TIME]. Typically discrete\n *        blocks which can be periodic or reside within triggered subsystems\n *        need to register the inherited sample time and the option\n *        SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME. Then in mdlSetWorkWidths, they\n *        need to verify that they were assigned a discrete or triggered\n *        sample time. To do this:\n *          mdlSetWorkWidths:\n *            if (ssGetSampleTime(S, 0) == CONTINUOUS_SAMPLE_TIME) {\n *              ssSetErrorStatus(S, \"This block cannot be assigned a \"\n *                               \"continuous sample time\");\n *            }\n *\n *    If your function has no intrinsic sample time, then you should indicate\n *    that your sample time is inherited according to the following guidelines:\n *\n *      o A function that changes as its input changes, even during minor\n *        integration steps should register the [INHERITED_SAMPLE_TIME, 0.0]\n *        sample time.\n *      o A function that changes as its input changes, but doesn't change\n *        during minor integration steps (i.e., held during minor steps) should\n *        register the [INHERITED_SAMPLE_TIME, FIXED_IN_MINOR_STEP_OFFSET]\n *        sample time.\n *\n *    To check for a sample hit during execution (in mdlOutputs or mdlUpdate),\n *    you should use the ssIsSampleHit or ssIsContinuousTask macros.\n *    For example, if your first sample time is continuous, then you\n *    used the following code-fragment to check for a sample hit. Note,\n *    you would get incorrect results if you used ssIsSampleHit(S,0,tid).\n *        if (ssIsContinuousTask(S,tid)) {\n *        }\n *    If say, you wanted to determine if the third (discrete) task has a hit,\n *    then you would use the following code-fragment:\n *        if (ssIsSampleHit(S,2,tid) {\n *        }\n *\n */\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{\n    /* Register one pair for each sample time */\n    ssSetSampleTime(S, 0, CONTINUOUS_SAMPLE_TIME);\n    ssSetOffsetTime(S, 0, 0.0);\n\n} /* end mdlInitializeSampleTimes */\n\n\n#define MDL_SET_INPUT_PORT_DATA_TYPE   /* Change to #undef to remove function */\n#if defined(MDL_SET_INPUT_PORT_DATA_TYPE) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetInputPortDataType =========================================\n   * Abstract:\n   *    This method is called with the candidate data type id for a dynamically\n   *    typed input port.  If the proposed data type is acceptable, the method\n   *    should go ahead and set the actual port data type using\n   *    ssSetInputPortDataType.  If the data type is unacceptable an error\n   *    should generated via ssSetErrorStatus.  Note that any other dynamically\n   *    typed input or output ports whose data types are implicitly defined by\n   *    virtue of knowing the data type of the given port can also have their\n   *    data types set via calls to ssSetInputPortDataType or \n   *    ssSetOutputPortDataType.  \n   *\n   *    See matlabroot/simulink/include/simstruc_types.h for built-in\n   *    type defines: SS_DOUBLE, SS_BOOLEAN, etc.\n   *\n   *    See matlabroot/simulink/src/sfun_dtype_io.c for an example. \n   */\n  static void mdlSetInputPortDataType(SimStruct *S, int portIndex,DTypeId dType)\n  {\n  } /* mdlSetInputPortDataType */\n#endif /* MDL_SET_INPUT_PORT_DATA_TYPE */\n\n\n#define MDL_SET_OUTPUT_PORT_DATA_TYPE  /* Change to #undef to remove function */\n#if defined(MDL_SET_OUTPUT_PORT_DATA_TYPE) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetOutputPortDataType ========================================\n   * Abstract:\n   *    This method is called with the candidate data type id for a dynamically\n   *    typed output port.  If the proposed data type is acceptable, the method\n   *    should go ahead and set the actual port data type using\n   *    ssSetOutputPortDataType.  If the data type is unacceptable an error\n   *    should generated via ssSetErrorStatus.  Note that any other dynamically\n   *    typed input or output ports whose data types are implicitly defined by\n   *    virtue of knowing the data type of the given port can also have their\n   *    data types set via calls to ssSetInputPortDataType or \n   *    ssSetOutputPortDataType.  \n   *\n   *    See matlabroot/simulink/src/sfun_dtype_io.c for an example. \n   */\n  static void mdlSetOutputPortDataType(SimStruct *S,int portIndex,DTypeId dType)\n  {\n  } /* mdlSetOutputPortDataType */\n#endif /* MDL_SET_OUTPUT_PORT_DATA_TYPE */\n\n\n#define MDL_SET_DEFAULT_PORT_DATA_TYPES /* Change to #undef to remove function*/\n#if defined(MDL_SET_DEFAULT_PORT_DATA_TYPES) && defined(MATLAB_MEX_FILE)\n  /* Function:  mdlSetDefaultPortDataTypes =====================================\n   * Abstract:\n   *    This method is called when there is not enough information in your\n   *    model to uniquely determine the input and output data types\n   *    for your block. When this occurs, Simulink's data type propagation \n   *    engine calls this method to ask you to set your S-function default \n   *    data type for any dynamically typed input and output ports.\n   *\n   *    If you do not provide this method and you have dynamically typed\n   *    ports where Simulink does not have enough information to propagate\n   *    data types to your S-function, then Simulink will assign the\n   *    data type to the largest known port data type of your S-function.\n   *    If there are no known data types, then Simulink will set the\n   *    data type to double.\n   *\n   *    See matlabroot/simulink/src/sfun_dtype_io.c for an example. \n   */\n  static void mdlSetDefaultPortDataTypes(SimStruct *S)\n  {\n  } /* mdlSetDefaultPortDataTypes */\n#endif /* MDL_SET_DEFAULT_PORT_DATA_TYPES */\n\n\n#define MDL_SET_INPUT_PORT_COMPLEX_SIGNAL   /* Change to #undef to remove */\n#if defined(MDL_SET_INPUT_PORT_COMPLEX_SIGNAL) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetInputPortComplexSignal ====================================\n   * Abstract:\n   *    This method is called with the candidate complexity signal setting\n   *    (COMPLEX_YES or COMPLEX_NO) for an input port whos complex signal\n   *    attribute is set to COMPLEX_INHERITED. If the proposed complexity is\n   *    acceptable, the method should go ahead and set the actual complexity\n   *    using ssSetInputPortComplexSignal. If the complex setting is\n   *    unacceptable an error should generated via ssSetErrorStatus.  Note that\n   *    any other unknown ports whose complexity is implicitly defined by virtue\n   *    of knowing the complexity of the given port can also have their\n   *    complexity set via calls to ssSetInputPortComplexSignal or\n   *    ssSetOutputPortComplexSignal.  \n   *\n   *    See matlabroot/simulink/src/sfun_cplx.c for an example. \n   */\n  static void mdlSetInputPortComplexSignal(SimStruct *S, \n                                           int       portIndex, \n                                           CSignal_T cSignalSetting)\n  {\n  } /* mdlSetInputPortComplexSignal */\n#endif /* MDL_SET_INPUT_PORT_COMPLEX_SIGNAL */\n\n\n#define MDL_SET_OUTPUT_PORT_COMPLEX_SIGNAL  /* Change to #undef to remove */\n#if defined(MDL_SET_OUTPUT_PORT_COMPLEX_SIGNAL) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetOutputPortComplexSignal ===================================\n   * Abstract:\n   *    This method is called with the candidate complexity signal setting\n   *    (COMPLEX_YES or COMPLEX_NO) for an output port whos complex signal\n   *    attribute is set to COMPLEX_INHERITED. If the proposed complexity is\n   *    acceptable, the method should go ahead and set the actual complexity\n   *    using ssSetOutputPortComplexSignal. If the complex setting is\n   *    unacceptable an error should generated via ssSetErrorStatus.  Note that\n   *    any other unknown ports whose complexity is implicitly defined by virtue\n   *    of knowing the complexity of the given port can also have their\n   *    complexity set via calls to ssSetInputPortComplexSignal or\n   *    ssSetOutputPortComplexSignal.  \n   *\n   *    See matlabroot/simulink/src/sfun_cplx.c for an example. \n   */\n  static void mdlSetOutputPortComplexSignal(SimStruct *S, \n                                            int       portIndex, \n                                            CSignal_T cSignalSetting)\n  {\n  } /* mdlSetOutputPortComplexSignal */\n#endif /* MDL_SET_OUTPUT_PORT_COMPLEX_SIGNAL */\n\n\n#define MDL_SET_DEFAULT_PORT_COMPLEX_SIGNALS /* Change to #undef to remove */\n#if defined(MDL_SET_DEFAULT_PORT_COMPLEX_SIGNALS) && defined(MATLAB_MEX_FILE)\n  /* Function:  mdlSetDefaultPortComplexSignals ================================\n   * Abstract:\n   *    This method is called when there is not enough information in your\n   *    model to uniquely determine the complexity (COMPLEX_NO, COMPLEX_YES) \n   *    of signals entering your block. When this occurs, Simulink's \n   *    complex signal propagation engine calls this method to ask you to set\n   *    your S-function default complexity type for any input and output ports\n   *    who's complex signal attribute is set to COMPLEX_INHERITED.\n   *\n   *    If you do not provide this method and you have COMPLEX_INHERITED\n   *    ports where Simulink does not have enough information to propagate\n   *    the complexity to your S-function, then Simulink will set\n   *    these unknown ports to COMPLEX_YES if any of your S-function\n   *    ports are currently set to COMPLEX_YES, otherwise the unknown\n   *    ports will be set to COMPLEX_NO.\n   *\n   *    See matlabroot/simulink/src/sfun_cplx.c for an example. \n   */\n  static void mdlSetDefaultPortComplexSignals(SimStruct *S)\n  {\n  } /* mdlSetDefaultPortComplexSignals */\n#endif /* MDL_SET_DEFAULT_PORT_COMPLEX_SIGNALS */\n\n\n#define MDL_SET_WORK_WIDTHS   /* Change to #undef to remove function */\n#if defined(MDL_SET_WORK_WIDTHS) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlSetWorkWidths ===============================================\n   * Abstract:\n   *      The optional method, mdlSetWorkWidths is called after input port\n   *      width, output port width, and sample times of the S-function have\n   *      been determined to set any state and work vector sizes which are\n   *      a function of the input, output, and/or sample times. This method\n   *      is used to specify the nonzero work vector widths via the macros\n   *      ssNumContStates, ssSetNumDiscStates, ssSetNumRWork, ssSetNumIWork,\n   *      ssSetNumPWork, ssSetNumModes, and ssSetNumNonsampledZCs.\n   *\n   *      Run-time parameters are registered in this method using methods \n   *      ssSetNumRunTimeParams, ssSetRunTimeParamInfo, and related methods.\n   *\n   *      If you are using mdlSetWorkWidths, then any work vectors you are\n   *      using in your S-function should be set to DYNAMICALLY_SIZED in\n   *      mdlInitializeSizes, even if the exact value is known at that point.\n   *      The actual size to be used by the S-function should then be specified\n   *      in mdlSetWorkWidths.\n   */\n  static void mdlSetWorkWidths(SimStruct *S)\n  {\n  }\n#endif /* MDL_SET_WORK_WIDTHS */\n\n\n#define MDL_INITIALIZE_CONDITIONS   /* Change to #undef to remove function */\n#if defined(MDL_INITIALIZE_CONDITIONS)\n  /* Function: mdlInitializeConditions ========================================\n   * Abstract:\n   *    In this function, you should initialize the continuous and discrete\n   *    states for your S-function block.  The initial states are placed\n   *    in the state vector, ssGetContStates(S) or ssGetDiscStates(S).\n   *    You can also perform any other initialization activities that your\n   *    S-function may require. Note, this method will be called at the\n   *    start of simulation and if it is present in an enabled subsystem\n   *    configured to reset states, it will be call when the enabled subsystem\n   *    restarts execution to reset the states.\n   *\n   *    You can use the ssIsFirstInitCond(S) macro to determine if this is\n   *    is the first time mdlInitializeConditions is being called.\n   */\n  static void mdlInitializeConditions(SimStruct *S)\n  {\n  }\n#endif /* MDL_INITIALIZE_CONDITIONS */\n\n\n#define MDL_START  /* Change to #undef to remove function */\n#if defined(MDL_START)\n  /* Function: mdlStart =======================================================\n   * Abstract:\n   *    This function is called once at start of model execution. If you\n   *    have states that should be initialized once, this is the place\n   *    to do it.\n   */\n  static void mdlStart(SimStruct *S)\n  {\n  }\n#endif /*  MDL_START */\n\n\n/* Define to indicate that this S-Function has the mdlG[S]etOperatingPoint methods */\n#define MDL_OPERATING_POINT /* Change to #undef to remove this function */\n#if defined(MDL_OPERATING_POINT)\n  /* Function: mdlGetOperatingPoint ===========================================\n   * Abstract:\n   *\n   *    Package the complete operating point of this block (i.e. the snapshot of this block's\n   *    simulation runtime data, which includes all the run-time data that can change *after*\n   *    mdlStart) as a MATLAB data structure and return it.\n   */\n  static mxArray* mdlGetOperatingPoint(SimStruct* S)\n  {\n  }\n\n  /* Function: mdlSetOperatingPoint ===========================================\n   * Abstract:\n   *\n   *    Unpack 'inputOperatingPoint' - the MATLAB data structure which contains the complete\n   *    simulation runtime data snapshot of this block (this includes all the run-time data that can\n   *    change *after* mdlStart) into the appropriate locations. inputOperatingPoint was created by\n   *    the function mdlGetOperatingPoint of this block\n   */\n  static void mdlSetOperatingPoint(SimStruct* S, const mxArray* inputOperatingPoint)\n  {\n  }\n#endif /* MDL_OPERATING_POINT */\n\n\n#define MDL_GET_TIME_OF_NEXT_VAR_HIT  /* Change to #undef to remove function */\n#if defined(MDL_GET_TIME_OF_NEXT_VAR_HIT) && (defined(MATLAB_MEX_FILE) || \\\n                                              defined(NRT))\n  /* Function: mdlGetTimeOfNextVarHit =========================================\n   * Abstract:\n   *    This function is called to get the time of the next variable sample\n   *    time hit. This function is called once for every major integration time\n   *    step. It must return time of next hit by using ssSetTNext. The time of\n   *    the next hit must be greater than ssGetT(S).\n   *\n   *    Note, the time of next hit can be a function of the input signal(s).\n   */\n\n  static void mdlGetTimeOfNextVarHit(SimStruct *S)\n  {\n      time_T timeOfNextHit = ssGetT(S) /* + offset */ ;\n      ssSetTNext(S, timeOfNextHit);\n  }\n#endif /* MDL_GET_TIME_OF_NEXT_VAR_HIT */\n\n\n#define MDL_ZERO_CROSSINGS   /* Change to #undef to remove function */\n#if defined(MDL_ZERO_CROSSINGS) && (defined(MATLAB_MEX_FILE) || defined(NRT))\n  /* Function: mdlZeroCrossings ===============================================\n   * Abstract:\n   *    If your S-function has registered CONTINUOUS_SAMPLE_TIME and there\n   *    are signals entering the S-function or internally generated signals\n   *    which have discontinuities, you can use this method to locate the\n   *    discontinuities. When called, this method must update the\n   *    ssGetNonsampleZCs(S) vector.\n   */\n  static void mdlZeroCrossings(SimStruct *S)\n  {\n  }\n#endif /* MDL_ZERO_CROSSINGS */\n\n\n/* Function: mdlOutputs =======================================================\n * Abstract:\n *    In this function, you compute the outputs of your S-function\n *    block. Generally outputs are placed in the output vector(s),\n *    ssGetOutputPortSignal.\n */\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n} /* end mdlOutputs */\n\n\n#define MDL_UPDATE  /* Change to #undef to remove function */\n#if defined(MDL_UPDATE)\n  /* Function: mdlUpdate ======================================================\n   * Abstract:\n   *    This function is called once for every major integration time step.\n   *    Discrete states are typically updated here, but this function is useful\n   *    for performing any tasks that should only take place once per\n   *    integration step.\n   */\n  static void mdlUpdate(SimStruct *S, int_T tid)\n  {\n  }\n#endif /* MDL_UPDATE */\n\n\n#define MDL_DERIVATIVES  /* Change to #undef to remove function */\n#if defined(MDL_DERIVATIVES)\n  /* Function: mdlDerivatives =================================================\n   * Abstract:\n   *    In this function, you compute the S-function block's derivatives.\n   *    The derivatives are placed in the derivative vector, ssGetdX(S).\n   */\n  static void mdlDerivatives(SimStruct *S)\n  {\n  }\n#endif /* MDL_DERIVATIVES */\n\n\n/* Function: mdlTerminate =====================================================\n * Abstract:\n *    In this function, you should perform any actions that are necessary\n *    at the termination of a simulation.  For example, if memory was allocated\n *    in mdlStart, this is the place to free it.\n *\n *    Suppose your S-function allocates a few chunks of memory in mdlStart\n *    and saves them in PWork. The following code fragment would free this\n *    memory.\n *        {\n *            int i;\n *            for (i = 0; i<ssGetNumPWork(S); i++) {\n *                if (ssGetPWorkValue(S,i) != NULL) {\n *                    free(ssGetPWorkValue(S,i));\n *                }\n *            }\n *        }\n */\nstatic void mdlTerminate(SimStruct *S)\n{\n}\n\n\n#define MDL_RTW  /* Change to #undef to remove function */\n#if defined(MDL_RTW) && defined(MATLAB_MEX_FILE)\n  /* Function: mdlRTW =========================================================\n   * Abstract:\n   *\n   *    This function is called when the Simulink Coder is generating\n   *    the model.rtw file. In this method, you can call the following\n   *    functions which add fields to the model.rtw file.\n   *\n   *    1) The following creates Parameter records for your S-functions.\n   *       nParams is the number of tunable S-function parameters.\n   *\n   *       if ( !ssWriteRTWParameters(S, nParams,\n   *\n   *                                  SSWRITE_VALUE_[type],paramName,stringInfo,\n   *                                  [type specific arguments below]\n   *\n   *                                 ) ) {\n   *           return; (error reporting will be handled by SL)\n   *       }\n   *\n   *       Where SSWRITE_VALUE_[type] can be one of the following groupings\n   *       (and you must have \"nParams\" such groupings):\n   *\n   *         SSWRITE_VALUE_VECT,\n   *           const char_T *paramName,\n   *           const char_T *stringInfo,\n   *           const real_T *valueVect,\n   *           int_T        vectLen\n   *\n   *         SSWRITE_VALUE_2DMAT,\n   *           const char_T *paramName,\n   *           const char_T *stringInfo,\n   *           const real_T *valueMat,\n   *           int_T        nRows,\n   *           int_T        nCols\n   *\n   *         SSWRITE_VALUE_DTYPE_VECT,\n   *           const char_T   *paramName,\n   *           const char_T   *stringInfo,\n   *           const void     *valueVect,\n   *           int_T          vectLen,\n   *           int_T          dtInfo\n   *\n   *         SSWRITE_VALUE_DTYPE_2DMAT,\n   *           const char_T   *paramName,\n   *           const char_T   *stringInfo,\n   *           const void     *valueMat,\n   *           int_T          nRows,\n   *           int_T          nCols,\n   *           int_T          dtInfo\n   *\n   *         SSWRITE_VALUE_DTYPE_ML_VECT,\n   *           const char_T   *paramName,\n   *           const char_T   *stringInfo,\n   *           const void     *rValueVect,\n   *           const void     *iValueVect,\n   *           int_T          vectLen,\n   *           int_T          dtInfo\n   *\n   *         SSWRITE_VALUE_DTYPE_ML_2DMAT,\n   *           const char_T   *paramName,\n   *           const char_T   *stringInfo,\n   *           const void     *rValueMat,\n   *           const void     *iValueMat,\n   *           int_T          nRows,\n   *           int_T          nCols,\n   *           int_T          dtInfo\n   *\n   *       Notes:\n   *       1. nParams is an integer and stringInfo is a string describing\n   *          general information about the parameter such as how it was derived.\n   *       2. The last argument to this function, dtInfo, is obtained from the\n   *          DTINFO macro (defined in simstruc.h) as:\n   *                 dtInfo = DTINFO(dataTypeId, isComplexSignal);\n   *          where dataTypeId is the data type id and isComplexSignal is a\n   *          boolean value specifying whether the parameter is complex.\n   *\n   *       See simulink/include/simulink.c for the definition (implementation)\n   *       of this function and simulink/src/sfun_multiport.c for an example\n   *       of using this function.\n   *\n   *    2) The following creates SFcnParameterSetting record for S-functions\n   *       (these can be derived from the non-tunable S-function parameters).\n   *\n   *       if ( !ssWriteRTWParamSettings(S, nParamSettings,\n   *\n   *                                     SSWRITE_VALUE_[whatever], settingName,\n   *                                     [type specific arguments below]\n   *\n   *                                    ) ) {\n   *           return; (error reporting will be handled by SL)\n   *       }\n   *\n   *       Where SSWRITE_VALUE_[type] can be one of the following groupings\n   *       (and you must have \"nParamSettings\" such groupings):\n   *       Also, the examples in the right hand column below show how the\n   *       ParamSetting appears in the .rtw file\n   *\n   *         SSWRITE_VALUE_STR,              - Used to write (un)quoted strings\n   *           const char_T *settingName,      example:\n   *           const char_T *value,              Country      USA\n   *\n   *         SSWRITE_VALUE_QSTR,             - Used to write quoted strings\n   *           const char_T *settingName,      example:\n   *           const char_T *value,              Country      \"U.S.A\"\n   *\n   *         SSWRITE_VALUE_VECT_STR,         - Used to write vector of strings\n   *           const char_T *settingName,      example:\n   *           const char_T *value,              Countries    [\"USA\", \"Mexico\"]\n   *           int_T        nItemsInVect\n   *\n   *         SSWRITE_VALUE_NUM,              - Used to write numbers\n   *           const char_T *settingName,      example:\n   *           const real_T value                 NumCountries  2\n   *\n   *\n   *         SSWRITE_VALUE_VECT,             - Used to write numeric vectors\n   *           const char_T *settingName,      example:\n   *           const real_T *settingValue,       PopInMil        [300, 100]\n   *           int_T        vectLen\n   *\n   *         SSWRITE_VALUE_2DMAT,            - Used to write 2D matrices\n   *           const char_T *settingName,      example:\n   *           const real_T *settingValue,       PopInMilBySex  Matrix(2,2)\n   *           int_T        nRows,                   [[170, 130],[60, 40]]\n   *           int_T        nCols\n   *\n   *         SSWRITE_VALUE_DTYPE_NUM,        - Used to write numeric vectors\n   *           const char_T   *settingName,    example: int8 Num 3+4i\n   *           const void     *settingValue,   written as: [3+4i]\n   *           int_T          dtInfo\n   *\n   *\n   *         SSWRITE_VALUE_DTYPE_VECT,       - Used to write data typed vectors\n   *           const char_T   *settingName,    example: int8 CArray [1+2i 3+4i]\n   *           const void     *settingValue,   written as:\n   *           int_T          vectLen             CArray  [1+2i, 3+4i]\n   *           int_T          dtInfo\n   *\n   *\n   *         SSWRITE_VALUE_DTYPE_2DMAT,      - Used to write data typed 2D\n   *           const char_T   *settingName     matrices\n   *           const void     *settingValue,   example:\n   *           int_T          nRow ,            int8 CMatrix  [1+2i 3+4i; 5 6]\n   *           int_T          nCols,            written as:\n   *           int_T          dtInfo               CMatrix         Matrix(2,2)\n   *                                                [[1+2i, 3+4i]; [5+0i, 6+0i]]\n   *\n   *\n   *         SSWRITE_VALUE_DTYPE_ML_VECT,    - Used to write complex matlab data\n   *           const char_T   *settingName,    typed vectors example:\n   *           const void     *settingRValue,  example: int8 CArray [1+2i 3+4i]\n   *           const void     *settingIValue,      settingRValue: [1 3]\n   *           int_T          vectLen              settingIValue: [2 4]\n   *           int_T          dtInfo\n   *                                             written as:\n   *                                                CArray    [1+2i, 3+4i]\n   *\n   *         SSWRITE_VALUE_DTYPE_ML_2DMAT,   - Used to write matlab complex\n   *           const char_T   *settingName,    data typed 2D matrices\n   *           const void     *settingRValue,  example\n   *           const void     *settingIValue,      int8 CMatrix [1+2i 3+4i; 5 6]\n   *           int_T          nRows                settingRValue: [1 5 3 6]\n   *           int_T          nCols,               settingIValue: [2 0 4 0]\n   *           int_T          dtInfo\n   *                                              written as:\n   *                                              CMatrix         Matrix(2,2)\n   *                                                [[1+2i, 3+4i]; [5+0i, 6+0i]]\n   *\n   *       Note, The examples above show how the ParamSetting is written out\n   *       to the .rtw file\n   *\n   *       See simulink/include/simulink.c for the definition (implementation)\n   *       of this function and simulink/src/sfun_multiport.c for an example\n   *       of using this function.\n   *\n   *    3) The following creates the work vector records for S-functions\n   *\n   *       if (!ssWriteRTWWorkVect(S, vectName, nNames,\n   *\n   *                            name, size,   (must have nNames of these pairs)\n   *                                 :\n   *                           ) ) {\n   *           return;  (error reporting will be handled by SL)\n   *       }\n   *\n   *       Notes:\n   *         a) vectName must be either \"RWork\", \"IWork\" or \"PWork\"\n   *         b) nNames is an int_T (integer), name is a const char_T* (const\n   *            char pointer) and size is int_T, and there must be nNames number\n   *            of [name, size] pairs passed to the function.\n   *         b) intSize1+intSize2+ ... +intSizeN = ssGetNum<vectName>(S)\n   *            Recall that you would have to set ssSetNum<vectName>(S)\n   *            in one of the initialization functions (mdlInitializeSizes\n   *            or mdlSetWorkVectorWidths).\n   *\n   *       See simulink/include/simulink.c for the definition (implementation)\n   *       of this function, and ... no example yet :(\n   *\n   *    4) Finally the following functions/macros give you the ability to write\n   *       arbitrary strings and [name, value] pairs directly into the .rtw\n   *       file.\n   *\n   *       if (!ssWriteRTWStr(S, const_char_*_string)) {\n   *          return;\n   *       }\n   *\n   *       if (!ssWriteRTWStrParam(S, const_char_*_name, const_char_*_value)) {\n   *          return;\n   *       }\n   *\n   *       if (!ssWriteRTWScalarParam(S, const_char_*_name, \n   *                                  const_void_*_value,\n   *                                  DTypeId_dtypeId)) {\n   *          return;\n   *       }\n   *\n   *       if (!ssWriteRTWStrVectParam(S, const_char_*_name,\n   *                                   const_char_*_value,\n   *                                   int_num_items)) {\n   *          return;\n   *       }\n   *\n   *       if (!ssWriteRTWVectParam(S, const_char_*_name, const_void_*_value,\n   *                                int_data_type_of_value, int_vect_len)){\n   *          return;\n   *       }\n   *\n   *       if (!ssWriteRTW2dMatParam(S, const_char_*_name, const_void_*_value,\n   *                        int_data_type_of_value, int_nrows, int_ncols)){\n   *          return;\n   *       }\n   *\n   *       The 'data_type_of_value' input argument for the above two macros is\n   *       obtained using\n   *          DTINFO(dTypeId, isComplex),\n   *       where\n   *          dTypeId: can be any one of the enum values in BuiltInDTypeID\n   *                   (SS_DOUBLE, SS_SINGLE, SS_INT8, SS_UINT8, SS_INT16,\n   *                   SS_UINT16, SS_INT32, SS_UINT32, SS_BOOLEAN defined\n   *                   in simstruc_types.h)\n   *          isComplex: is either 0 or 1, as explained in Note-2 for\n   *                    ssWriteRTWParameters.\n   *\n   *       For example DTINFO(SS_INT32,0) is a non-complex 32-bit signed\n   *       integer.\n   *\n   *       If isComplex==1, then it is assumed that 'const_void_*_value' array\n   *       has the real and imaginary parts arranged in an interleaved manner\n   *       (i.e., Simulink Format).\n   *\n   *       If you prefer to pass the real and imaginary parts as two separate\n   *       arrays, you should use the following macros:\n   *\n   *       if (!ssWriteRTWMxVectParam(S, const_char_*_name,\n   *                                  const_void_*_rvalue, const_void_*_ivalue,\n   *                                  int_data_type_of_value, int_vect_len)){\n   *          return;\n   *       }\n   *\n   *       if (!ssWriteRTWMx2dMatParam(S, const_char_*_name,\n   *                                   const_void_*_rvalue, const_void_*_ivalue,\n   *                                   int_data_type_of_value,\n   *                                   int_nrows, int_ncols)){\n   *          return;\n   *       }\n   *\n   *       See simulink/include/simulink.c and simstruc.h for the definition \n   *       (implementation) of these functions and simulink/src/ml2rtw.c for \n   *       examples of using these functions.\n   *\n   */\n  static void mdlRTW(SimStruct *S)\n  {\n  }\n#endif /* MDL_RTW */\n\n\n/*=============================*\n * Required S-function trailer *\n *=============================*/\n\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n"},{"name":"sfuntmpl_gate_fortran.c","type":"source","group":"other","path":"/Users/jamesbond/Desktop/Vehicle_Speedometer_Module_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n *  File: sfuntmpl_gate_fortran.c\n *\n *  Abstract:: \n *\n *  C->Fortran gateway TEMPLATE for a level 2 S-function.\n *  Copy, rename and then edit this file to call your Fortran\n *  code in the solver mode you want, then build it.\n *\n *  To build the mex file, first compile the Fortran file(s), \n *  then include their object file names in the mex command.  \n *  For example, if your Fortran compiler is invoked with the\n *  'g77' command, a mex session looks like this at the command \n *  prompt:\n *\n *  >> !g77 -c myfortranfile.f\n *  >> mex my_sfuntmpl_gate_fortran.c myfortranfile.o\n *  \n * Copyright 1990-2013 The MathWorks, Inc.\n */\n\n\n/*\n * You must specify the S_FUNCTION_NAME as the name of your S-function\n * (i.e. replace sfungate with the name of your S-function, which has\n * to match the name of the final mex file, e.g., if the S_FUNCTION_NAME\n * is my_sfuntmpl_gate_fortran, the mex filename will have to be \n * my_sfuntmpl_gate_fortran.dll on Windows and \n * my_sfuntmpl_gate_fortran.mexXXX on unix where XXX is the 3 letter \n * mex extension code for your platform).\n */\n\n#define S_FUNCTION_LEVEL 2\n#define S_FUNCTION_NAME  sfuntmpl_gate_fortran\n\n/*\n * Need to include simstruc.h for the definition of the SimStruct and\n * its associated macro definitions.\n */\n#include \"simstruc.h\"\n\n/* \n * As a convenience, this template has options for both variable \n * step and fixed step algorithm support.  If you want fixed step\n * operation, change the #define below to #undef.\n *\n * If you want to, you can delete all references to VARIABLE_STEP \n * and set up the C-MEX as described in the \"Writing S-functions\" \n * manual.\n */\n\n#define VARIABLE_STEP\n\n/* \n * The interface (function prototype) for your  Fortran subroutine.  \n * Change the name to the name of the subroutine and the arguments \n * to the actual argument list.\n *\n * Note that datatype REAL is 32 bits in Fortran and are passed\n * by reference, so the prototype arguments must be 'float *'.\n * INTEGER maps to int, so those arguments are 'int *'. Be\n * wary of IMPLICIT rules in Fortran when datatypes are not\n * explicit in your Fortran code.  To use the datatype double\n * the Fortran variables need to be declared DOUBLE PRECISION\n * either explicitly or via an IMPLICIT DOUBLE PRECISION\n * statement.\n *\n * Your Fortran compiler may decorate and/or change the \n * capitalization of 'SUBROUTINE nameOfSub' differently \n * than the prototype below.  Check your Fortran compiler's \n * manual for options to learn about and possibly control \n * external symbol decoration.  See also the text file named\n * sfuntmpl_fortran.txt in this file's directory.\n *\n * Additionally, you may want to use CFORTRAN, a tool for \n * automating interface generation between C and Fortran.\n * Search the web for 'cfortran'.\n * \n */\n\n#ifdef VARIABLE_STEP\n\nextern void nameofsub_(float *sampleArgs, \n                       float *states, \n                       int   *numstates,\n                       float *sampleOutput);\n#else\n\nextern void nameofsub_(float *sampleArgs, float *sampleOutput);\n\n#endif\n\n\n/* Error handling\n * --------------\n *\n * You should use the following technique to report errors encountered within\n * an S-function:\n *\n *       ssSetErrorStatus(S,\"Error encountered due to ...\");\n *       return;\n *\n * Note that the 2nd argument to ssSetErrorStatus must be persistent memory.\n * It cannot be a local variable. For example the following will cause\n * unpredictable errors:\n *\n *      mdlOutputs()\n *      {\n *         char msg[256];    {ILLEGAL: to fix use \"static char msg[256];\"}\n *         sprintf(msg,\"Error due to %s\", string);\n *         ssSetErrorStatus(S,msg);\n *         return;\n *      }\n *\n * See matlabroot/simulink/src/sfunctmpl_doc.c for further details.\n */\n\n/*====================*\n * S-function methods *\n *====================*/\n\n/* Function: mdlInitializeSizes ===============================================\n * Abstract:\n *    The sizes information is used by Simulink to determine the S-function\n *    block's characteristics (number of inputs, outputs, states, etc.).\n */\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n    ssSetNumSFcnParams(S, 0);  /* Number of expected parameters */\n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {\n        /* Return if number of expected != number of actual parameters */\n        return;\n    }\n\n    ssSetNumContStates(S, 1);  /* how many continuous states? */\n    ssSetNumDiscStates(S, 0);\n\n    if (!ssSetNumInputPorts(S, 1)) return;\n    ssSetInputPortWidth(S, 0, 1);\n    /*\n     * Set direct feedthrough flag (1=yes, 0=no).\n     * A port has direct feedthrough if the input is used in either\n     * the mdlOutputs or mdlGetTimeOfNextVarHit functions.\n     */\n    ssSetInputPortDirectFeedThrough(S, 0, 1);\n\n    if (!ssSetNumOutputPorts(S, 1)) return;\n    ssSetOutputPortWidth(S, 0, 1);\n\n    ssSetNumSampleTimes(S, 1);\n\n    /* \n     * If your Fortran code uses REAL for the state, input, and/or output \n     * datatypes, use these DWorks as work areas to downcast continuous \n     * states from double to REAL before calling your code.  You could\n     * also put the work vectors in hard-coded local (stack) variables.\n     *\n     * For fixed step code, keep a copy of the variables  to be output \n     * in a DWork vector so the mdlOutputs() function can provide output \n     * data when needed. You can use as many DWork vectors as you like \n     * for both input and output (or hard-code local variables).\n     */\n    if(!ssSetNumDWork(   S, 3)) return;\n\n    ssSetDWorkWidth(     S, 0, ssGetOutputPortWidth(S,0));\n    ssSetDWorkDataType(  S, 0, SS_SINGLE); /* use SS_DOUBLE if needed */\n\n    ssSetDWorkWidth(     S, 1, ssGetInputPortWidth(S,0));\n    ssSetDWorkDataType(  S, 1, SS_SINGLE);\n\n    ssSetDWorkWidth(     S, 2, ssGetNumContStates(S));\n    ssSetDWorkDataType(  S, 2, SS_SINGLE);\n\n    ssSetNumNonsampledZCs(S, 0);\n\n    /* Specify the operating point save/restore compliance to be same as a built-in block */\n    /* see sfun_OperatingPoint.c for example of other possible settings */\n    ssSetOperatingPointCompliance(S, USE_DEFAULT_OPERATING_POINT);\n\n    ssSetOptions(S, 0);\n}\n\n\n\n/* Function: mdlInitializeSampleTimes =========================================\n * Abstract:\n *    This function is used to specify the sample time(s) for your\n *    S-function. You must register the same number of sample times as\n *    specified in ssSetNumSampleTimes.\n */\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{\n#ifdef VARIABLE_STEP\n    \n    /* \n     * For Fortran code with either no states at\n     * all or with continuous states that you want\n     * to support with variable time steps, use\n     * a sample time like this:\n     */\n    ssSetSampleTime(S, 0, CONTINUOUS_SAMPLE_TIME);\n    ssSetOffsetTime(S, 0, 0.0);\n    \n#else\n\n    /* \n     * If the Fortran code implicitly steps time\n     * at a fixed rate and you don't want to change\n     * the code, you need to use a discrete (fixed\n     * step) sample time, 1 second is chosen below.\n     */\n    ssSetSampleTime(S, 0, 0.01); /* Choose the sample time here if discrete */\n    ssSetOffsetTime(S, 0, 0.0);\n   \n#endif\n    ssSetModelReferenceSampleTimeDefaultInheritance(S);\n}\n\n\n\n#define MDL_INITIALIZE_CONDITIONS   /* Change to #undef to remove function */\n#if defined(MDL_INITIALIZE_CONDITIONS)\n  /* Function: mdlInitializeConditions ========================================\n   * Abstract:\n   *    In this function, you should initialize the continuous and discrete\n   *    states for your S-function block.  The initial states are placed\n   *    in the state vector, ssGetContStates(S) or ssGetRealDiscStates(S).\n   *    You can also perform any other initialization activities that your\n   *    S-function may require. Note, this routine will be called at the\n   *    start of simulation and if it is present in an enabled subsystem\n   *    configured to reset states, it will be call when the enabled subsystem\n   *    restarts execution to reset the states.\n   */\n  static void mdlInitializeConditions(SimStruct *S)\n  {\n      /* \n       * #undef MDL_INITIALIZE_CONDITIONS if you don't have any\n       * continuous states.\n       */\n      real_T *x = ssGetContStates(S);\n\n      /* set the values of the states (x) to start with */\n\n  }\n#endif /* MDL_INITIALIZE_CONDITIONS */\n\n\n\n#define MDL_START  /* Change to #undef to remove function */\n#if defined(MDL_START) \n  /* Function: mdlStart =======================================================\n   * Abstract:\n   *    This function is called once at start of model execution. If you\n   *    have states that should be initialized once, this is the place\n   *    to do it.\n   */\n  static void mdlStart(SimStruct *S)\n  {\n    \n  }\n#endif /*  MDL_START */\n\n\n\n/* Function: mdlOutputs =======================================================\n * Abstract:\n *    In this function, you compute the outputs of your S-function\n *    block.  The default datatype for signals in Simulink is double,\n *    but you can use other intrinsic C datatypes or even custom\n *    datatypes if you wish.  See Simulink document \"Writing S-functions\"\n *    for details on datatype topics.\n */\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n\n#ifdef VARIABLE_STEP\n\n    /*\n     *    For Variable Step Code WITH CONTINUOUS STATES\n     *    ---------------------------------------------\n     * For Fortran code that implements continuous states and uses\n     * the mdlDerivatives interface, call your Fortran code's output\n     * routines from here.  If it alters the states, you have to\n     * reset the solver.  Remember, in Simulink the continuous states\n     * must be of type double, so be prepared to copy them to float \n     * if your Fortran code uses REAL as the datatype for the states.\n     *\n     *                ... or, NO STATES\n     *                -----------------\n     * If your code has no states and you want it to execute in\n     * a continuous model, keep the uPtrs, sampleArgs, y, and\n     * sampleOutput variables and delete x, xf, and nx.  Adjust \n     * the function call accordingly.\n     */ \n    InputRealPtrsType uPtrs = ssGetInputPortRealSignalPtrs(S,0);\n    float  *sampleArgs   = (float *) ssGetDWork(S,1);\n    double *y            = ssGetOutputPortRealSignal(S,0);\n    float  *sampleOutput = (float *) ssGetDWork(S,0);\n    double *x            = ssGetContStates(S);\n    float  *xf           = (float *) ssGetDWork(S,2);\n    int     nx           = ssGetNumContStates(S);\n    int k;\n    \n    /* \n     * If the datatype in the Fortran code is REAL\n     * then you have to downcast the I/O and states from\n     * double to float as copies before sending them \n     * to your code (or change the Fortran code).\n     */\n\n    for (k=0; k < ssGetDWorkWidth(S,1); k++) {\n        sampleArgs[k] = (float) (*uPtrs[k]);\n    }\n\n    /*\n     * It is recommended to use a DWork vector to \n     * allocate the space for  the float copy of \n     * the states (if needed).\n     */\n    for (k=0; k < nx; k++) {\n        xf[k] = (float) x[k];\n    }\n    \n\n    /* ==== Call the Fortran routine (args are pass-by-reference) */\n    \n    /* nameofsub_(sampleArgs, xf, &nx, sampleOutput ); */\n\n   \n    /* \n     * If needed, convert the float outputs to the \n     * double (y) output array \n     */\n    for (k=0; k < ssGetOutputPortWidth(S,0); k++) {\n        y[k] = (double) sampleOutput[k];\n    }\n\n#else\n\n    /* \n     *    For Fixed Step Code\n     *    -------------------\n     * If the Fortran code implements discrete states (implicitly or\n     * registered with Simulink, it doesn't matter), call the code\n     * from mdlUpdates() and save the output values in a DWork vector.  \n     * The variable step solver may call mdlOutputs() several\n     * times in between calls to mdlUpdate, and you must extract the \n     * values from the DWork vector and copy them to the block output\n     * variables.\n     *\n     * Be sure that the ssSetDWorkDataType(S,0) declaration in \n     * mdlInitializeSizes() uses SS_DOUBLE for the datatype when \n     * this code is active.\n     */\n    \n    double *copyOfOutputs = (double *) ssGetDWork(S, 0);\n    double *y             = ssGetOutputPortRealSignal(S,0);\n    int     k;\n    \n    for (k=0; k < ssGetOutputSignalWidth(S,0); k++ ) {\n        y[k] = copyOfOutputs[k];\n    }\n\n#endif\n\n}\n\n\n\n#define MDL_UPDATE  /* Change to #undef to remove function */\n#if defined(MDL_UPDATE)\n/* Function: mdlUpdate ======================================================\n * Abstract:\n *    This function is called once for every major integration time step.\n *    Discrete states are typically updated here, but this function is useful\n *    for performing any tasks that should only take place once per\n *    integration step.\n */\nstatic void mdlUpdate(SimStruct *S, int_T tid)\n{\n\n#ifndef VARIABLE_STEP\n\n    /* \n     *    For Fixed Step Code Only\n     *    ------------------------\n     * If your Fortran code runs at a fixed time step that advances\n     * each time you call it, it is best to call it here instead of\n     * in mdlOutputs().  The states in the Fortran code need not be\n     * continuous if you call your code from here.\n     */\n    InputRealPtrsType uPtrs = ssGetInputPortRealSignalPtrs(S,0);\n    float  *sampleArgs   = (float *) ssGetDWork(S,1);\n    double *y            = ssGetOutputPortRealSignal(S,0);\n    float  *sampleOutput = (float *) ssGetDWork(S,0);\n    int k;\n    \n    /* \n     * If the datatype in the Fortran code is REAL\n     * then you have to downcast the I/O and states from\n     * double to float as copies before sending them \n     * to your code (or change the Fortran code).\n     */\n\n    for (k=0; k < ssGetDWorkWidth(S,1); k++) {\n        sampleArgs[k] = (float) (*uPtrs[k]);\n    }\n\n\n    /* ==== Call the Fortran routine (args are pass-by-reference) */\n    \n    /* nameofsub_(sampleArgs, sampleOutput ); */\n\n   \n    /* \n     * If needed, convert the float outputs to the \n     * double (y) output array \n     */\n    for (k=0; k < ssGetOutputPortWidth(S,0); k++) {\n        y[k] = (double) sampleOutput[k];\n    }\n\n#endif\n\n}\n#endif /* MDL_UPDATE */\n\n#define MDL_DERIVATIVES  /* Change to #undef to remove function */\n#if defined(MDL_DERIVATIVES)\n/* Function: mdlDerivatives =================================================\n * Abstract:\n *    In this function, you compute the S-function block's derivatives.\n *    The derivatives are placed in the derivative vector, ssGetdX(S).\n */\nstatic void mdlDerivatives(SimStruct *S)\n{\n\n#ifdef VARIABLE_STEP\n\n      /* \n       *    For Variable Step Code Only\n       *    ---------------------------\n       * If your Fortran code needs to support continuous states\n       * with variable timestep solvers, you need to call into\n       * your Fortran routine (or perhaps one that shares a \n       * common block but only calculates derivatives) here to \n       * extract/calculate state derivatives WITHOUT ADVANCING TIME.\n       */\n\n#endif\n\n}\n#endif /* MDL_DERIVATIVES */\n\n\n\n/* Function: mdlTerminate =====================================================\n * Abstract:\n *    In this function, you should perform any actions that are necessary\n *    at the termination of a simulation.  For example, if memory was\n *    allocated in mdlStart, this is the place to free it.\n */\nstatic void mdlTerminate(SimStruct *S)\n{\n}\n\n\n/*=============================*\n * Required S-function trailer *\n *=============================*/\n\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};