var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":true},"build":"Vehicle_Speedometer_Module/Speedometer_Module","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"/Users/jamesbond/Desktop/TFT Cluster Speedometer Module/Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: ert_main.c\n *\n * Code generated for Simulink model 'Speedometer_Module'.\n *\n * Model version                  : 1.40\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 19:46:59 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include <stddef.h>\n#include <stdio.h>            /* This example main program uses printf/fflush */\n#include \"Speedometer_Module.h\"        /* Model header file */\n\n/*\n * Associating rt_OneStep with a real-time clock or interrupt service routine\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\n * always associated with the base rate of the model.  Subrates are managed\n * by the base rate from inside the generated code.  Enabling/disabling\n * interrupts and floating point context switches are target specific.  This\n * example code indicates where these should take place relative to executing\n * the generated code step function.  Overrun behavior should be tailored to\n * your application needs.  This example simply sets an error status in the\n * real-time model and returns from rt_OneStep.\n */\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag = false;\n\n  /* Disable interrupts here */\n\n  /* Check for overrun */\n  if (OverrunFlag) {\n    rtmSetErrorStatus(Speedometer_Module_M, \"Overrun\");\n    return;\n  }\n\n  OverrunFlag = true;\n\n  /* Save FPU context here (if necessary) */\n  /* Re-enable timer or interrupt here */\n  /* Set model inputs here */\n\n  /* Step the model */\n  Speedometer_Module_step();\n\n  /* Get model outputs here */\n\n  /* Indicate task complete */\n  OverrunFlag = false;\n\n  /* Disable interrupts here */\n  /* Restore FPU context here (if necessary) */\n  /* Enable interrupts here */\n}\n\n/*\n * The example main function illustrates what is required by your\n * application code to initialize, execute, and terminate the generated code.\n * Attaching rt_OneStep to a real-time clock is target specific. This example\n * illustrates how you do this relative to initializing the model.\n */\nint_T main(int_T argc, const char *argv[])\n{\n  /* Unused arguments */\n  (void)(argc);\n  (void)(argv);\n\n  /* Initialize model */\n  Speedometer_Module_initialize();\n\n  /* Attach rt_OneStep to a timer or interrupt service routine with\n   * period 0.01 seconds (base rate of the model) here.\n   * The call syntax for rt_OneStep is\n   *\n   *  rt_OneStep();\n   */\n  printf(\"Warning: The simulation will run forever. \"\n         \"Generated ERT main won't simulate model step behavior. \"\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\n  fflush((NULL));\n  while (rtmGetErrorStatus(Speedometer_Module_M) == (NULL)) {\n    /*  Perform application tasks here */\n  }\n\n  /* Terminate model */\n  Speedometer_Module_terminate();\n  return 0;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Speedometer_Module.c","type":"source","group":"model","path":"/Users/jamesbond/Desktop/TFT Cluster Speedometer Module/Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Speedometer_Module.c\n *\n * Code generated for Simulink model 'Speedometer_Module'.\n *\n * Model version                  : 1.40\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 19:46:59 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"Speedometer_Module.h\"\n#include \"rtwtypes.h\"\n#include \"Speedometer_Module_private.h\"\n\n/* Block signals (default storage) */\nB_Speedometer_Module_T Speedometer_Module_B;\n\n/* External inputs (root inport signals with default storage) */\nExtU_Speedometer_Module_T Speedometer_Module_U;\n\n/* External outputs (root outports fed by signals with default storage) */\nExtY_Speedometer_Module_T Speedometer_Module_Y;\n\n/* Real-time model */\nstatic RT_MODEL_Speedometer_Module_T Speedometer_Module_M_;\nRT_MODEL_Speedometer_Module_T *const Speedometer_Module_M =\n  &Speedometer_Module_M_;\n\n/* Model step function */\nvoid Speedometer_Module_step(void)\n{\n  int16_T rtb_Add;\n  uint16_T rtb_Add_0;\n  uint16_T tmp;\n\n  /* Outputs for Atomic SubSystem: '<Root>/Speedometer_Module' */\n  /* Saturate: '<S5>/Saturation' incorporates:\n   *  Inport: '<Root>/Avg_VehicleSpeed'\n   */\n  if (Speedometer_Module_U.Avg_VehicleSpeed > 25000) {\n    /* Saturate: '<S5>/Saturation' */\n    Speedometer_Module_Y.Out_VehicleSpeed_Display = 25000U;\n  } else if (Speedometer_Module_U.Avg_VehicleSpeed < 200) {\n    /* Saturate: '<S5>/Saturation' */\n    Speedometer_Module_Y.Out_VehicleSpeed_Display = 200U;\n  } else {\n    /* Saturate: '<S5>/Saturation' */\n    Speedometer_Module_Y.Out_VehicleSpeed_Display =\n      Speedometer_Module_U.Avg_VehicleSpeed;\n  }\n\n  /* End of Saturate: '<S5>/Saturation' */\n\n  /* Outputs for Enabled SubSystem: '<S1>/Auxilliary_Data_Filtering' incorporates:\n   *  EnablePort: '<S2>/Enable'\n   */\n  /* Outputs for Enabled SubSystem: '<S1>/Main_Data_Filtering' incorporates:\n   *  EnablePort: '<S6>/Enable'\n   */\n  /* RelationalOperator: '<S3>/Compare' incorporates:\n   *  Constant: '<S3>/Constant'\n   *  Inport: '<Root>/Timer_Input'\n   *  Math: '<S1>/Rem'\n   */\n  if ((uint16_T)(Speedometer_Module_U.Timer_Input % 10) == 0) {\n    /* Product: '<S6>/Divide' incorporates:\n     *  Gain: '<S6>/Gain'\n     *  Inport: '<Root>/MainFilt_SpeedValue'\n     *  Saturate: '<S5>/Saturation'\n     */\n    if (Speedometer_Module_U.In_MainFilt_SpeedValue == 0U) {\n      rtb_Add_0 = MAX_uint16_T;\n\n      /* Divide by zero handler */\n    } else {\n      rtb_Add_0 = (uint16_T)((uint32_T)(uint16_T)((((65U *\n        Speedometer_Module_Y.Out_VehicleSpeed_Display) >> 7) * 2684355UL) >> 21)\n        / Speedometer_Module_U.In_MainFilt_SpeedValue);\n    }\n\n    /* Product: '<S2>/Divide' incorporates:\n     *  Constant: '<S6>/Constant'\n     *  Gain: '<S2>/Gain'\n     *  Inport: '<Root>/AuxFilt_SpeedValue'\n     *  Product: '<S6>/Divide'\n     *  Sum: '<S6>/Add'\n     */\n    if (Speedometer_Module_U.In_AuxFilt_SpeedValue == 0U) {\n      rtb_Add_0 = MAX_uint16_T;\n\n      /* Divide by zero handler */\n    } else {\n      rtb_Add_0 = (uint16_T)((uint32_T)(uint16_T)(((((uint16_T)(rtb_Add_0 - 5U) *\n        39U) >> 6) * 2684355UL) >> 21) /\n        Speedometer_Module_U.In_AuxFilt_SpeedValue);\n    }\n\n    /* Sum: '<S2>/Add' incorporates:\n     *  Constant: '<S2>/Constant'\n     *  Product: '<S2>/Divide'\n     */\n    Speedometer_Module_B.DisplaySpeed_Filter = (uint16_T)(rtb_Add_0 - 3U);\n  }\n\n  /* End of RelationalOperator: '<S3>/Compare' */\n  /* End of Outputs for SubSystem: '<S1>/Main_Data_Filtering' */\n  /* End of Outputs for SubSystem: '<S1>/Auxilliary_Data_Filtering' */\n\n  /* Sum: '<S4>/Add' incorporates:\n   *  Saturate: '<S5>/Saturation'\n   *  Sum: '<S2>/Add'\n   */\n  rtb_Add_0 = Speedometer_Module_B.DisplaySpeed_Filter;\n  if (Speedometer_Module_B.DisplaySpeed_Filter > 32767) {\n    rtb_Add_0 = 32767U;\n  }\n\n  tmp = Speedometer_Module_Y.Out_VehicleSpeed_Display;\n  if (Speedometer_Module_Y.Out_VehicleSpeed_Display > 32767) {\n    tmp = 32767U;\n  }\n\n  rtb_Add = (int16_T)(rtb_Add_0 - tmp);\n\n  /* End of Sum: '<S4>/Add' */\n\n  /* Abs: '<S4>/Abs' incorporates:\n   *  Sum: '<S4>/Add'\n   */\n  if (rtb_Add < 0) {\n    rtb_Add_0 = (uint16_T)-rtb_Add;\n  } else {\n    rtb_Add_0 = (uint16_T)rtb_Add;\n  }\n\n  /* End of Abs: '<S4>/Abs' */\n\n  /* Switch: '<S4>/Switch' incorporates:\n   *  RelationalOperator: '<S4>/Relational Operator'\n   */\n  if (rtb_Add_0 <= 150) {\n    /* Saturate: '<S5>/Saturation' incorporates:\n     *  Outport: '<Root>/Out_VehicleSpeed_Display'\n     *  Sum: '<S2>/Add'\n     */\n    Speedometer_Module_Y.Out_VehicleSpeed_Display =\n      Speedometer_Module_B.DisplaySpeed_Filter;\n  }\n\n  /* End of Switch: '<S4>/Switch' */\n  /* End of Outputs for SubSystem: '<Root>/Speedometer_Module' */\n}\n\n/* Model initialize function */\nvoid Speedometer_Module_initialize(void)\n{\n  /* (no initialization code required) */\n}\n\n/* Model terminate function */\nvoid Speedometer_Module_terminate(void)\n{\n  /* (no terminate code required) */\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Speedometer_Module.h","type":"header","group":"model","path":"/Users/jamesbond/Desktop/TFT Cluster Speedometer Module/Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Speedometer_Module.h\n *\n * Code generated for Simulink model 'Speedometer_Module'.\n *\n * Model version                  : 1.40\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 19:46:59 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Speedometer_Module_h_\n#define RTW_HEADER_Speedometer_Module_h_\n#ifndef Speedometer_Module_COMMON_INCLUDES_\n#define Speedometer_Module_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#endif                                 /* Speedometer_Module_COMMON_INCLUDES_ */\n\n#include \"Speedometer_Module_types.h\"\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n/* Block signals (default storage) */\ntypedef struct {\n  uint16_T DisplaySpeed_Filter;        /* '<S2>/Add' */\n} B_Speedometer_Module_T;\n\n/* External inputs (root inport signals with default storage) */\ntypedef struct {\n  uint8_T In_MainFilt_SpeedValue;      /* '<Root>/MainFilt_SpeedValue' */\n  uint8_T In_AuxFilt_SpeedValue;       /* '<Root>/AuxFilt_SpeedValue' */\n  uint16_T Avg_VehicleSpeed;           /* '<Root>/Avg_VehicleSpeed' */\n  uint16_T Timer_Input;                /* '<Root>/Timer_Input' */\n} ExtU_Speedometer_Module_T;\n\n/* External outputs (root outports fed by signals with default storage) */\ntypedef struct {\n  uint16_T Out_VehicleSpeed_Display;   /* '<Root>/Out_VehicleSpeed_Display' */\n} ExtY_Speedometer_Module_T;\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_Speedometer_Module_T {\n  const char_T * volatile errorStatus;\n};\n\n/* Block signals (default storage) */\nextern B_Speedometer_Module_T Speedometer_Module_B;\n\n/* External inputs (root inport signals with default storage) */\nextern ExtU_Speedometer_Module_T Speedometer_Module_U;\n\n/* External outputs (root outports fed by signals with default storage) */\nextern ExtY_Speedometer_Module_T Speedometer_Module_Y;\n\n/* Model entry point functions */\nextern void Speedometer_Module_initialize(void);\nextern void Speedometer_Module_step(void);\nextern void Speedometer_Module_terminate(void);\n\n/* Real-time Model object */\nextern RT_MODEL_Speedometer_Module_T *const Speedometer_Module_M;\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Note that this particular code originates from a subsystem build,\n * and has its own system numbers different from the parent model.\n * Refer to the system hierarchy for this subsystem below, and use the\n * MATLAB hilite_system command to trace the generated code back\n * to the parent model.  For example,\n *\n * hilite_system('Vehicle_Speedometer_Module/Speedometer_Module')    - opens subsystem Vehicle_Speedometer_Module/Speedometer_Module\n * hilite_system('Vehicle_Speedometer_Module/Speedometer_Module/Kp') - opens and selects block Kp\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'Vehicle_Speedometer_Module'\n * '<S1>'   : 'Vehicle_Speedometer_Module/Speedometer_Module'\n * '<S2>'   : 'Vehicle_Speedometer_Module/Speedometer_Module/Auxilliary_Data_Filtering'\n * '<S3>'   : 'Vehicle_Speedometer_Module/Speedometer_Module/Compare To Zero'\n * '<S4>'   : 'Vehicle_Speedometer_Module/Speedometer_Module/Display_Speed_Output'\n * '<S5>'   : 'Vehicle_Speedometer_Module/Speedometer_Module/Input_Processing'\n * '<S6>'   : 'Vehicle_Speedometer_Module/Speedometer_Module/Main_Data_Filtering'\n */\n#endif                                 /* RTW_HEADER_Speedometer_Module_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Speedometer_Module_private.h","type":"header","group":"model","path":"/Users/jamesbond/Desktop/TFT Cluster Speedometer Module/Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Speedometer_Module_private.h\n *\n * Code generated for Simulink model 'Speedometer_Module'.\n *\n * Model version                  : 1.40\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 19:46:59 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Speedometer_Module_private_h_\n#define RTW_HEADER_Speedometer_Module_private_h_\n#include \"rtwtypes.h\"\n#ifndef UCHAR_MAX\n#include <limits.h>\n#endif\n\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\n#error Code was generated for compiler with different sized uchar/char. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\n#error Code was generated for compiler with different sized ushort/short. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\n#error Code was generated for compiler with different sized uint/int. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n/* Skipping ulong/long check: insufficient preprocessor integer range. */\n#endif                            /* RTW_HEADER_Speedometer_Module_private_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Speedometer_Module_types.h","type":"header","group":"model","path":"/Users/jamesbond/Desktop/TFT Cluster Speedometer Module/Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Speedometer_Module_types.h\n *\n * Code generated for Simulink model 'Speedometer_Module'.\n *\n * Model version                  : 1.40\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 19:46:59 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Speedometer_Module_types_h_\n#define RTW_HEADER_Speedometer_Module_types_h_\n\n/* Model Code Variants */\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_Speedometer_Module_T RT_MODEL_Speedometer_Module_T;\n\n#endif                              /* RTW_HEADER_Speedometer_Module_types_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/Users/jamesbond/Desktop/TFT Cluster Speedometer Module/Speedometer_Module_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtwtypes.h\n *\n * Code generated for Simulink model 'Speedometer_Module'.\n *\n * Model version                  : 1.40\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Sun Mar 19 19:46:59 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Mac OS X)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n/*=======================================================================*\n * Target hardware information\n *   Device type: Intel->x86-64 (Mac OS X)\n *   Number of bits:     char:   8    short:   16    int:  32\n *                       long:  64\n *                       native word size:  64\n *   Byte ordering: LittleEndian\n *   Signed integer division rounds to: Zero\n *   Shift right on a signed integer as arithmetic shift: on\n *=======================================================================*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long int64_T;\ntypedef unsigned long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n/*===========================================================================*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T.                        *\n *===========================================================================*/\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n/*===========================================================================*\n * Complex number type definitions                                           *\n *===========================================================================*/\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n\n/* Block D-Work pointer type */\ntypedef void * pointer_T;\n\n#endif                                 /* RTWTYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};